# 00. Rails 시작하기

>

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./README.md)

---

<!-- TOC -->

- 

<!-- /TOC -->

## 1. Rails 준비

새로운 Rails app 만들기는 `rails new` 명령어를 이용하면 된다. app을 빌드하기 위한 기본적인 파일들을 만들어 준다.

```
$ rails new MySite 
```

`bundle install ` 새로운 레일즈 앱에 필요한 소프트웨어 패키지를 설치해준다. 패키지들을 gem이라 부르며 패키지들의 리스트는 Gemfile에서 확인 할 수 있다.

```
$ bundle install 
```

`rails server`  는 레일즈 서버를 시작하는 명령어다.

```
$ rails server 
```

`http://localhost:8000` 로 접속하면 레일즈 기본화면이 보인다. 개밥 서버는 WEBrick이라 불린다.

만약 특정 포트번호를 이용하고 싶다면 아래와 같이 명령어를 입력한다. (4001번 포트 사용 예시)

`rails s -p 4001`

## 2. Static Page

 `http://localhost:8000`에 접속을 하면 브라우저가 URL http://localhost:8000로 요청을 보낸다.

1. 브라우저가 URL `http://localhost:8000`에 대한 요청을 한다.
2.  요청이 `config/routes.rb`의 Rails 라우터에 도달하고, 라우터는 URL을 인식하여 컨트롤러로 요청을 보낸다.
3. 컨트롤러는 요청을 받고 요청에 대한 처리를 한다.
4. 컨트롤러는 요청은 뷰로 전달한다.
5. 뷰는 HTML페이지를 렌더링한다.
6. 컨트롤러는 생성된 HTML을 브라우저로 보내준다.

이러한 과정을 **request/response cycle**이라 한다.

request/response cycle을 보면, 레일즈 앱을 빌드하기 위해 3가지의 파트가 필요하다. `controller`,  `route`, `view`. 

## 3. Controller 만들기

먼저 컨트롤러부 생성해 보자.

```
rails generate controller Pages 
```

명령이 실행되면 여러가지 파일이 자동으로 생성이 된다. 그 중**app/controllers/pages_controller.rb**을 열어 확인해 보면 아래와 같은 클래스가 생성되어 있는 것을 볼 수 있다. 이 부분이 컨트롤러에 해당하는 클래스로 Pages라는 이름의 컨트롤러를 만들었기 때문에 `PagesController`라는 이름을 가지고 `ApplicationController`의 상속을 받게된다.

```ruby
class PagesController < ApplicationController 

end
```

Page컨트롤러에 home이라는 메서드를 추가해 보자.

```ruby
class PagesController < ApplicationController
  def home
  end
end
```

 새로 생성한 Pages컨트롤러에서 home 메소드를 추가했다. 레일즈 컨트롤러에 있는 메소드들은 컨트롤러 액션이라고도 한다. 우리는 home이라는 액션을 페이지 컨트롤러에 추가한 것이다.

## 4. Route 만들기

컨트롤러는 생성을 했고, 이제는 라우트를 생성해 보자.

**config/routes.rb**를 열어 아래 코드를 추가한다.

```
get 'welcome' => 'pages#home'
```

이렇게 설정을 하고  `http://localhost:8000/welcome`로 접속 하면, 레일즈는 Pages controller의 `home` action 으로 요청을 보낸단.

## 5. View 만들기

컨트롤러와 라우트를 만들었다. 이제는 뷰를 만들어 보자.

**app/views/pages/home.html.erb**파일을 열고 아래 파일을 작성해 보자.

```erb
<div class="main">
  <div class="container">
    <h1>Hello my name is Jason</h1>
    <p>I make Rails apps.</p>
  </div>
</div>
```

> css파일은 **app/assets/stylesheets/pages.css.scss**.에서 관리

## 6. Dynamic page

static pages는 모든 사용자에게 똑같은 화면을 제공해준다. 하지만 실제 서비스에서는 사용자마다 다른 데이터를 사용하여 다른 화면을 보여주는 경우가 많다. 그러한 페이지를 dynamic page라 하고 동적인 페이지를 제공하기 위해서는 데이터베이스가 필요하다. 

동적 페이지의 request-response cycle과 정적 페이지에서의 request-response cycle과 약간의 차이가 있다.

아래에서 동적 페이지의 request-response cycle을 확인해보자.

1. 브라우저가 URL `http://localhost:8000`에 대한 요청을 한다.
2.  요청이 `config/routes.rb`의 Rails 라우터에 도달하고, 라우터는 URL을 인식하여 컨트롤러로 요청을 보낸다.
3. **컨트롤러는 요청을 받고 요청에 대한 처리를 한다. 이때 액션(메소드)은 모델에게 데이터베이스로 부터 데이터를 가져오도록 요청한다.**
4. **모델은 데이터를 컨트롤 액션에게 리턴한다.**
5. 컨트롤러 액션은 데이터를 뷰로 전달해 준다.
6. 뷰는 데이터를 이용하여 HTML페이지를 렌더링한다.
7. 컨트롤러는 생성된 HTML을 브라우저로 보내준다.

Dynamic page를 생성하기 위해서는 모델을 추가로 생성해야 한다.

## 7. Model 만들기

먼저 Mesaage라는 새 application을 만들어 실습환경을 만들어 둔다.

아래 명령어를 통해 Message라는 모델을 만들 수 있다.

```
rails generate model Message
```

위 명령어를 실행하면 두 가지 파일이 생성된다.

1. a model file in **app/models/message.rb**. => 모델은 데이터 베이스의 테이블을 표현한다.
2. a migration file in **db/migrate/**. => 마이그레이션은 데이터 베이스를 업데이트 하는 방법을 의미한다.

migration file의 이름은 생성된 시간의 타임 스탬프로 시작된다.

마이그레이션 파일 내부의 `change` 메소드에 아래 내용을 추가해보자.

`t.text :content `

```ruby
class CreateMessages < ActiveRecord::Migration
  def change
    create_table :messages do |t|
      t.text :content 
      t.timestamps
    end
  end
end
```

 `change` method는 데이터 베이스에 어떤 변화를 줄지 정해준다.

위에 보면  `create_table` method를 이용하여 데이터 베이스에 메세지를 저장하기 위한 새로운 테이블을 생성한다는 것을 볼 수 있다.

`create_table`안에 추가한 `t.text :content`는 message 테이블에 `text 자료형`의 컬럼을 생성하면서 그 칼럼의 이름을 `content`로 한다는 의미이다.  `t.timestamps`는 레일즈 커맨드로 생성 시간과 업데이트 시간을 기록하는 칼럼을 추가한다.( `created_at`, `updated_at`). 이 컬럼들은 message 데이터가 생성되고 업데이트 되면 자동으로 생성되고 업데이트 된다.

이제 터미널에서 아래 명령으를 실행시켜 보자.

```
bundle exec rake db:migrate
bundle exec rake db:seed
```

 `bundle exec rake db:migrate` 명령어는 데이터베이스를 새로운 message data model와 함께 업데이트 한다. 이 명령어로 번들러에게 rake 태스크를 수행하도록 지시하는 것이다. (이 경우에는 db에 mirate 태스크를 수행하도록)

 `bundle exec rake db:seed` 명령어는 **db/seeds.rb**로 부터 샘플 데이터를 이용하여 데이터베이스를 seed한다.

## 8. Controller With Model

`Messages`라는 컨트롤러를 생성하고,  `/messages` 를 컨트롤러의 `index` action에 맵핑 시킨다.

그 후 `app/controllers/messages_controller.rb`에 아래와 같이 index 액션을 추가한다.

```ruby
def index 
  @messages = Message.all 
end
```

 `index`라는 이름을 사용한 이유는 전체 메세지를 디스플레이 하는 화면을 이용할 것이기 때문이다.

레일즈는 데이터를 처리하는 기본적인 7가지 컨트롤러 액션을 제공한다. 

> Ruby on Rails defines seven standard controller actions can be used to do common things such as display and modify **data**.

![Seven actions](https://s3.amazonaws.com/codecademy-content/projects/3/seven-actions.svg)

> If you want to create routes for all seven actions in your app, you can add a *resource route* to your routes file. This resource route below maps URLs to the Messages controller’s seven actions (`index`, `show`, `new`, `create`, `edit`, `update`, and `destroy`):
>
> ```ruby
> resources :messages
> ```
>
> If you only want to create routes for specific actions, you can use `:only` to fine tune the resource route. This line maps URLs only to the Message controller’s `index` and `show` actions.
>
> ```ruby
> resources :messages, only: [:index, :show]
> ```
>
> 이 예시에서는 index만을 사용하기 때문에`resources :messages, only: [:index]` 로 사용하면 된다.

종합해보면, 사용자가 `http://localhost:8000/messages`에 접속하면 라우터는 Messages controller’s `index` action에 요청을 전달한다.

그 후  `index` action은  모든 메시지를 데이터 베이스에서 가져와 `@messages`에 저장한다. 그 후 `@messages` 변수를 view에 전달한다. 

## 9. View with model

뷰에서는 전달받은 메세지들을 표현해야한다.

**app/views/messages/index.html.erb**.를 아래와 같이 수정해보자

```erb
<div class="header">
  <div class="container">
    <img src="http://s3.amazonaws.com/codecademy-content/courses/learn-rails/img/logo-1m.svg">
    <h1>Messenger</h1>
  </div>
</div>

<div class="messages">
  <div class="container">
   <% @messages.each do |message| %> 
    <div class="message"> 
      <p class="content"><%= message.content %></p> 
      <p class="time"><%= message.created_at %></p> 
    </div> 
  <% end %> 
  </div>
</div>
```

**index.html.erb** 은 웹 템플릿이다. 웹 템플릿이란 변수와 흐름 제어문이 들어있는 HTML 파일이다. 같은 html을 여러번 쓰는 것 보다 템플릿을 이용하여  반복되는 작업을 쉽게 표한할 수 있다.

이 경우에는

1. `<% @messages.each do |message| %>` 를 이용해 각 `@messages` 배열에 있는 각 메세지를 반복하여 접근할 수 있다.
2. 각 메세지의 컨텐츠와 생성시간을 표시한다.

레일즈에서 기본 템플릿 언어는 Embedded Ruby(ERB)이다.

## 10. DB에 데이터 생성하기

