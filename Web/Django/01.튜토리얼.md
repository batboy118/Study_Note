# 01. 장고 튜토리얼

>장고를 이용한 블로그 만들기 튜토리얼

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./README.md)

---

<!-- TOC -->

- [1. 기본 준비](#1-기본-준비)
	- [1.1. python의 가상환경](#11-python의-가상환경)
	- [1.2. 장고 설치하기](#12-장고-설치하기)
	- [1.3. PythonAnywhere 계정 만들기](#13-pythonanywhere-계정-만들기)
- [2. 장고란?](#2-장고란)
	- [2.1. 서버에 웹사이트를 요청하는 과정](#21-서버에-웹사이트를-요청하는-과정)
- [3. 시작하기](#3-시작하기)
	- [3.1. 기본 골격을 만들어 주는 스크립트](#31-기본-골격을-만들어-주는-스크립트)
	- [3.2. 기본 설정 변경](#32-기본-설정-변경)
	- [3.3. 데이터 베이스 설정](#33-데이터-베이스-설정)
	- [3.4. 만들어진 기본 웹 사이트 확인](#34-만들어진-기본-웹-사이트-확인)
- [4. 장고 모델](#4-장고-모델)
	- [4.1. 객체](#41-객체)
	- [4.2. 장고 모델](#42-장고-모델)
	- [4.3. 어플리케이션 만들기](#43-어플리케이션-만들기)
	- [4.4. 블로그 글 모델 만들기](#44-블로그-글-모델-만들기)
	- [4.5. 데이터베이스에 모델을 위한 테이블 만들기](#45-데이터베이스에-모델을-위한-테이블-만들기)
- [5. 장고 관리자](#5-장고-관리자)
- [6. 배포하기](#6-배포하기)
	- [6.1. PythonAnywhere에 블로그 복제하기](#61-pythonanywhere에-블로그-복제하기)
	- [6.2. PythonAnywhere에서 가상환경(virtualenv) 생성하고 장고 설치하기](#62-pythonanywhere에서-가상환경virtualenv-생성하고-장고-설치하기)
	- [6.3. PythonAnywhere에서 데이터베이스 생성하기](#63-pythonanywhere에서-데이터베이스-생성하기)
	- [6.4. web app으로 블로그 배포하기](#64-web-app으로-블로그-배포하기)
	- [6.5 가상환경(virtualenv) 경로 설정하기](#65-가상환경virtualenv-경로-설정하기)
	- [6.6. WSGI 파일 설정하기](#66-wsgi-파일-설정하기)
	- [6.7. 디버깅](#67-디버깅)
- [7. URL](#7-url)
	- [7.1. url 설정](#71-url-설정)
- [8. 장고 뷰 만들기](#8-장고-뷰-만들기)
	- [8.1. blog/views.py](#81-blogviewspy)
- [9. HTML 시작하기](#9-html-시작하기)
	- [9.1. HTML 만들기](#91-html-만들기)
	- [9.2 PythonAnywhere에 작업 내용 업로드 하기](#92-pythonanywhere에-작업-내용-업로드-하기)
- [10. 장고 ORM과 쿼리셋(QuerySets)](#10-장고-orm과-쿼리셋querysets)
	- [10.1. 쿼리셋이란?](#101-쿼리셋이란)
	- [10.2. 쿼리셋 예제](#102-쿼리셋-예제)

<!-- /TOC -->

## 1. 기본 준비

먼저 파이썬3를 설치한다. (자세한 내용은 구글링으로 알아본다.)

### 1.1. python의 가상환경

python의 가상환경이란, 작은 python을 새로 설치해서 내가 원하는 모듈만 운용하는 바구니라고 생각하면 된다. 운영체제 안에서 새로 운영체제를 만들어내는 가상 머신(virtual machine)과 같은 맥락이라고 볼 수 있다. 같은 모듈이라도 이 버젼 저 버젼 다른 버젼이 필요할 때나, python 프로그램을 실행하기 위한 최소한의 환경을 마련하고자 할 때, 그리고 github 등의 저장소와 연계하고자 할 때 등 가상환경은 매우 다양하게 사용될 수 있다.

- 리눅스에 가상환경 설치하기

  가상환경을 설치하기 윈하는 디렉토리로 이동한다.

  ```bash
  sudo apt get-update
  sudo apt install python3-venv
  python3 -m venv [가상환경이름]
  ```

- 가상환경 사용하기

  ```bash
  source [가상환경이름]/bin/activate
  ```

  - 콘솔의 프롬프트 앞에 가상환경이름이 나타나면 가상환경이 실행 된 것이다.
  - 가상환경에서 작업 할 때,`python`은 자동으로 올바른 버전을 참조하므로 `python3` 대신`python`를 사용할 수 있다.
  - 가상환경이 활성화 중일 때에는 파이썬의 실행환경이 가상환경을 기준으로 작동된다.

- 가상환경 비활성화 시키기

  ```bash
  deactivate
  ```

### 1.2. 장고 설치하기

가상환경이 실행된 상태에서 진행한다.

- pip 최신 버전으로 업그레이드

  ```bash
  python3 -m pip install --upgrade pip
  ```

- 장고 설치

  ```bash
  pip install django~=2.0.0
  ```

### 1.3. PythonAnywhere 계정 만들기

무료로 서버를 제공하는 업체 중 하나인 PythonAnywhere를 통해 실습을 진행하기 위해 가입을 한다.

PythonAnywhere에서 무료 계정인 "초보자(Beginner)"로 회원가입

- [www.pythonanywhere.com](https://www.pythonanywhere.com/)

> **Note** 사용자 이름을 정할 때 블로그 주소의 일부가 되는 것을 기억하세요. 예를 들어 사용자이름이 `yourusername`이면 URL은 `yourusername.pythonanywhere.com`이 된다.

## 2. 장고란?

Django는 파이썬으로 만들어진 **무료 오픈소스 웹 애플리케이션 프레임워크**(web application framework)이다. 쉽고 빠르게 웹사이트를 개발할 수 있도록 만들어진 구성요소로 이루어져 있다.

웹사이트를 구축할 때, 비슷한 유형의 요소들이 항상 필요하다.

> 회원가입, 로그인, 로그아웃과 같이 사용자 인증을 다루는 방법이나 웹사이트의 관리자 패널, 폼, 파일 업로드 등

이러한 것을 매번 만들어 주기란 어렵기 때문에, 프레임워크에서 제공하는 구성요소들을 사용하여 원하는 기능을 손쉽게 만들수 있다.

장고라는 것이 실제로 무엇을 위한 것인지 이해하기 위해서는 서버에 대해서 자세히 살펴볼 필요가 있다. 클라이언트로 부터 `request`가 서버로 도착한다면, 웹 서버는 클라이언트의 요청을 받아 클라이언트가 원하는 웹 페이지와 함께 `response`를준다. 이때 장고는 `response`에 보낼 특정 콘텐츠를 만들어 주는 역할을 한다.

### 2.1. 서버에 웹사이트를 요청하는 과정

웹 서버에 요청이 오면 요청이 장고로 전달된다. 장고 **urlresolver**는 웹 페이지의 주소를 가져와 무엇을 할지 확인한다.(*urlresolver*는 웹 사이트 주소인 URL(Uniform Resource Locator)를 통해 이해한다.). urlreslover는 패턴 목록을 가져와 URL과 맞는지 처음부터 하나씩 대조해 식별한다. 만약 일치하는 패턴이있으면, 장고는 해당 요청을 관련된 함수(*view*)에 넘겨주게된다.

> 집배원을 생각해보세요. 집배원은 거리를 걸으며 집집이 편지와 대조해서 주소와 번지를 확인합니다. 주소와 번지가 일치하면 그곳에 편지를 배달합니다. *urlresolver*가 바로 집배원과 같은 역할을 합니다.

모든 재미난 일들은 *view* 함수에서 처리된다.

예를들어, 특정 정보를 데이터베이스에서 찾을 수 있다. 만약 사용자가 데이터를 바꿔달라고 수정을 요청한다면, view함수는 해당 데이터를 수정할 수 있는 권한이 있는지 확인하고 나서, 데이터를 수정한다. 그 후 view는 답장을 생성하고 장고는 그 답장을 그 사용자의 웹 브라우저에 보내주는 역할을 한다.

## 3. 시작하기

아주 간단한 블로그사이트를 만들어보며 장고의 사용방법을 학습할 것이다.

장고에서는 디렉토리와 파일명이 매우 중요하다. 파일명을 마음대로 변경해서도 안되고 다른 곳으로 옮겨도 안된다. 장고는 중요한 것들을 찾을 수 있게 특정한 구조를 유지해야 한다.

### 3.1. 기본 골격을 만들어 주는 스크립트

```bash
django-admin startproject mysite .
```

- 현재 디렉토리에 장고를 설치하면 아래와 같은 구조가 생성 된다.

  ```
  .
  ├───manage.py
  └───mysite
          settings.py
          urls.py
          wsgi.py
          __init__.py
  ```

  `manage.py` : 사이트 관리를 도와주는 역할을 하는 스크립트. 이 스크립트로 다른 설치 작업 없이, 컴퓨터에서 웹 서버를 시작할 수 있다.

  `settings.py` : 웹사이트 설정이 있는 파일

  `urls.py` : `urlresolver`가 사용하는 패턴 목록을 포함

### 3.2. 기본 설정 변경

`mysite/settings.py` 파일

- 시간대 변경

  ```python
  TIME_ZONE = 'Asia/Seoul'
  ```

- 정적 파일 경로 추가 ( `STATIC_ROOT`을 추가 )

  ```python
  STATIC_URL = '/static/'
  STATIC_ROOT = os.path.join(BASE_DIR, 'static')
  ```

  > 정적 파일은 튜토리얼 후반부에서 CSS와 함께 다룰 예정

- 호스트 변경

  기본 상태는 `DEBUG`가`True`이고 `ALLOWED_HOSTS`가 비어 있다. 디버깅 모드에서 `ALLOWED_HOSTS` 변수가 빈 리스트일 경우 `['localhost', '127.0.0.1', '[::1]']` 의미가 된다. 즉, 로컬 호스트에서만 접속이 가능하다. 디버깅 모드를 끄면 일체 접속이 허용되지 않고 명시적으로 지정한 호스트에만 접속할 수 있다.

  예시 : `ALLOWED_HOSTS = ['example.com', 'www.example.com', 'localhost', ]`

  애플리케이션을 배포할 때 PythonAnywhere을 이용할 예정이므로 아래와 같이 설정해 준다.

  ```python
  ALLOWED_HOSTS = ['127.0.0.1', '.pythonanywhere.com']
  ```

### 3.3. 데이터 베이스 설정

사이트 내 데이터를 저장하기 위한 많은 다양한 데이터베이스 소프트웨어들이 있다. 그중에서 `sqlite3`을 사용해서 튜토리얼을 진행 한다.

이미 `mysite/settings.py`파일 안에 설치 되어있다.

```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}
```

- 데이터 베이스 생성

  아래 명령어를 실행하여 블로그에 사용할 데이터 베이스를 생성한다. manage.py가 있는 디렉토리에서 아래 명령어를 실행한다.

  ```bash
  python manage.py migrate
  ```

  > 결과
  >
  > Operations to perform:
  >   Apply all migrations: auth, admin, contenttypes, sessions
  > Running migrations:
  >   Rendering model states... DONE
  >   Applying contenttypes.0001_initial... OK
  >   Applying auth.0001_initial... OK
  >   Applying admin.0001_initial... OK
  >   Applying admin.0002_logentry_remove_auto_add... OK
  >   Applying contenttypes.0002_remove_content_type_name... OK
  >   Applying auth.0002_alter_permission_name_max_length... OK
  >   Applying auth.0003_alter_user_email_max_length... OK
  >   Applying auth.0004_alter_user_username_opts... OK
  >   Applying auth.0005_alter_user_last_login_null... OK
  >   Applying auth.0006_require_contenttypes_0002... OK
  >   Applying auth.0007_alter_validators_add_error_messages... OK
  >   Applying sessions.0001_initial... OK

### 3.4. 만들어진 기본 웹 사이트 확인

- 서버 시작하기

  ```bash
  python manage.py runserver
  ```

  > 결과
  >
  > Performing system checks...
  >
  > System check identified no issues (0 silenced).
  > May 05, 2020 - 16:40:09
  > Django version 2.0.13, using settings 'mysite.settings'
  > Starting development server at http://127.0.0.1:8000/
  > Quit the server with CONTROL-C.

  http://127.0.0.1:8000/ 를 눌러보면 로컬에서 서버에 접속할 수 있다.

> 웹 서버가 실행되는 동안 추가 명령을 입력 할 수있는 프롬프트가 표시되지 않는다. 새 텍스트를 터미널에서 입력할 수 있지만 명령은 실행되지 않는다. 웹 서버가 들어오는 요청을 수신 대기하기 위해 지속적으로 실행하고 있기 떄문이다.
>
> 웹 서버가 실행되는 동안 추가 명령을 입력하기 위해서는 새 터미널 창을 열고 virtualenv를 활성화 해야 한다.

- 웹서버 종료하기

  `Control+C` 키를 누르면 서버가 종료 된다.

## 4. 장고 모델

### 4.1. 객체

프로그래밍 개발 방법 중에는 `객체 지향 프로그래밍(object oriented programming)`이라 부르는 개념있다. 이 개발 방법은 프로그램이 어떻게 작동해야 하는지 모든 것을 하나하나 지시하는 것 대신, 모델을 만들어 그 모델이 어떤 역할을 가지고 어떻게 행동해야 하는지 정의하여 서로 상호작용할 수 있도록 만드는 것이다.

그렇다면 객체란 무엇일까? 객체란 속성과 행동을 모아놓은 것이라 할 수 있다.

예를 들어 `고양이(Cat)`라는 객체를 모델링 한다면, 고양이는 여러 속성을 가지고 있다. : `색깔`, `나이`, `분위기`(착한, 나쁜, 졸려 하는), `주인`(주인이 `사람`일 수도 있지만, 길고양이면 주인이 없으니 속성이 빈 값이 될 수 있을 것이다.) 또 `고양이는` 특정 행동을 할 수 있다: `야옹야옹하기`, `긁기`, 또는 `먹기` 등.

기본적으로 객체지향설계 개념은 현실에 존재하는 것을 속성과 행위로 나타내는 것이다. 여기서 속성은 `객체 속성(properties)`, 행위는 `메서드(methods)`로 구현된다.

그렇다면 블로그 글을 모델로 만들 수 있을까?

```
'객체'
Post(게시글)
--------
'속성'
title(제목)
text(내용)
author(글쓴이)
created_date(작성일)
published_date(게시일)
--
'메서드'
publish()
delete()
edit()
```

### 4.2. 장고 모델

블로그 글을 위한 장고 모델을 만들어 보자.

장고 안의 모델은 객체의 특별한 종류다. 이 모델을 저장하면 그 내용이 `데이터베이스`에 저장된다. 데이터베이스란 데이터들이 모여 있는 곳이고, 사용자에 대한 정보나 여러분의 블로그 글 등이 저장되어 있다. 우리는 데이터를 저장하기 위해서 여러 가지 데이터베이스를 입맛에 맞게 고를 수 있는데 여기서는 SQLite 데이터베이스를 사용한다.

> `SQlite 데이터베이스는 기본 장고 데이터베이스 어댑터`이다.

### 4.3. 어플리케이션 만들기

잘 정돈된 상태에서 시작하기 위해, 프로젝트 내부에 별도의 애플리케이션을 만들어야 한다.

- 블로그 어플리케이션 만들기

`manage.py`이 있는 디렉토리에서 실행

```bash
python manage.py startapp blog
```

> ```
> .
> ├── mysite
> |       __init__.py
> |       settings.py
> |       urls.py
> |       wsgi.py
> ├── manage.py
> └── blog
>     ├── migrations
>     |       __init__.py
>     ├── __init__.py
>     ├── admin.py
>     ├── models.py
>     ├── tests.py
>     └── views.py
> ```

- APP 항목에 blog 어플리케이션 추가하기

  `mysite/settings.py`에 INSTALLED_APPS에 blog 추가

  ```python
  INSTALLED_APPS = [
      'django.contrib.admin',
      'django.contrib.auth',
      'django.contrib.contenttypes',
      'django.contrib.sessions',
      'django.contrib.messages',
      'django.contrib.staticfiles',
      'blog',
  ]
  ```

### 4.4. 블로그 글 모델 만들기

모든 `Model` 객체는 `blog/models.py` 파일에 선언하여 모델을 만든다.

- 블로그 글 모델 정의

  `blog/models.py`파일에 아래 코드를 넣는다.

  ```python
  from django.conf import settings
  from django.db import models
  from django.utils import timezone
  ```


  class Post(models.Model):
      author = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
      title = models.CharField(max_length=200)
      text = models.TextField()
      created_date = models.DateTimeField(default=timezone.now)
      published_date = models.DateTimeField(blank=True, null=True)

      def publish(self):
          self.published_date = timezone.now()
          self.save()
    
      def __str__(self):
          return self.title
  ```

  - `class Post(models.Model): `Post class를 사용하여 모델을 정의함

    - `Post`는 모델의 이름 : 항상 클래스 이름의 첫 글자는 대문자로 쓴다.
    - `models`은 Post가 장고 모델임을 의미한다. 이 코드로 인해 장고는 Post가 데이터베이스에 저장되어야 함을 알게 된다.

  - 속성

    - `title`, `text`,  `created_date`, `published_date`, `author`
    - 속성을 정의하기 위해, 필드마다 어떤 종류의 데이터 타입을 가지는지를 정해야 한다. 데이터 타입에는 텍스트, 숫자, 날짜, 사용자 같은 다른 객체 참조가 있다.
      - `models.CharField` - 글자 수가 제한된 텍스트를 정의할 때 사용
      - `models.TextField` - 글자 수에 제한이 없는 긴 텍스트를 위한 속성
      - `models.DateTimeField` - 날짜와 시간을 의미
      - `models.ForeignKey` - 다른 모델에 대한 링크를 의미

    > 여기서 사용할 수 있는 필드는 [모델 필드 레퍼런스](https://docs.djangoproject.com/ko/3.0/ref/models/fields/#field-types)를 참조

  - 메서드
    - `def publish(self)`  : 블로그의 published_date를 설정하고, 내용을 저장
    - `def __str__(self)` : 블로그 Post 객체의 제목을 리텅

### 4.5. 데이터베이스에 모델을 위한 테이블 만들기

데이터 베이스에 Post 모델을 추가하는 작업을 해야한다. 그 전에 Post 모델을 만들었기 때문에 모델을 데이터 베이스에 반영할 수 있도록 만들어주는 마이그레이션 파일을 만들어야 한다.

- makemigrations

  ```bash
  python manage.py makemigrations blog
  ```

  > Migrations for 'blog':
  >   blog/migrations/0001_initial.py:
  >
  > \- Create model Post

  - `blog/migrations/0001_initial.py` 이 생성 되었다.

- 실제 데이터베이스에 모델 추가를 반영

  ```bash
  python manage.py migrate blog
  ```

  > Operations to perform:
  >   Apply all migrations: blog
  > Running migrations:
  >   Applying blog.0001_initial... OK

  - 데이터 베이스에 Post모델이 저장 되었다.

## 5. 장고 관리자

> 관리자 화면을 한글로 변경하고 싶다면, `settings.py`중 `LANGUAGE_CODE = 'en-us'`를 `LANGUAGE_CODE = 'ko'`로 바꾸면된다.

모델링한 글들을 장고 관리자에서 추가하거나 삭제할 수 있다. `blog/admin.py` 파일을 열어서 내용을 아래와 같이 바꾼다.

- 관리자 페이지에 모델 추가

  ```python
  from django.contrib import admin
  from .models import Post

  admin.site.register(Post)
  ```

  - `Post`모델을 import
  - 관리자 페이지에서 만든 모델을 보려면 `admin.site.register(Post)`로 모델을 등록해야 함

- 관리자 페이지 실행

  웹 서버를 다시 실행`python manage.py runserver` 후  http://127.0.0.1:8000/admin/ 에 접속하면 관리자 페이지를 볼 수 있다.

  로그인을 하기 위해서는 superuser를 생성해야 한다. 아래 명령어를 치고, 정보를 입력한다.

  ```bash
  python manage.py createsuperuser
  ```

  > ```
  > Username: admin
  > Email address: admin@admin.com
  > Password:
  > Password (again):
  > Superuser created successfully.
  > ```

  생성한 계정으로 로그인한 후 대시보드를 확인하면 Post 모델이 존재하는 것을 확인 할 수 있다.

  `Add`를 눌러 Post를 생성할 수 있다.

## 6. 배포하기

로컬에서만 확인하던 사이트를 배포를 통해 다른사람들도 볼 수 있게 할 수 있다. 앞서 가입했던  [PythonAnywhere](https://www.pythonanywhere.com/)를 활용하여 배포를 진행할 것이다. 파이썬애니웨어는 소규모 애플리케이션을 위한 무료서비스를 제공하고 있다.

설명을 하자면, `로컬 컴퓨터`는 개발 및 테스트를 수행하고, 개발이 완료되면 프로그램을 `GitHub`에 저장한다. 웹사이트는 `PythonAnywhere`에 있고 GitHub에서 코드 사본을 업데이트할 예정이다.

- 먼저 github에 레포지토리를 생성하고 코드를 커밋하여 push 한다.

  > `.gitignore` 설정
  >
  > ```
  > *.pyc
  > *~
  > __pycache__
  > [가상환경이름]
  > db.sqlite3
  > /static
  > .DS_Store
  > ```
  >
  > - db.sqlite3 이라는 파일은 모든 게시물이 저장된 로컬 데이터베이스입니다. PythonAnywhere는 다른 데이터베이스를 사용하기 때문에 저장소에 추가될 필요가 없습니다. 다른 데이터베이스로는 SQLite로도 사용하지만 보통은 SQLite보다 훨씬 많은 방문자를 보유한 웹사이트일 경우 MySQL을 사용합니다. GitHub 저장소에 SQLite 데이터베이스를 제외하고 저장하면, 지금까지 작성한 모든 게시물을 로컬에서만 사용할 수 있으므로 실제 운영하는 프로덕션 환경에서는 다시 **새 데이터베이스를 추가**해야합니다. 로컬 데이터베이스는 데이터가 삭제돼도 괜찮은 테스트 공간으로만 사용하세요.

### 6.1. PythonAnywhere에 블로그 복제하기

> 사용자 이름을 정할 때 블로그 주소의 일부가 되는 것을 기억하세요. 예를 들어 사용자이름이 `yourusername`이면 URL은 `yourusername.pythonanywhere.com`이 됩니다.

PythonAnywhere에 가입하면 대시보드 또는 "콘솔(Consoles)" 페이지를 볼 수 있다. . "배시(Bash)" 콘솔로 시작하는 옵션을 선택한다.

gitHub에 있는 코드를 끌어와 저장소를 "복제"해 PythonAnywhere로 클론한다.

```bash
git clone https://github.com/batboy118/django-tutorial.git
```

클론된 내용을 확인한다.

```bash
tree django-tutorial
```

> ```
> django-tutorial
> ├── blog
> │   ├── __init__.py
> │   ├── admin.py
> │   ├── apps.py
> │   ├── migrations
> │   │   ├── 0001_initial.py
> │   │   └── __init__.py
> │   ├── models.py
> │   ├── tests.py
> │   └── views.py
> ├── manage.py
> └── mysite
>     ├── __init__.py
>     ├── settings.py
>     ├── urls.py
>     └── wsgi.py
> ```

### 6.2. PythonAnywhere에서 가상환경(virtualenv) 생성하고 장고 설치하기

```bash
cd django-tutorial
virtualenv --python=python3.6 [가상환경이름]
source [가상환경이름]/bin/activate
pip install django~=2.0
```

### 6.3. PythonAnywhere에서 데이터베이스 생성하기

컴퓨터와 서버가 다른 점이 또 하나 있어요. 바로 다른 데이터베이스를 사용한다. 그렇기 때문에 `migrate`와 `createsuperuser`를 사용해서 다시 설정을 해주어야 한다.

```bash
python manage.py migrate
python manage.py createsuperuser
```

### 6.4. web app으로 블로그 배포하기

PythonAnywhere 대시보드로 와서 **Web**을 클릭하고 **Add a new web app**를 선택

도메인 이름을 확정한 후, 대화창에 **수동설정(manual configuration)** ("Django"옵션이 아님!!) 을 클릭

다음, **Python 3.6**을 선택하고 다음(Next)을 클릭

### 6.5 가상환경(virtualenv) 경로 설정하기

PythonAnywhere 설정 화면으로 이동 후 `Virtualenv:`섹션에서 `가상환경 경로를 입력`

: `/home/118jjh/django-tutorial/myvenv/`

### 6.6. WSGI 파일 설정하기

장고는 "WSGI 프로토콜(WSGI protocol)"을 사용해 작동한다. 이 프로토콜은 파이썬을 이용한 웹사이트를 서비스하기 위한 표준으로 PythonAnywhere에서도 지원한다. WSGI 설정을 파일을 수정해 장고 블로그를 PythonAnywhere에서 인식하게 한다.

PythonAnywhere 설정 화면으로 이동 후 `Code:`섹션에서 `/var/www/118jjh_pythonanywhere_com_wsgi.py` 을 수정한다.

모든 내용을 지우고 아래 내용을 넣는다.

```python
import os
import sys

path = '/home/118jjh/django-tutorial/'
if path not in sys.path:
    sys.path.append(path)

os.environ['DJANGO_SETTINGS_MODULE'] = 'mysite.settings'

from django.core.wsgi import get_wsgi_application
from django.contrib.staticfiles.handlers import StaticFilesHandler
application = StaticFilesHandler(get_wsgi_application())
```

> 이 파일은 PythonAnywhere에게 웹 애플리케이션의 위치와 Django 설정 파일명을 알려주는 역할을 한다.
>
> `StaticFilesHandler`는 CSS를 다루기 위한 것이다. `runserver` 명령으로 로컬 개발 중에 자동으로 처리된다.

**저장(Save)**을 누르고 **웹(Web)** 탭을 누른 후 큰 녹색 **다시 불러오기(Reload)** 버튼을 누르면 배포가 끝난다. [118jjh.pythonanywhere.com](http://118jjh.pythonanywhere.com/)

### 6.7. 디버깅

본인의 사이트에 접속할 때 오류가 보이면, 제일 먼저 **error log(오류 로그)**에서 디버깅 정보를 찾아보자. PythonAnywhere [Web tab](https://www.pythonanywhere.com/web_app_setup/)에서 이 링크를 찾을 수 있다.

## 7.URL

인터넷의 모든 페이지는 고유한 URL을 가지고 있다. 애플리케이션은 사용자가 URL을 입력하면 어떤 내용을 보여줘야 하는지 알고 있다. 장고는 `URLconf (URL configuration)`를 사용한다. `URLconf`는 장고에서 URL과 일치하는 뷰를 찾기 위한 패턴들의 집합이다.

- `mysite/urls.py`의 기본 포맷

  ```python
  """mysite URL Configuration

  [...]
  """
  from django.contrib import admin
  from django.urls import path

  urlpatterns = [
      path('admin/', admin.site.urls),
  ]
  ```

  - `path('admin/', admin.site.urls),` : 관리자 페이지

    > 장고는 `admin/`로 시작하는 모든 URL을 *view*와 대조해 찾아냅니다. 무수히 많은 URL이 `admin URL`에 포함될 수 있어 일일이 모두 쓸 수 없습니다. 그래서 정규표현식을 사용합니다.

### 7.1. url 설정

'http://127.0.0.1:8000/' 주소를 `블로그` 홈 페이지로 지정하고 여기에서 글 목록을 보여주도록 수정할 것 이다.

또한 `mysite/urls.py`파일을 깨끗한 상태로 유지하기 위해, `blog` 애플리케이션에서 메인 `mysite/urls.py`파일로 url들을 가져오도록 설정한다.

먼저 `blog.urls`를 가져오는 행을 추가해야한다. `blog.urls`를 가져오려면, `include` 함수가 필요하다. `from django.urls` 행을 찾아 `import` 뒤에 `include` 함수를 추가하면 된다.

 `mysite/urls.py`

```python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('blog.urls')),
]
```

- http://127.0.0.1:8000/ 로 들어오는 모든 접속 요청을 `blog.urls`로 전송해 추가 명령을 찾는다.

그 후, `blog/urls.py`이라는 새 파일을 생성하고 내부에 아래 내용을 추가한다.

```python
from django.urls import path
from . import views

urlpatterns = [
    path('', views.post_list, name='post_list'),
]
```

- 장고 함수인 `path`와 `blog` 애플리케이션에서 사용할 모든 `views`를 가져왔다.

- 또한, urlpatterns을 추가한다. 이제 `post_list`라는 `view`가 루트 URL에 할당되어 있다. 이 URL 패턴은 빈 문자열에 매칭이 되며, 장고 URL 확인자(resolver)는 전체 URL 경로에서 접두어(prefix)에 포함되는 도메인 이름(i.e. http://127.0.0.1:8000/)을 무시하고 받아드린다. 이 패턴은 장고에게 누군가 웹사이트에 'http://127.0.0.1:8000/' 주소로 들어왔을 때 `views.post_list`를 보여주도록 설정해 준다.

  마지막 부분인 `name='post_list'`는 URL에 이름을 붙인 것으로 뷰를 식별한다. 뷰의 이름과 같을 수도 완전히 다를 수도 있다. 이름을 붙인 URL은 프로젝트의 후반에 사용할 예정이다. 그러니 앱의 각 URL마다 이름 짓는 것은 중요하다. URL에 고유한 이름을 붙여, 외우고 부르기 쉽게 만들어야 한다.

- 하지만, 이대로 서버를 동작시키면 **no attribute 'post_list'** 에러 메세지가 뜬다. 아직, 장고가 찾고 사용하고자 하는 뷰가 없다는 의미이다.

## 8. 장고 뷰 만들기

뷰(*view*) 는 애플리케이션의 "로직"을 넣는 곳이다. 뷰는 이전 장에서 만들었던 `모델`에서 필요한 정보를 받아와서 `템플릿`에 전달하는 역할을 한다. 템플릿은 다음 장에서 만들 것이다.뷰는 파이썬의 함수일 뿐이라고 생각하면 쉽다.

### 8.1. blog/views.py

- blog/views.py

  아래와 같이 views.py 파일을 작성한다.

  ```python
  from django.shortcuts import render

  def post_list(request):
      return render(request, 'blog/post_list.html', {})
  ```

  - `post_list`라는 함수(`def`)를 만들었다. 이 함수는 `요청(request)`을 넘겨받아 `render`메서드를 호출한다. 이 함수는 `render` 메서드를 호출하여 받은(return) `blog/post_list.html`템플릿을 보여준다.
  - 하지만, 파일을 저장하고, http://127.0.0.1:8000/ 로 접속해  보면 템플릿이 존재하지 않는다는 에러가 발생한다.

## 9. HTML 시작하기

템플릿이란 서로 다른 정보를 일정한 형태로 표시하기 위해 재사용 가능한 파일을 말한다. 편지의 내용이나 수신인 주소는 달라져도 같은 디자인, 레이아웃을 사용하는 것 처럼 웹 페이지도 마찬가지 이다.

### 9.1. HTML 만들기

`blog/templates/blog`디렉토리를 만들고, 디렉토리 안에 `post_list.html`를 만든다.

> blog와 동일한 이름의 디렉토리를 또 만드는 이유는 폴더의 구조가 복잡할 경우 조금도 쉽게 찾기 위해 사용하는 관습적인 방법이다.

웹서버를 다시 작동시키고, http://127.0.0.1:8000/에 접속하면 에러는 사라졌지만 아무화면도 보이지 않을 것이다.

HTML에 내용을 입력해주면 화면이 바뀐다.

`blog/templates/blog/post_list.html`

```html
<html>
    <head>
        <title>batboy's blog</title>
    </head>
	<body>
        <div>
            <h1><a href="">batboy's Blog</a></h1>
        </div>

        <div>
            <p>published: 14.06.2014, 12:14</p>
            <h2><a href="">My first post</a></h2>
            <p>Aenean eu leo quam. Pellentesque ornare sem lacinia quam venenatis vestibulum. Donec id elit non mi porta gravida at eget metus. Fusce dapibus, tellus ac cursus commodo, tortor mauris condimentum nibh, ut fermentum massa justo sit amet risus.</p>
        </div>

        <div>
            <p>published: 14.06.2014, 12:14</p>
            <h2><a href="">My second post</a></h2>
            <p>Aenean eu leo quam. Pellentesque ornare sem lacinia quam venenatis vestibulum. Donec id elit non mi porta gravida at eget metus. Fusce dapibus, tellus ac cursus commodo, tortor mauris condimentum nibh, ut f.</p>
        </div>
    </body>
</html>

```

### 9.2 PythonAnywhere에 작업 내용 업로드 하기

github에 로컬 작업 내용을 push하고 PythonAnywhere console에서 pull한다. 그 후 Web tab에서 Relaod를 한 뒤 접속하면 업데이트 된 것을 확인할 수 있다.

## 10. 장고 ORM과 쿼리셋(QuerySets)

이번 장에서는 장고를 데이터베이스에 연결, 데이터를 저장하는 방법에 대해서 학습한다.

### 10.1. 쿼리셋이란?

핵심만 말하자면, 쿼리셋(QuerySet)은 전달받은 모델의 객체 목록이다. 쿼리셋은 데이터베이스로부터 데이터를 읽고, 필터를 걸거나 정렬을 할 수 있다.

### 10.2. 쿼리셋 예제

- 장고 인터랙티브 콘솔(interactive console)

  로컬 콘솔에서 아래 명령을 입력하면 장고 인터랙티브 콘솔이 실행된다. 파이썬과 비슷하지만 다르다. 파이썬의 모든 명령어가 사용가능하지만, 장고를 위한 공간이라고 생각하면 된다.

  ```bash
  python manage.py shell
  ```

- 모든 객체 조회하기

  특정 모델의 객체를 조회하기 위해서는, 먼저 모델을 import해야 한다.

  ```python
  >>> from blog.models import Post
  ```

  아래 명령어로 모든 객체를 조회할 수 있다.

  ```python
  >>> Post.objects.all()
  ```

- 객체 생성하기

  ```python
  >>> Post.objects.create(author=me, title='Sample title', text='Test')
  ```

  - `me`라는 사용자는 정의되어 있지 않기 때문에 오류가 발생한다. 먼저 User 모델을 불러온 후 `me`  유저를 정의해 준다.

  ```python
  >>> from django.contrib.auth.models import User
  >>> User.objects.all()
  >>> me = User.objects.get(username='admin')
  ```

- 필터링하기

  ```python
  Post.objects.filter(author=me)
  ```

  - author가 me인 Post만 확인한다.

  ```python
  Post.objects.filter(title__contains='title')
  ```

  - 제목에 title이 포함되어 있는 글자만 확인한다.

  - `title`와 `contains` 사이에 있는 밑줄(`_`)이 2개(`__`)

    `장고 ORM`은 필드 이름("title")과 연산자과 필터("contains")를 밑줄 2개를 사용해 구분한다. 밑줄 1개만 입력한다면, `FieldError: Cannot resolve keyword title_contains`라는 오류가 뜬다.

  ```python
  >>> from django.utils import timezone
  >>> Post.objects.filter(published_date__lte=timezone.now())
  ```

  - `게시일(published_date)`로 과거에 작성한 글을 필터링하여 목록을 불러올 수 있다.
  - 위 결과 `[]`아무것도 출력되지 않았다면, publish()된 것이 없기 때문이다.

  ```python
  >>> post = Post.objects.get(title="Sample title")
  >>> post.publish()
  >>> Post.objects.filter(published_date__lte=timezone.now())
  ```

- 정렬하기

  `created_date`필드를 정렬

  ```python
  >>> Post.objects.order_by('created_date')
  ```

  - `-`을 맨 앞에 붙여주면 내림차순 정렬도 가능하다.

  ```python
  >>> Post.objects.order_by('-created_date')
  ```

- 쿼리셋 연결하기

  퀴리셋들을 함께 연결하는 것을 `chaining`이라 한다.

  아래 체이닝은, 필터와 정렬을 진행한 체이닝이다.

  ```python
  >>> Post.objects.filter(published_date__lte=timezone.now()).order_by('published_date')
  ```
