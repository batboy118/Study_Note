# 01. 장고 튜토리얼

>장고를 이용한 블로그 만들기 튜토리얼

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./README.md)

---

<!-- TOC -->

- [1. 기본 준비](#1-기본-준비)
	- [1.1. python의 가상환경](#11-python의-가상환경)
	- [1.2. 장고 설치하기](#12-장고-설치하기)
	- [1.3. PythonAnywhere 계정 만들기](#13-pythonanywhere-계정-만들기)
- [2. 장고란?](#2-장고란)
	- [2.1. 서버에 웹사이트를 요청하는 과정](#21-서버에-웹사이트를-요청하는-과정)
- [3. 시작하기](#3-시작하기)
	- [3.1. 기본 골격을 만들어 주는 스크립트](#31-기본-골격을-만들어-주는-스크립트)
	- [3.2. 기본 설정 변경](#32-기본-설정-변경)
	- [3.3. 데이터 베이스 설정](#33-데이터-베이스-설정)
	- [3.4. 만들어진 기본 웹 사이트 확인](#34-만들어진-기본-웹-사이트-확인)
- [4. 장고 모델](#4-장고-모델)
	- [4.1. 객체](#41-객체)
	- [4.2. 장고 모델](#42-장고-모델)
	- [4.3. 어플리케이션 만들기](#43-어플리케이션-만들기)
	- [4.4. 블로그 글 모델 만들기](#44-블로그-글-모델-만들기)
	- [4.5. 데이터베이스에 모델을 위한 테이블 만들기](#45-데이터베이스에-모델을-위한-테이블-만들기)
- [5. 장고 관리자](#5-장고-관리자)
- [6. 배포하기](#6-배포하기)
	- [6.1. PythonAnywhere에 블로그 복제하기](#61-pythonanywhere에-블로그-복제하기)
	- [6.2. PythonAnywhere에서 가상환경(virtualenv) 생성하고 장고 설치하기](#62-pythonanywhere에서-가상환경virtualenv-생성하고-장고-설치하기)
	- [6.3. PythonAnywhere에서 데이터베이스 생성하기](#63-pythonanywhere에서-데이터베이스-생성하기)
	- [6.4. web app으로 블로그 배포하기](#64-web-app으로-블로그-배포하기)
	- [6.5 가상환경(virtualenv) 경로 설정하기](#65-가상환경virtualenv-경로-설정하기)
	- [6.6. WSGI 파일 설정하기](#66-wsgi-파일-설정하기)
	- [6.7. 디버깅](#67-디버깅)
- [7. URL](#7-url)
	- [7.1. url 설정](#71-url-설정)
- [8. 장고 뷰 만들기](#8-장고-뷰-만들기)
	- [8.1. blog/views.py](#81-blogviewspy)
- [9. HTML 시작하기](#9-html-시작하기)
	- [9.1. HTML 만들기](#91-html-만들기)
	- [9.2 PythonAnywhere에 작업 내용 업로드 하기](#92-pythonanywhere에-작업-내용-업로드-하기)
- [10. 장고 ORM과 쿼리셋(QuerySets)](#10-장고-orm과-쿼리셋querysets)
	- [10.1. 쿼리셋이란?](#101-쿼리셋이란)
	- [10.2. 쿼리셋 예제](#102-쿼리셋-예제)
- [11. 템플릿 동적 데이터](#11-템플릿-동적-데이터)
	- [11.1. QuerySet](#111-queryset)
- [12. 장고 템플릿](#12-장고-템플릿)
	- [12.1. 템플릿 태그](#121-템플릿-태그)
- [13. CSS 꾸미기](#13-css-꾸미기)
	- [13.1. 부트스트랩](#131-부트스트랩)
	- [13.2. 정적 파일](#132-정적-파일)
	- [13.3. CSS 파일](#133-css-파일)
- [14. 템플릿 확장](#14-템플릿-확장)
	- [14.1 기본 템플릿 생성하기](#141-기본-템플릿-생성하기)
- [15. 애플리케이션 확장하기](#15-애플리케이션-확장하기)
	- [15.1. Post에 템플릿 링크 만들기](#151-post에-템플릿-링크-만들기)
	- [15.2. Post 상세 페이지 URL 만들기](#152-post-상세-페이지-url-만들기)
	- [15.3. Post 상세 페이지 내 뷰 추가하기](#153-post-상세-페이지-내-뷰-추가하기)
	- [15.4. Post 상세 페이지 템플릿 만들기](#154-post-상세-페이지-템플릿-만들기)
- [16. 장고 폼](#16-장고-폼)
	- [16.1. 폼과 페이지 링크](#161-폼과-페이지-링크)
	- [16.2. URL](#162-url)
	- [16.3. `postnew` view](#163-postnew-view)
	- [16.4. 템플릿](#164-템플릿)
	- [16.5. 폼 저장하기](#165-폼-저장하기)
	- [16.6. 폼 검증하기](#166-폼-검증하기)
	- [16.7. 폼 수정하기](#167-폼-수정하기)
	- [16.8. 보안](#168-보안)

<!-- /TOC -->

## 1. 기본 준비

먼저 파이썬3를 설치한다. (자세한 내용은 구글링으로 알아본다.)

### 1.1. python의 가상환경

python의 가상환경이란, 작은 python을 새로 설치해서 내가 원하는 모듈만 운용하는 바구니라고 생각하면 된다. 운영체제 안에서 새로 운영체제를 만들어내는 가상 머신(virtual machine)과 같은 맥락이라고 볼 수 있다. 같은 모듈이라도 이 버젼 저 버젼 다른 버젼이 필요할 때나, python 프로그램을 실행하기 위한 최소한의 환경을 마련하고자 할 때, 그리고 github 등의 저장소와 연계하고자 할 때 등 가상환경은 매우 다양하게 사용될 수 있다.

- 리눅스에 가상환경 설치하기

  가상환경을 설치하기 윈하는 디렉토리로 이동한다.

  ```bash
  sudo apt get-update
  sudo apt install python3-venv
  python3 -m venv [가상환경이름]
  ```

- 가상환경 사용하기

  ```bash
  source [가상환경이름]/bin/activate
  ```

  - 콘솔의 프롬프트 앞에 가상환경이름이 나타나면 가상환경이 실행 된 것이다.
  - 가상환경에서 작업 할 때,`python`은 자동으로 올바른 버전을 참조하므로 `python3` 대신`python`를 사용할 수 있다.
  - 가상환경이 활성화 중일 때에는 파이썬의 실행환경이 가상환경을 기준으로 작동된다.

- 가상환경 비활성화 시키기

  ```bash
  deactivate
  ```

### 1.2. 장고 설치하기

가상환경이 실행된 상태에서 진행한다.

- pip 최신 버전으로 업그레이드

  ```bash
  python3 -m pip install --upgrade pip
  ```

- 장고 설치

  ```bash
  pip install django~=2.0.0
  ```

### 1.3. PythonAnywhere 계정 만들기

무료로 서버를 제공하는 업체 중 하나인 PythonAnywhere를 통해 실습을 진행하기 위해 가입을 한다.

PythonAnywhere에서 무료 계정인 "초보자(Beginner)"로 회원가입

- [www.pythonanywhere.com](https://www.pythonanywhere.com/)

> **Note** 사용자 이름을 정할 때 블로그 주소의 일부가 되는 것을 기억하세요. 예를 들어 사용자이름이 `yourusername`이면 URL은 `yourusername.pythonanywhere.com`이 된다.

## 2. 장고란?

Django는 파이썬으로 만들어진 **무료 오픈소스 웹 애플리케이션 프레임워크**(web application framework)이다. 쉽고 빠르게 웹사이트를 개발할 수 있도록 만들어진 구성요소로 이루어져 있다.

웹사이트를 구축할 때, 비슷한 유형의 요소들이 항상 필요하다.

> 회원가입, 로그인, 로그아웃과 같이 사용자 인증을 다루는 방법이나 웹사이트의 관리자 패널, 폼, 파일 업로드 등

이러한 것을 매번 만들어 주기란 어렵기 때문에, 프레임워크에서 제공하는 구성요소들을 사용하여 원하는 기능을 손쉽게 만들수 있다.

장고라는 것이 실제로 무엇을 위한 것인지 이해하기 위해서는 서버에 대해서 자세히 살펴볼 필요가 있다. 클라이언트로 부터 `request`가 서버로 도착한다면, 웹 서버는 클라이언트의 요청을 받아 클라이언트가 원하는 웹 페이지와 함께 `response`를준다. 이때 장고는 `response`에 보낼 특정 콘텐츠를 만들어 주는 역할을 한다.

### 2.1. 서버에 웹사이트를 요청하는 과정

웹 서버에 요청이 오면 요청이 장고로 전달된다. 장고 **urlresolver**는 웹 페이지의 주소를 가져와 무엇을 할지 확인한다.(*urlresolver*는 웹 사이트 주소인 URL(Uniform Resource Locator)를 통해 이해한다.). urlreslover는 패턴 목록을 가져와 URL과 맞는지 처음부터 하나씩 대조해 식별한다. 만약 일치하는 패턴이있으면, 장고는 해당 요청을 관련된 함수(*view*)에 넘겨주게된다.

> 집배원을 생각해보세요. 집배원은 거리를 걸으며 집집이 편지와 대조해서 주소와 번지를 확인합니다. 주소와 번지가 일치하면 그곳에 편지를 배달합니다. *urlresolver*가 바로 집배원과 같은 역할을 합니다.

모든 재미난 일들은 *view* 함수에서 처리된다.

예를들어, 특정 정보를 데이터베이스에서 찾을 수 있다. 만약 사용자가 데이터를 바꿔달라고 수정을 요청한다면, view함수는 해당 데이터를 수정할 수 있는 권한이 있는지 확인하고 나서, 데이터를 수정한다. 그 후 view는 답장을 생성하고 장고는 그 답장을 그 사용자의 웹 브라우저에 보내주는 역할을 한다.

## 3. 시작하기

아주 간단한 블로그사이트를 만들어보며 장고의 사용방법을 학습할 것이다.

장고에서는 디렉토리와 파일명이 매우 중요하다. 파일명을 마음대로 변경해서도 안되고 다른 곳으로 옮겨도 안된다. 장고는 중요한 것들을 찾을 수 있게 특정한 구조를 유지해야 한다.

### 3.1. 기본 골격을 만들어 주는 스크립트

```bash
django-admin startproject mysite .
```

- 현재 디렉토리에 장고를 설치하면 아래와 같은 구조가 생성 된다.

  ```
  .
  ├───manage.py
  └───mysite
          settings.py
          urls.py
          wsgi.py
          __init__.py
  ```

  `manage.py` : 사이트 관리를 도와주는 역할을 하는 스크립트. 이 스크립트로 다른 설치 작업 없이, 컴퓨터에서 웹 서버를 시작할 수 있다.

  `settings.py` : 웹사이트 설정이 있는 파일

  `urls.py` : `urlresolver`가 사용하는 패턴 목록을 포함

### 3.2. 기본 설정 변경

`mysite/settings.py` 파일

- 시간대 변경

  ```python
  TIME_ZONE = 'Asia/Seoul'
  ```

- 정적 파일 경로 추가 ( `STATIC_ROOT`을 추가 )

  ```python
  STATIC_URL = '/static/'
  STATIC_ROOT = os.path.join(BASE_DIR, 'static')
  ```

  > 정적 파일은 튜토리얼 후반부에서 CSS와 함께 다룰 예정

- 호스트 변경

  기본 상태는 `DEBUG`가`True`이고 `ALLOWED_HOSTS`가 비어 있다. 디버깅 모드에서 `ALLOWED_HOSTS` 변수가 빈 리스트일 경우 `['localhost', '127.0.0.1', '[::1]']` 의미가 된다. 즉, 로컬 호스트에서만 접속이 가능하다. 디버깅 모드를 끄면 일체 접속이 허용되지 않고 명시적으로 지정한 호스트에만 접속할 수 있다.

  예시 : `ALLOWED_HOSTS = ['example.com', 'www.example.com', 'localhost', ]`

  애플리케이션을 배포할 때 PythonAnywhere을 이용할 예정이므로 아래와 같이 설정해 준다.

  ```python
  ALLOWED_HOSTS = ['127.0.0.1', '.pythonanywhere.com']
  ```

### 3.3. 데이터 베이스 설정

사이트 내 데이터를 저장하기 위한 많은 다양한 데이터베이스 소프트웨어들이 있다. 그중에서 `sqlite3`을 사용해서 튜토리얼을 진행 한다.

이미 `mysite/settings.py`파일 안에 설치 되어있다.

```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}
```

- 데이터 베이스 생성

  아래 명령어를 실행하여 블로그에 사용할 데이터 베이스를 생성한다. manage.py가 있는 디렉토리에서 아래 명령어를 실행한다.

  ```bash
  python manage.py migrate
  ```

  > 결과
  >
  > Operations to perform:
  >   Apply all migrations: auth, admin, contenttypes, sessions
  > Running migrations:
  >   Rendering model states... DONE
  >   Applying contenttypes.0001_initial... OK
  >   Applying auth.0001_initial... OK
  >   Applying admin.0001_initial... OK
  >   Applying admin.0002_logentry_remove_auto_add... OK
  >   Applying contenttypes.0002_remove_content_type_name... OK
  >   Applying auth.0002_alter_permission_name_max_length... OK
  >   Applying auth.0003_alter_user_email_max_length... OK
  >   Applying auth.0004_alter_user_username_opts... OK
  >   Applying auth.0005_alter_user_last_login_null... OK
  >   Applying auth.0006_require_contenttypes_0002... OK
  >   Applying auth.0007_alter_validators_add_error_messages... OK
  >   Applying sessions.0001_initial... OK

### 3.4. 만들어진 기본 웹 사이트 확인

- 서버 시작하기

  ```bash
  python manage.py runserver
  ```

  > 결과
  >
  > Performing system checks...
  >
  > System check identified no issues (0 silenced).
  > May 05, 2020 - 16:40:09
  > Django version 2.0.13, using settings 'mysite.settings'
  > Starting development server at http://127.0.0.1:8000/
  > Quit the server with CONTROL-C.

  http://127.0.0.1:8000/ 를 눌러보면 로컬에서 서버에 접속할 수 있다.

> 웹 서버가 실행되는 동안 추가 명령을 입력 할 수있는 프롬프트가 표시되지 않는다. 새 텍스트를 터미널에서 입력할 수 있지만 명령은 실행되지 않는다. 웹 서버가 들어오는 요청을 수신 대기하기 위해 지속적으로 실행하고 있기 떄문이다.
>
> 웹 서버가 실행되는 동안 추가 명령을 입력하기 위해서는 새 터미널 창을 열고 virtualenv를 활성화 해야 한다.

- 웹서버 종료하기

  `Control+C` 키를 누르면 서버가 종료 된다.

## 4. 장고 모델

### 4.1. 객체

프로그래밍 개발 방법 중에는 `객체 지향 프로그래밍(object oriented programming)`이라 부르는 개념있다. 이 개발 방법은 프로그램이 어떻게 작동해야 하는지 모든 것을 하나하나 지시하는 것 대신, 모델을 만들어 그 모델이 어떤 역할을 가지고 어떻게 행동해야 하는지 정의하여 서로 상호작용할 수 있도록 만드는 것이다.

그렇다면 객체란 무엇일까? 객체란 속성과 행동을 모아놓은 것이라 할 수 있다.

예를 들어 `고양이(Cat)`라는 객체를 모델링 한다면, 고양이는 여러 속성을 가지고 있다. : `색깔`, `나이`, `분위기`(착한, 나쁜, 졸려 하는), `주인`(주인이 `사람`일 수도 있지만, 길고양이면 주인이 없으니 속성이 빈 값이 될 수 있을 것이다.) 또 `고양이는` 특정 행동을 할 수 있다: `야옹야옹하기`, `긁기`, 또는 `먹기` 등.

기본적으로 객체지향설계 개념은 현실에 존재하는 것을 속성과 행위로 나타내는 것이다. 여기서 속성은 `객체 속성(properties)`, 행위는 `메서드(methods)`로 구현된다.

그렇다면 블로그 글을 모델로 만들 수 있을까?

```
'객체'
Post(게시글)
--------
'속성'
title(제목)
text(내용)
author(글쓴이)
created_date(작성일)
published_date(게시일)
--
'메서드'
publish()
delete()
edit()
```

### 4.2. 장고 모델

블로그 글을 위한 장고 모델을 만들어 보자.

장고 안의 모델은 객체의 특별한 종류다. 이 모델을 저장하면 그 내용이 `데이터베이스`에 저장된다. 데이터베이스란 데이터들이 모여 있는 곳이고, 사용자에 대한 정보나 여러분의 블로그 글 등이 저장되어 있다. 우리는 데이터를 저장하기 위해서 여러 가지 데이터베이스를 입맛에 맞게 고를 수 있는데 여기서는 SQLite 데이터베이스를 사용한다.

> `SQlite 데이터베이스는 기본 장고 데이터베이스 어댑터`이다.

### 4.3. 어플리케이션 만들기

잘 정돈된 상태에서 시작하기 위해, 프로젝트 내부에 별도의 애플리케이션을 만들어야 한다.

- 블로그 어플리케이션 만들기

`manage.py`이 있는 디렉토리에서 실행

```bash
python manage.py startapp blog
```

> ```
> .
> ├── mysite
> |       __init__.py
> |       settings.py
> |       urls.py
> |       wsgi.py
> ├── manage.py
> └── blog
>     ├── migrations
>     |       __init__.py
>     ├── __init__.py
>     ├── admin.py
>     ├── models.py
>     ├── tests.py
>     └── views.py
> ```

- APP 항목에 blog 어플리케이션 추가하기

  `mysite/settings.py`에 INSTALLED_APPS에 blog 추가

  ```python
  INSTALLED_APPS = [
      'django.contrib.admin',
      'django.contrib.auth',
      'django.contrib.contenttypes',
      'django.contrib.sessions',
      'django.contrib.messages',
      'django.contrib.staticfiles',
      'blog',
  ]
  ```

### 4.4. 블로그 글 모델 만들기

모든 `Model` 객체는 `blog/models.py` 파일에 선언하여 모델을 만든다.

- 블로그 글 모델 정의

  `blog/models.py`파일에 아래 코드를 넣는다.

  ```python
  from django.conf import settings
  from django.db import models
  from django.utils import timezone
  ```


  class Post(models.Model):
      author = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
      title = models.CharField(max_length=200)
      text = models.TextField()
      created_date = models.DateTimeField(default=timezone.now)
      published_date = models.DateTimeField(blank=True, null=True)

      def publish(self):
          self.published_date = timezone.now()
          self.save()

      def __str__(self):
          return self.title
  ```

  - `class Post(models.Model): `Post class를 사용하여 모델을 정의함

    - `Post`는 모델의 이름 : 항상 클래스 이름의 첫 글자는 대문자로 쓴다.
    - `models`은 Post가 장고 모델임을 의미한다. 이 코드로 인해 장고는 Post가 데이터베이스에 저장되어야 함을 알게 된다.

  - 속성

    - `title`, `text`,  `created_date`, `published_date`, `author`
    - 속성을 정의하기 위해, 필드마다 어떤 종류의 데이터 타입을 가지는지를 정해야 한다. 데이터 타입에는 텍스트, 숫자, 날짜, 사용자 같은 다른 객체 참조가 있다.
      - `models.CharField` - 글자 수가 제한된 텍스트를 정의할 때 사용
      - `models.TextField` - 글자 수에 제한이 없는 긴 텍스트를 위한 속성
      - `models.DateTimeField` - 날짜와 시간을 의미
      - `models.ForeignKey` - 다른 모델에 대한 링크를 의미

    > 여기서 사용할 수 있는 필드는 [모델 필드 레퍼런스](https://docs.djangoproject.com/ko/3.0/ref/models/fields/#field-types)를 참조

  - 메서드
    - `def publish(self)`  : 블로그의 published_date를 설정하고, 내용을 저장
    - `def __str__(self)` : 블로그 Post 객체의 제목을 리텅

### 4.5. 데이터베이스에 모델을 위한 테이블 만들기

데이터 베이스에 Post 모델을 추가하는 작업을 해야한다. 그 전에 Post 모델을 만들었기 때문에 모델을 데이터 베이스에 반영할 수 있도록 만들어주는 마이그레이션 파일을 만들어야 한다.

- makemigrations

  ```bash
  python manage.py makemigrations blog
  ```

  > Migrations for 'blog':
  >   blog/migrations/0001_initial.py:
  >
  > \- Create model Post

  - `blog/migrations/0001_initial.py` 이 생성 되었다.

- 실제 데이터베이스에 모델 추가를 반영

  ```bash
  python manage.py migrate blog
  ```

  > Operations to perform:
  >   Apply all migrations: blog
  > Running migrations:
  >   Applying blog.0001_initial... OK

  - 데이터 베이스에 Post모델이 저장 되었다.

## 5. 장고 관리자

> 관리자 화면을 한글로 변경하고 싶다면, `settings.py`중 `LANGUAGE_CODE = 'en-us'`를 `LANGUAGE_CODE = 'ko'`로 바꾸면된다.

모델링한 글들을 장고 관리자에서 추가하거나 삭제할 수 있다. `blog/admin.py` 파일을 열어서 내용을 아래와 같이 바꾼다.

- 관리자 페이지에 모델 추가

  ```python
  from django.contrib import admin
  from .models import Post

  admin.site.register(Post)
  ```

  - `Post`모델을 import
  - 관리자 페이지에서 만든 모델을 보려면 `admin.site.register(Post)`로 모델을 등록해야 함

- 관리자 페이지 실행

  웹 서버를 다시 실행`python manage.py runserver` 후  http://127.0.0.1:8000/admin/ 에 접속하면 관리자 페이지를 볼 수 있다.

  로그인을 하기 위해서는 superuser를 생성해야 한다. 아래 명령어를 치고, 정보를 입력한다.

  ```bash
  python manage.py createsuperuser
  ```

  > ```
  > Username: admin
  > Email address: admin@admin.com
  > Password:
  > Password (again):
  > Superuser created successfully.
  > ```

  생성한 계정으로 로그인한 후 대시보드를 확인하면 Post 모델이 존재하는 것을 확인 할 수 있다.

  `Add`를 눌러 Post를 생성할 수 있다.

## 6. 배포하기

로컬에서만 확인하던 사이트를 배포를 통해 다른사람들도 볼 수 있게 할 수 있다. 앞서 가입했던  [PythonAnywhere](https://www.pythonanywhere.com/)를 활용하여 배포를 진행할 것이다. 파이썬애니웨어는 소규모 애플리케이션을 위한 무료서비스를 제공하고 있다.

설명을 하자면, `로컬 컴퓨터`는 개발 및 테스트를 수행하고, 개발이 완료되면 프로그램을 `GitHub`에 저장한다. 웹사이트는 `PythonAnywhere`에 있고 GitHub에서 코드 사본을 업데이트할 예정이다.

- 먼저 github에 레포지토리를 생성하고 코드를 커밋하여 push 한다.

  > `.gitignore` 설정
  >
  > ```
  > *.pyc
  > *~
  > __pycache__
  > [가상환경이름]
  > db.sqlite3
  > /static
  > .DS_Store
  > ```
  >
  > - db.sqlite3 이라는 파일은 모든 게시물이 저장된 로컬 데이터베이스입니다. PythonAnywhere는 다른 데이터베이스를 사용하기 때문에 저장소에 추가될 필요가 없습니다. 다른 데이터베이스로는 SQLite로도 사용하지만 보통은 SQLite보다 훨씬 많은 방문자를 보유한 웹사이트일 경우 MySQL을 사용합니다. GitHub 저장소에 SQLite 데이터베이스를 제외하고 저장하면, 지금까지 작성한 모든 게시물을 로컬에서만 사용할 수 있으므로 실제 운영하는 프로덕션 환경에서는 다시 **새 데이터베이스를 추가**해야합니다. 로컬 데이터베이스는 데이터가 삭제돼도 괜찮은 테스트 공간으로만 사용하세요.

### 6.1. PythonAnywhere에 블로그 복제하기

> 사용자 이름을 정할 때 블로그 주소의 일부가 되는 것을 기억하세요. 예를 들어 사용자이름이 `yourusername`이면 URL은 `yourusername.pythonanywhere.com`이 됩니다.

PythonAnywhere에 가입하면 대시보드 또는 "콘솔(Consoles)" 페이지를 볼 수 있다. . "배시(Bash)" 콘솔로 시작하는 옵션을 선택한다.

gitHub에 있는 코드를 끌어와 저장소를 "복제"해 PythonAnywhere로 클론한다.

```bash
git clone https://github.com/batboy118/django-tutorial.git
```

클론된 내용을 확인한다.

```bash
tree django-tutorial
```

> ```
> django-tutorial
> ├── blog
> │   ├── __init__.py
> │   ├── admin.py
> │   ├── apps.py
> │   ├── migrations
> │   │   ├── 0001_initial.py
> │   │   └── __init__.py
> │   ├── models.py
> │   ├── tests.py
> │   └── views.py
> ├── manage.py
> └── mysite
>     ├── __init__.py
>     ├── settings.py
>     ├── urls.py
>     └── wsgi.py
> ```

### 6.2. PythonAnywhere에서 가상환경(virtualenv) 생성하고 장고 설치하기

```bash
cd django-tutorial
virtualenv --python=python3.6 [가상환경이름]
source [가상환경이름]/bin/activate
pip install django~=2.0
```

### 6.3. PythonAnywhere에서 데이터베이스 생성하기

컴퓨터와 서버가 다른 점이 또 하나 있어요. 바로 다른 데이터베이스를 사용한다. 그렇기 때문에 `migrate`와 `createsuperuser`를 사용해서 다시 설정을 해주어야 한다.

```bash
python manage.py migrate
python manage.py createsuperuser
```

### 6.4. web app으로 블로그 배포하기

PythonAnywhere 대시보드로 와서 **Web**을 클릭하고 **Add a new web app**를 선택

도메인 이름을 확정한 후, 대화창에 **수동설정(manual configuration)** ("Django"옵션이 아님!!) 을 클릭

다음, **Python 3.6**을 선택하고 다음(Next)을 클릭

### 6.5 가상환경(virtualenv) 경로 설정하기

PythonAnywhere 설정 화면으로 이동 후 `Virtualenv:`섹션에서 `가상환경 경로를 입력`

: `/home/118jjh/django-tutorial/myvenv/`

### 6.6. WSGI 파일 설정하기

장고는 "WSGI 프로토콜(WSGI protocol)"을 사용해 작동한다. 이 프로토콜은 파이썬을 이용한 웹사이트를 서비스하기 위한 표준으로 PythonAnywhere에서도 지원한다. WSGI 설정을 파일을 수정해 장고 블로그를 PythonAnywhere에서 인식하게 한다.

PythonAnywhere 설정 화면으로 이동 후 `Code:`섹션에서 `/var/www/118jjh_pythonanywhere_com_wsgi.py` 을 수정한다.

모든 내용을 지우고 아래 내용을 넣는다.

```python
import os
import sys

path = '/home/118jjh/django-tutorial/'
if path not in sys.path:
    sys.path.append(path)

os.environ['DJANGO_SETTINGS_MODULE'] = 'mysite.settings'

from django.core.wsgi import get_wsgi_application
from django.contrib.staticfiles.handlers import StaticFilesHandler
application = StaticFilesHandler(get_wsgi_application())
```

> 이 파일은 PythonAnywhere에게 웹 애플리케이션의 위치와 Django 설정 파일명을 알려주는 역할을 한다.
>
> `StaticFilesHandler`는 CSS를 다루기 위한 것이다. `runserver` 명령으로 로컬 개발 중에 자동으로 처리된다.

**저장(Save)**을 누르고 **웹(Web)** 탭을 누른 후 큰 녹색 **다시 불러오기(Reload)** 버튼을 누르면 배포가 끝난다. [118jjh.pythonanywhere.com](http://118jjh.pythonanywhere.com/)

### 6.7. 디버깅

본인의 사이트에 접속할 때 오류가 보이면, 제일 먼저 **error log(오류 로그)**에서 디버깅 정보를 찾아보자. PythonAnywhere [Web tab](https://www.pythonanywhere.com/web_app_setup/)에서 이 링크를 찾을 수 있다.

## 7.URL

인터넷의 모든 페이지는 고유한 URL을 가지고 있다. 애플리케이션은 사용자가 URL을 입력하면 어떤 내용을 보여줘야 하는지 알고 있다. 장고는 `URLconf (URL configuration)`를 사용한다. `URLconf`는 장고에서 URL과 일치하는 뷰를 찾기 위한 패턴들의 집합이다.

- `mysite/urls.py`의 기본 포맷

  ```python
  """mysite URL Configuration

  [...]
  """
  from django.contrib import admin
  from django.urls import path

  urlpatterns = [
      path('admin/', admin.site.urls),
  ]
  ```

  - `path('admin/', admin.site.urls),` : 관리자 페이지

    > 장고는 `admin/`로 시작하는 모든 URL을 *view*와 대조해 찾아냅니다. 무수히 많은 URL이 `admin URL`에 포함될 수 있어 일일이 모두 쓸 수 없습니다. 그래서 정규표현식을 사용합니다.

### 7.1. url 설정

'http://127.0.0.1:8000/' 주소를 `블로그` 홈 페이지로 지정하고 여기에서 글 목록을 보여주도록 수정할 것 이다.

또한 `mysite/urls.py`파일을 깨끗한 상태로 유지하기 위해, `blog` 애플리케이션에서 메인 `mysite/urls.py`파일로 url들을 가져오도록 설정한다.

먼저 `blog.urls`를 가져오는 행을 추가해야한다. `blog.urls`를 가져오려면, `include` 함수가 필요하다. `from django.urls` 행을 찾아 `import` 뒤에 `include` 함수를 추가하면 된다.

 `mysite/urls.py`

```python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('blog.urls')),
]
```

- http://127.0.0.1:8000/ 로 들어오는 모든 접속 요청을 `blog.urls`로 전송해 추가 명령을 찾는다.

그 후, `blog/urls.py`이라는 새 파일을 생성하고 내부에 아래 내용을 추가한다.

```python
from django.urls import path
from . import views

urlpatterns = [
    path('', views.post_list, name='post_list'),
]
```

- 장고 함수인 `path`와 `blog` 애플리케이션에서 사용할 모든 `views`를 가져왔다.

- 또한, urlpatterns을 추가한다. 이제 `post_list`라는 `view`가 루트 URL에 할당되어 있다. 이 URL 패턴은 빈 문자열에 매칭이 되며, 장고 URL 확인자(resolver)는 전체 URL 경로에서 접두어(prefix)에 포함되는 도메인 이름(i.e. http://127.0.0.1:8000/)을 무시하고 받아드린다. 이 패턴은 장고에게 누군가 웹사이트에 'http://127.0.0.1:8000/' 주소로 들어왔을 때 `views.post_list`를 보여주도록 설정해 준다.

  마지막 부분인 `name='post_list'`는 URL에 이름을 붙인 것으로 뷰를 식별한다. 뷰의 이름과 같을 수도 완전히 다를 수도 있다. 이름을 붙인 URL은 프로젝트의 후반에 사용할 예정이다. 그러니 앱의 각 URL마다 이름 짓는 것은 중요하다. URL에 고유한 이름을 붙여, 외우고 부르기 쉽게 만들어야 한다.

- 하지만, 이대로 서버를 동작시키면 **no attribute 'post_list'** 에러 메세지가 뜬다. 아직, 장고가 찾고 사용하고자 하는 뷰가 없다는 의미이다.

## 8. 장고 뷰 만들기

뷰(*view*) 는 애플리케이션의 "로직"을 넣는 곳이다. 뷰는 이전 장에서 만들었던 `모델`에서 필요한 정보를 받아와서 `템플릿`에 전달하는 역할을 한다. 템플릿은 다음 장에서 만들 것이다.뷰는 파이썬의 함수일 뿐이라고 생각하면 쉽다.

### 8.1. blog/views.py

- blog/views.py

  아래와 같이 views.py 파일을 작성한다.

  ```python
  from django.shortcuts import render

  def post_list(request):
      return render(request, 'blog/post_list.html', {})
  ```

  - `post_list`라는 함수(`def`)를 만들었다. 이 함수는 `요청(request)`을 넘겨받아 `render`메서드를 호출한다. 이 함수는 `render` 메서드를 호출하여 받은(return) `blog/post_list.html`템플릿을 보여준다.
  - 하지만, 파일을 저장하고, http://127.0.0.1:8000/ 로 접속해  보면 템플릿이 존재하지 않는다는 에러가 발생한다.

## 9. HTML 시작하기

템플릿이란 서로 다른 정보를 일정한 형태로 표시하기 위해 재사용 가능한 파일을 말한다. 편지의 내용이나 수신인 주소는 달라져도 같은 디자인, 레이아웃을 사용하는 것 처럼 웹 페이지도 마찬가지 이다.

### 9.1. HTML 만들기

`blog/templates/blog`디렉토리를 만들고, 디렉토리 안에 `post_list.html`를 만든다.

> blog와 동일한 이름의 디렉토리를 또 만드는 이유는 폴더의 구조가 복잡할 경우 조금도 쉽게 찾기 위해 사용하는 관습적인 방법이다.

웹서버를 다시 작동시키고, http://127.0.0.1:8000/에 접속하면 에러는 사라졌지만 아무화면도 보이지 않을 것이다.

HTML에 내용을 입력해주면 화면이 바뀐다.

`blog/templates/blog/post_list.html`

```html
<html>
    <head>
        <title>batboy's blog</title>
    </head>
	<body>
        <div>
            <h1><a href="">batboy's Blog</a></h1>
        </div>

        <div>
            <p>published: 14.06.2014, 12:14</p>
            <h2><a href="">My first post</a></h2>
            <p>Aenean eu leo quam. Pellentesque ornare sem lacinia quam venenatis vestibulum. Donec id elit non mi porta gravida at eget metus. Fusce dapibus, tellus ac cursus commodo, tortor mauris condimentum nibh, ut fermentum massa justo sit amet risus.</p>
        </div>

        <div>
            <p>published: 14.06.2014, 12:14</p>
            <h2><a href="">My second post</a></h2>
            <p>Aenean eu leo quam. Pellentesque ornare sem lacinia quam venenatis vestibulum. Donec id elit non mi porta gravida at eget metus. Fusce dapibus, tellus ac cursus commodo, tortor mauris condimentum nibh, ut f.</p>
        </div>
    </body>
</html>

```

### 9.2 PythonAnywhere에 작업 내용 업로드 하기

github에 로컬 작업 내용을 push하고 PythonAnywhere console에서 pull한다. 그 후 Web tab에서 Relaod를 한 뒤 접속하면 업데이트 된 것을 확인할 수 있다.

## 10. 장고 ORM과 쿼리셋(QuerySets)

이번 장에서는 장고를 데이터베이스에 연결, 데이터를 저장하는 방법에 대해서 학습한다.

### 10.1. 쿼리셋이란?

핵심만 말하자면, 쿼리셋(QuerySet)은 전달받은 모델의 객체 목록이다. 쿼리셋은 데이터베이스로부터 데이터를 읽고, 필터를 걸거나 정렬을 할 수 있다.

### 10.2. 쿼리셋 예제

- 장고 인터랙티브 콘솔(interactive console)

  로컬 콘솔에서 아래 명령을 입력하면 장고 인터랙티브 콘솔이 실행된다. 파이썬과 비슷하지만 다르다. 파이썬의 모든 명령어가 사용가능하지만, 장고를 위한 공간이라고 생각하면 된다.

  ```bash
  python manage.py shell
  ```

- 모든 객체 조회하기

  특정 모델의 객체를 조회하기 위해서는, 먼저 모델을 import해야 한다.

  ```python
  >>> from blog.models import Post
  ```

  아래 명령어로 모든 객체를 조회할 수 있다.

  ```python
  >>> Post.objects.all()
  ```

- 객체 생성하기

  ```python
  >>> Post.objects.create(author=me, title='Sample title', text='Test')
  ```

  - `me`라는 사용자는 정의되어 있지 않기 때문에 오류가 발생한다. 먼저 User 모델을 불러온 후 `me`  유저를 정의해 준다.

  ```python
  >>> from django.contrib.auth.models import User
  >>> User.objects.all()
  >>> me = User.objects.get(username='admin')
  ```

- 필터링하기

  ```python
  Post.objects.filter(author=me)
  ```

  - author가 me인 Post만 확인한다.

  ```python
  Post.objects.filter(title__contains='title')
  ```

  - 제목에 title이 포함되어 있는 글자만 확인한다.

  - `title`와 `contains` 사이에 있는 밑줄(`_`)이 2개(`__`)

    `장고 ORM`은 필드 이름("title")과 연산자과 필터("contains")를 밑줄 2개를 사용해 구분한다. 밑줄 1개만 입력한다면, `FieldError: Cannot resolve keyword title_contains`라는 오류가 뜬다.

  ```python
  >>> from django.utils import timezone
  >>> Post.objects.filter(published_date__lte=timezone.now())
  ```

  - `게시일(published_date)`로 과거에 작성한 글을 필터링하여 목록을 불러올 수 있다.
  - 위 결과 `[]`아무것도 출력되지 않았다면, publish()된 것이 없기 때문이다.

  ```python
  >>> post = Post.objects.get(title="Sample title")
  >>> post.publish()
  >>> Post.objects.filter(published_date__lte=timezone.now())
  ```

- 정렬하기

  `created_date`필드를 정렬

  ```python
  >>> Post.objects.order_by('created_date')
  ```

  - `-`을 맨 앞에 붙여주면 내림차순 정렬도 가능하다.

  ```python
  >>> Post.objects.order_by('-created_date')
  ```

- 쿼리셋 연결하기

  퀴리셋들을 함께 연결하는 것을 `chaining`이라 한다.

  아래 체이닝은, 필터와 정렬을 진행한 체이닝이다.

  ```python
  >>> Post.objects.filter(published_date__lte=timezone.now()).order_by('published_date')
  ```

## 11. 템플릿 동적 데이터

`Post`모델은 `models.py`파일에, `post_list`모델은 `views.py`파일에 있다. 이번 장에서는 콘텐츠(데이터베이스 안에 저장되어 있는 모델)를 가져와 템플릿에 넣어 보여주는 것을 할 것이다.

*뷰(view)*는 모델과 템플릿을 연결하는 역할을 한다. `post_list`를 *뷰*에서 보여주고 이를 템플릿에 전달하기 위해서는, 모델을 가져와야 한다. 일반적으로 *뷰*가 템플릿에서 모델을 선택하도록 만들어야 한다.

`blog/views.py`파일을 열어봅시다. `post_list` *뷰* 내용을 보면 아래와 같다.

```python
from django.shortcuts import render

def post_list(request):
    return render(request, 'blog/post_list.html', {})
```

여기에 Post 모델을 사용하기 위해 Post 모델을 import해준다.

```python
from django.shortcuts import render
from .models import Post

def post_list(request):
    return render(request, 'blog/post_list.html', {})
```

`from` 다음에 있는 마침표(.)는 현재 *디렉토리* 또는 *애플리케이션*을 의미한다. 동일한 디렉터리 내 `views.py`, `models.py`파일이 있기 때문에 `. 파일명` (`.py`확장자를 붙이지 않아도)으로 내용을 가져올 수 있다.

`Post`모델에서 블로그 글을 가져오기 위해서는 `쿼리셋(QuerySet)`이 필요하다.

### 11.1. QuerySet

```python
from django.shortcuts import render
from django.utils import timezone
from .models import Post

def post_list(request):
    posts = Post.objects.filter(published_date__lte=timezone.now()).order_by('published_date')
    return render(request, 'blog/post_list.html', {'posts': posts})
```

- `timezone` 모듈을 사용을 위해 `from django.utils import timezone`를 추가

- publish된 포스트 쿼리셋을 posts에 저장

- `render` 함수에는 매개변수 `request`(사용자가 요청하는 모든 것)와 'blog/post_list.html' 템플릿이 있다. `{}`이 보일 텐데, 이곳에 템플릿을 사용하기 위해 매개변수를 추가해야 한다.

  > 이 매개변수를`'posts'`로 하고, `{'posts': posts}`이렇게 작성한다. `:`앞에는 문자열이 와야한다.

## 12. 장고 템플릿

### 12.1. 템플릿 태그

**템플릿 태그**는 파이썬을 HTML로 바꿔주어, 빠르고 쉽게 동적인 웹 사이트를 만들 수 있게 해준다.

- Post 목록 템플릿 보여주기

  이전에 `blog/views.py`파일에서 posts변수를 매개변수로 주었다. `posts`변수를 받아 HTML에 나타나도록 할 수 있다.  변수 이름 안에 중괄호를 넣어 표시해야 한다.

  `blog/templates/blog/post_list.html`

  ```html
  <html>
      <head>
          <title>batboy's blog</title>
      </head>
  	<body>
          <div>
              <h1><a href="">batboy's Blog</a></h1>
          </div>

          <div>
              {{ posts }}
          </div>
      </body>
  </html>
  ```

  서버를 실행해 보면 객체가 리스트형태로 웹브라우저에 뜨는 것을 확인할 수 있다. 이는 장고가 `{{ posts }}`를 객체 목록으로 이해하고 처리했다는 것을 의미한다. for문을 이용해 개별 객체에 접근해보자.

  ```html
  <html>
      <head>
          <title>batboy's blog</title>
      </head>
  	<body>
          <div>
              <h1><a href="">batboy's Blog</a></h1>
          </div>

          <div>
  			{% for post in posts %}
              	{{ post }}
              {% endfor %}
          </div>
      </body>
  </html>
  ```

  이렇게하면 객체의 이름만 연속해서 출력이 되는것을 확인할 수 있다. 이를 조금더 바꾸어보면 아래와 같이 표현할 수 있다.

  ```html
  <html>
      <head>
          <title>batboy's blog</title>
      </head>
  	<body>
          <div>
              <h1><a href="">batboy's Blog</a></h1>
          </div>

          {% for post in posts %}
              <div>
                  <p>published: {{ post.published_date }}</p>
                  <h1><a href="">{{ post.title }}</a></h1>
                  <p>{{ post.text|linebreaksbr }}</p>
              </div>
          {% endfor %}
      </body>
  </html>
  ```

  - 가장 위에 published date, 그다음줄엔 포스트 제목, 그 다음줄엔 포스트 텍스트가 나오게 된다.
  - `post.text`, `post.published_date`, `post.title` 등과 같이 post 객체의 속성에 접근할 수 있다.

  -  `|linebreaksbr`같이 파이프 문자(|)를 사용할 수 있다. 이건 블로그 글 텍스트에서 행이 바뀌면 문단으로 변환하도록 하라는 의미이다.

## 13. CSS 꾸미기

### 13.1. 부트스트랩

부트스트랩(Bootstrap)은 유명한 HTML과 CSS프레임워크로 예쁜 웹사이트를 만들 수 있게 해준다. : https://getbootstrap.com/

- 부트 스트랩 사용

`blog/templates/blog/post_list.html`의 `<head>`에 아래 내용을 추가한다.

```html
<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css">
<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap-theme.min.css">
```

### 13.2. 정적 파일

**정적 파일(static files)**은 CSS와 이미지 파일에 해당한다. 이 컨텐츠는 요청 내용에 따라 바뀌는 것이 아니기 때문에 모든 사용자들이 동일한 내용을 볼 수 있다.

서버에서 `collectstatic`를 실행할 때 처럼, 장고는 "admin"앱에서 정적 파일을 어디서 찾아야하는지 이미 알고있다. 이제 "blog"앱에 정적파일을 추가하면 된다. "blog"앱 안에 `static`라는 새 폴더를 만든다.

```
    .
    ├── blog
    │   ├── migrations
    │   ├── static
    │   └── templates
    └── mysite
```

장고는 app 폴더 안에 있는 `static`폴더를 자동으로 찾을 수 있다. 이 컨텐츠를 정적 파일로 사용하게 된다.

### 13.3. CSS 파일

CSS파일을 만들어 나만의 스타일을 가진 웹페이지를 만들수 있다. `static`디렉토리 안에 `css`디렉토리를 만들어 안에 `blog.css`라는 파일을 만든다.

```
    .
    └─── blog
         └─── static
              └─── css
                   └─── blog.css
```

`blog/static/css/blog.css` 파일에 아래 코드를 추가하여 h1태그와 a태그의 색을 바꾸어 보자.

```css
h1 a {
    color: #FCA205;
}
```

이제 CSS를 HTML에 추가해보자. `blog/templates/blog/post_list.html` 파일을 열고 맨 처음 줄에 이 라인을 추가한다.

```html
{% load static %}
```

그 후, ``와 `` 사이에 부트스트랩 CSS파일 링크 다음에 아래 코드를 추가한다.

```html
<link rel="stylesheet" href="{% static 'css/blog.css' %}">
```

- 최종 코드

  `post_list.html`

  ```html
  {% load static %}
  <html>
      <head>
          <title>batboy's blog</title>
          <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css">
          <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap-theme.min.css">
          <link rel="stylesheet" href="{% static 'css/blog.css' %}">
          <link href="//fonts.googleapis.com/css?family=Lobster&subset=latin,latin-ext" rel="stylesheet" type="text/css">
      </head>
  	<body>
          <div class="page-header">
              <h1><a href="">batboy's Blog</a></h1>
          </div>
          <div class="content container">
              <div class="row">
                  <div class="col-md-8">
                      {% for post in posts %}
                          <div class="post">
                              <div class="date">
                                  <p>published: {{ post.published_date }}</p>
                              </div>
                              <h1><a href="">{{ post.title }}</a></h1>
                              <p>{{ post.text|linebreaksbr }}</p>
                          </div>
                      {% endfor %}
                  </div>
              </div>
          </div>
      </body>
  </html>

  ```

  `blog.css`

  ```css
  .page-header {
      background-color: #ff9400;
      margin-top: 0;
      padding: 20px 20px 20px 40px;
  }

  .page-header h1, .page-header h1 a, .page-header h1 a:visited, .page-header h1 a:active {
      color: #ffffff;
      font-size: 36pt;
      text-decoration: none;
  }

  .content {
      margin-left: 40px;
  }

  h1, h2, h3, h4 {
      font-family: 'Lobster', cursive;
  }

  .date {
      color: #828282;
  }

  .save {
      float: right;
  }

  .post-form textarea, .post-form input {
      width: 100%;
  }

  .top-menu, .top-menu:hover, .top-menu:visited {
      color: #ffffff;
      float: right;
      font-size: 26pt;
      margin-right: 20px;
  }

  .post {
      margin-bottom: 70px;
  }

  .post h1 a, .post h1 a:visited {
      color: #000000;
  }
  ```

## 14. 템플릿 확장

**템플릿 확장(template extending)** 은 웹사이트 안의 서로 다른 페이지에서 HTML의 일부를 동일하게 재사용 할 수 있다는 뜻이다.

이 방법을 사용하면 동일한 정보/레이아웃을 사용하고자 할 때, 모든 파일마다 같은 내용을 반복해서 입력 할 필요가 없게 된다. 또 뭔가 수정할 부분이 생겼을 때, 각각 모든 파일을 수정할 필요 없이 딱 한번만 수정하면 된다.

### 14.1 기본 템플릿 생성하기

`blog/templates/blog/`에 `base.html` 파일을 만든다.

```
blog
└───templates
    └───blog
            base.html
            post_list.html
```

`base.html`에 아래와 같이 만든다.

```html
{% load static %}
<html>
    <head>
        <title>Django Girls blog</title>
        <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css">
        <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap-theme.min.css">
        <link href='//fonts.googleapis.com/css?family=Lobster&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="{% static 'css/blog.css' %}">
    </head>
    <body>
        <div class="page-header">
            <h1><a href="/">Django Girls Blog</a></h1>
        </div>

		<div class="content container">
			<div class="row">
				<div class="col-md-8">
				{% block content %}
				{% endblock %}
				</div>
			</div>
		</div>
    </body>
</html>

```

> ```html
> {% block content %}
> {% endblock %}
> ```
>
> 위 코드는 `block`을 만든 것이다. 템플릿 태그 `{% block %}`로 HTML 내에 들어갈 수 있는 공간을 만들었다. `base.html`을 확장해 다른 템플릿에도 가져다 쓸 수 있게 한 것이다.

`blog/templates/blog/post_list.html` 파일을 다시 열어, `{% for post in posts %}`부터 `{% endfor %}`까지만 남기고 나머지는 전부 지우고, 블록 태그로 감싸준다.

```html
{% block content %}
    {% for post in posts %}
        <div class="post">
            <div class="date">
                {{ post.published_date }}
            </div>
            <h1><a href="">{{ post.title }}</a></h1>
            <p>{{ post.text|linebreaksbr }}</p>
        </div>
    {% endfor %}
{% endblock %}
```

이제 base.html과 post_list.html연결해주어야 한다.

`blog/templates/blog/post_list.html` 파일에 확장태그를 맨 처음에 추가한다.

```html
{% extends 'blog/base.html' %}

{% block content %}
    {% for post in posts %}
        <div class="post">
            <div class="date">
                {{ post.published_date }}
            </div>
            <h1><a href="">{{ post.title }}</a></h1>
            <p>{{ post.text|linebreaksbr }}</p>
        </div>
    {% endfor %}
{% endblock %}
```

## 15. 애플리케이션 확장하기

지금까지 웹 사이트 제작 단계를 모두 마쳤어요. 모델, url, 뷰와 템플릿을 만드는 방법을 실습했다. 이제는 블로그 게시글이 각 페이지마다 보이게 만들어 볼 것이다.

### 15.1. Post에 템플릿 링크 만들기

`blog/templates/blog/post_list.html`

```html
{% extends 'blog/base.html' %}

{% block content %}
    {% for post in posts %}
        <div class="post">
            <div class="date">
                {{ post.published_date }}
            </div>
            <h1><a href="{% url 'post_detail' pk=post.pk %}">{{ post.title }}</a></h1>
            <p>{{ post.text|linebreaksbr }}</p>
        </div>
    {% endfor %}
{% endblock %}
```

- `<h1><a href="{% url 'post_detail' pk=post.pk %}">{{ post.title }}</a></h1>`  타이틀 부분을 이렇게 수정하여서, 타이틀을 클릭하면 상세 페이지로 이동하게 한다.

- `{% url 'post_detail' pk=post.pk %}`

  -  `{% %}`는 장고 템플릿 태그를 의미

  - `blog.views.post_detail`는 `post_detail` *뷰* 경로이다. `blog`는 응용프로그램(디렉터리 `blog`)의 이름이다. `views`는 `views.py`파일명이고 마지막 부분 `post_detail`는 *view* 이름이다.
  - `pk`는 데이터베이스의 각 레코드를 식별하는 기본키(Prmiary Key)의 줄임말 이다. Post 모델에서 기본키를 지정하지 않았기 때문에 장고는 `pk`라는 필드를 추가해 새로운 블로그 게시물이 추가될 때마다 그 값이 1,2,3 등으로 증가하게 된다. Post 객체의 다른 필드 (제목, 작성자 등)에 액세스하는 것과 같은 방식으로 post.pk를 작성하여 기본 키에 액세스 할수있다 `post.pk`를 써서 기본키 뿐만 아니라 `Post`객체내 다른 필드(`title`, `author`)에도 접근할 수 있다.

아직, `post_detail` 뷰를 마늗ㄹ지 않아 오류가 발생할 것이다.

### 15.2. Post 상세 페이지 URL 만들기

`post_detail`*뷰*가 보이게 `urls.py`에 URL를 만들어 보자.

첫 게시물의 상세 페이지 **URL**을 http://127.0.0.1:8000/post/1/ 로 만들고자 한다.

`blog/urls.py`파일에 URL을 만들어, 장고가 `post_detail` *뷰*로 보내, 게시글이 보일 수 있게 만든다.

```python
from django.urls import path
from . import views

urlpatterns = [
    path('', views.post_list, name='post_list'),
    path('post/<int:pk>/', views.post_detail, name='post_detail'),
]
```

- `post/<int:pk>/`는 URL 패턴을 의미
  - `post/`란 URL이 **post** 문자를 포함해야 한다는 것을 의미
  - `<int:pk>`는 조금 까다롭습니다. 장고는 정수 값을 기대하고 이를 `pk`라는 변수로 뷰로 전송하는 것을 의미한다.
  - `/`은 다음에 **/** 가 한 번 더 와야 한다는 의미

### 15.3. Post 상세 페이지 내 뷰 추가하기

*뷰*가 `pk`를 식별할 수 있도록 매개 변수를 추가해야 한다.

함수를 `def post_detail(request, pk):`라고 정의하고, urls(`pk`)과 동일하게 이름을 사용해야 한다. 변수가 생략되면 오류가 난다.

```python
from django.shortcuts import render
from django.utils import timezone
from .models import Post
from django.shortcuts import render, get_object_or_404

def post_detail(request, pk):
    post = get_object_or_404(Post, pk=pk)
    return render(request, 'blog/post_detail.html', {'post': post})

def post_list(request):
    posts = Post.objects.filter(published_date__lte=timezone.now()).order_by('published_date')
    return render(request, 'blog/post_list.html', {'posts': posts})
```

- `get_object_or_404`라는 특별한 기능을 사용하여, `pk`에 해당하는 `Post`가 없을 경우 `페이지 찾을 수 없음 404 : Page Not Found 404`를 사용.

### 15.4. Post 상세 페이지 템플릿 만들기

`blog/templates/blog` 디렉터리 안에 `post_detail.html`라는 새 파일을 생성하고 아래와 같이 코드를 작성한다.

`blog/templates/blog/post_detail.html`

```html
{% extends 'blog/base.html' %}

{% block content %}
    <div class="post">
        {% if post.published_date %}
            <div class="date">
                {{ post.published_date }}
            </div>
        {% endif %}
        <h1>{{ post.title }}</h1>
        <p>{{ post.text|linebreaksbr }}</p>
    </div>
{% endblock %}
```

- `base.html`을 확장
- `content`블록에서 블로그 글의 게시일, 제목과 내용을 보이게함
- `{% if ... %} ... {% endif %}`라는 템플릿 태그인데, 내용이 있는지 확인할 때 사용한다. `post`의 `게시일(published_date)`이 있는지, 없는지를 확인

## 16. 장고 폼

 블로그 글을 추가하거나 수정하는 멋진 기능을 추가할 것이다. 장고의 `관리자` 기능도 충분히 가능하지만, `폼(양식, forms)`으로 강력한 인터페이스를 만들 수 있다.

장고 폼은 아무런 준비 없이도 양식을 만들 수 있고, `ModelForm`을 생성해 자동으로 모델에 결과물을 저장할 수 있게 해준다.

장고의 모든 중요한 부분과 마찬가지로, 폼도 폼만의 `forms.py`.라는 파일을 만들어야 한다. blog` 디렉토리 안에 `forms.py` 파일을 만든다.

```
blog
 └── forms.py
```

파일에 아래 내용을 넣는다.

`blog/forms.py`

```python
from django import forms
from .models import Post

class PostForm(forms.ModelForm):

    class Meta:
        model = Post
        fields = ('title', 'text',)
```

위 코드를 보면 첫 번째로 forms model을 import 해야 하고 (`from django import forms`), 그다음으로 `Post` model도 import 해야 한다. (`from .models import Post`).

`PostForm` 은 만들 폼의 이름이다. 그리고 장고에 이 폼이 `ModelForm`이라는 것을 알려 준다. `forms.ModelForm`은 ModelForm이라는 것을 알려주는 구문이다.

`class Meta`는 이 폼을 만들기 위해서 어떤 model이 쓰여야 하는지 장고에 알려주는 구문이다. (`model = Post`).

마지막으로, 이 폼에 필드를 넣으면 완성된다. 이번 폼에서는 `title`과 `text`만 보여지게 한다. `author`는 현재 로그인 하고 있는 사람이 될 것이고 그리고 `created_date`는 글이 등록되는 시간이 될 것이다.

이제 *뷰* 에서 이 폼을 사용해 템플릿에서 보여주기만 하면 된다. 다음에는 링크, URL, 뷰 그리고 템플릿을 만들어보자.

### 16.1. 폼과 페이지 링크

`blog/templates/blog/base.html` 파일을 열어 `page-header` 라는 `div` class에 링크를 하나 추가한다.

```html
<a href="{% url 'post_new' %}" class="top-menu"><span class="glyphicon glyphicon-plus"></span></a>
```

- 부트스트랩 테마에 있는 `glyphicon glyphicon-plus` 클래스로 더하기 기호 사용

### 16.2. URL

이제 `blog/urls.py`를 열고 아래 구문을 추가

```python
path('post/new', views.post_new, name='post_new'),
```

### 16.3. `post_new` view

`blog/views.py`파일을 열어서 `from`줄에 아래와 같은 코드를 추가

```python
from .forms import PostForm
```

*view*에 추가

```python
def post_new(request):
    form = PostForm()
    return render(request, 'blog/post_edit.html', {'form': form})
```

새 `Post` 폼을 추가하기 위해 `PostForm()` 함수를 호출하도록 하여 템플릿에 넘긴다.

### 16.4. 템플릿

이번에는 `blog/templates/blog` 디렉터리 안에 `post_edit.html` 파일을 생성해 폼이 작동할 수 있게 만든다.

-  `{{ form.as_p }}` 폼을 보이게 할 수 있다.
- 위 코드를 HTML 태그로 폼을 감싸세요. `...`
- `Save` 버튼은 HTML을 이용하여 만든다.
- 마지막으로` <form ...>`을 열어 `{% csrf_token %}`를 추가한다. 이 작업은 폼 보안을 위해 중요하다. 이 것을 빼먹으면 에러가 뜰 것이다.

`blog/templates/blog/post_edit.html`

```html
{% extends 'blog/base.html' %}

{% block content %}
    <h1>New post</h1>
    <form method="POST" class="post-form">{% csrf_token %}
        {{ form.as_p }}
        <button type="submit" class="save btn btn-default">Save</button>
    </form>
{% endblock %}
```

 `title`과 `text`필드에 아무거나 입력하고 저장해 새 글이 추가되지 않는다. 뷰 추가 작업을 해야한다.

### 16.5. 폼 저장하기

`blog/views.py`

```python
def post_new(request):
    form = PostForm()
    return render(request, 'blog/post_edit.html', {'form': form})
```

폼을 제출할 때, 같은 뷰를 불러온다. 이때 `request`에는 우리가 입력했던 데이터들을 가지고 있는데, `request.POST`가 이 데이터를 가지고 있다. (`POST`는 글 데이터를 "등록하는(posting)"하는 것을 의미한다. 블로그 "글"을 의미하는 "post"와 관련이 없다.)

HTML에서 `<form>` 정의에 `method="POST"`라는 속성이 있었다. POST로 넘겨진 폼 필드의 값들이`request.POST`에 저장된다. `POST`로 된 값을 꾸면 안된다.

이제 *view* 에서 두 상황으로 나누어 처리한다. (if문 사용)

- 첫 번째: 처음 페이지에 접속했을 때이다. 당연히 우리가 새 글을 쓸 수 있게 폼이 비어있어야 한다.
- 두 번째: 폼에 입력된 데이터를 *view* 페이지로 가지고 올 때다. 여기서 조건문을 추가시켜야 한다.

```python
from django.shortcuts import redirect

def post_new(request):
    if request.method == "POST":
        form = PostForm(request.POST)
        if form.is_valid():
            post = form.save(commit=False)
            post.author = request.user
            post.published_date = timezone.now()
            post.save()
            return redirect('post_detail', pk=post.pk)
    else:
        form = PostForm()
    return render(request, 'blog/post_edit.html', {'form': form})
```

- 만약 `method`가 `POST`라면, 폼에서 받은 데이터를 `PostForm`으로 넘겨주어야 한다. 다음에는 폼에 들어있는 값들이 올바른지를 확인해야 한다. (모든 필드에는 값이 있어야하고 잘못된 값이 있다면 저장하면 되지 않아야 한다.) 이를 위해 `form.is_valid()`을 사용하여 체크한다. 그 후, 저장한다.

  `form.save()`로 폼을 저장하는 작업과 작성자를 추가하는 작업으로 나눌 수 있다. (`PostForm`에는 `작성자(author)` 필드가 없지만, 필드 값이 필요하다) `commit=False`란 넘겨진 데이터를 바로 `Post` 모델에 저장하지는 말라는 뜻이다. 작성자를 추가한 다음 저장해야 하므로 사용한다.  (대부분의 경우에는 `commit=False`를 쓰지 않고 바로 `form.save()`를 사용해서 저장한다. 다만 여기서는 작성자 정보를 추가하고 저장해야 하므로 `commit=False`를 사용한다.) `post.save()`는 변경사항(작성자 정보를 포함)을 유지할 것이고 새 블로그 글이 만들어 지도록한다.

  새 블로그 글을 작성한 다음에 `post_detail`페이지로 이동하도록 `return redirect('post_detail', pk=post.pk)` 해준다. `post_detail`은 우리가 이동해야 할 뷰의 이름이고, `pk=post.pk`를 사용해서 뷰에게 값을 넘겨준다. 여기서 `post`는 새로 생성한 블로그 글이다.

> 장고 관리자 인터페이스처럼 로그인된 상태라고 생각해봅시다. 하지만 사용자가 로그아웃되는 상황이 발생하기도 하죠. (브라우저가 닫히거나, DB가 재시작된다든가 등) 만약 로그인되지 않은 상태에서 새 글을 저장한다면, 사용자가 로그인되어있지 않아 누가 글을 작성하였는지 알 수 없어요. 그래서 글을 저장할 때 오류가 발생하고, 로그인시키도록 http://127.0.0.1:8000/admin 관리자 페이지가 나타나게 될 거에요. 이 문제는 금방 해결할 수 있어요. 튜토리얼을 마친 후 장고걸스 심화 튜토리얼 - 보안 추가하기 장에서 실습할 수 있어요.

### 16.6. 폼 검증하기

블로그 글은 `title`과 `text`필드가 반드시 있어야 한다. `Post`모델에서는 이 필드 값들이 필요 없다고 했지만(`published_date`는 제외하고) 장고는 모두 기본적으로 값이 설정되어 있다고 생각한다. `title`과 `text`없이 폼을 저장해보면, 채워지지 않았다는 것을 알려준다.

### 16.7. 폼 수정하기

글을 수정하는 기능을 추가한다.

`blog/templates/blog/post_detail.html`파일을 열어 아래 내용을 추가

```html
<a class="btn btn-default" href="{% url 'post_edit' pk=post.pk %}"><span class="glyphicon glyphicon-pencil"></span></a>
```

`blog/urls.py`에 다음 코드를 추가

```python
    path('post/<int:pk>/edit/', views.post_edit, name='post_edit'),
```

`blog/views.py`파일을 열어서 파일 맨 밑에 코드를 추가

```python
def post_edit(request, pk):
    post = get_object_or_404(Post, pk=pk)
    if request.method == "POST":
        form = PostForm(request.POST, instance=post)
        if form.is_valid():
            post = form.save(commit=False)
            post.author = request.user
            post.published_date = timezone.now()
            post.save()
            return redirect('post_detail', pk=post.pk)
    else:
        form = PostForm(instance=post)
    return render(request, 'blog/post_edit.html', {'form': form})
```

- 첫 번째: url로부터 추가로 `pk` 매개변수를 받아서 처리
- 두 번째: `get_object_or_404(Post, pk=pk)`를 호출하여 수정하고자 하는 글의 `Post` 모델 `인스턴스(instance)`로 가져온다.

### 16.8. 보안

글을 쓰고 수정할수 있는 권한을 나에게만 주는 기능을 구현한다.

`blog/templates/blog/base.html` 파일에서, `page-header` `div`를 찾아 아래와 같이 작성된 앵커 태그(Anchor Tag)를 찾는다.

```html
<a href="{% url 'post_new' %}" class="top-menu"><span class="glyphicon glyphicon-plus"></span></a>
```

여기에 `{% if %}`태그를 추가해 관리자로 로그인한 유저들만 링크가 보일 수 있게 만들 어야 한다.

```html
{% if user.is_authenticated %}
    <a href="{% url 'post_new' %}" class="top-menu"><span class="glyphicon glyphicon-plus"></span></a>
{% endif %}
```

이 `{% if %}`는 브라우저에 페이지를 요청 하는 사용자가 로그인 하는 경우 링크가 발생됩니다. 이는 새 게시글을 완전히 보호해주지는 않지만 바람직한 방법이다.

`blog/templates/blog/post_detail.html`파일을 열어 아래와 같이 작성된 라인을 찾수정한다.

```html
{% if user.is_authenticated %}
     <a class="btn btn-default" href="{% url 'post_edit' pk=post.pk %}"><span class="glyphicon glyphicon-pencil"></span></a>
{% endif %}
```

