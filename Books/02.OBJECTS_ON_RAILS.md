# OBJECTS on RAILS

> By AVDI GRIMM

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./README.md)

---

<!-- TOC -->

- 

<!-- /TOC -->

## 1. Yet another frickin’ blog app

새 블로그 어플리케이션을 만들어보자. 

```
rails new bloog --skip-test-unit --skip-prototype
```

> 프로젝트 이름을 blog라고 하지않은 이유는, Class 이름 중 Blog를 사용할 계획이기 때문이다. 만약 이름이 같다면 충돌이 발생할 것이다. 

홈페이지의 첫 화면부터 시작하는 것이 좋을 것 같다. route를 설정해 주자.

```ruby
root to: "blog#index"
```

라우트가 동작하도록 컨트롤러를 만든다.

```
rails g controller blog index
```

> 이렇게 만들면 blog 컨트롤러를 만들어 주며 내부에 index 메서드를 자동으로 만들어 준다.

이제 뷰와 컨트롤러를 작성하자.

뷰에서는 @blog의 타이틀과 서브타이블을 화면에 출력한다.

```erb
<!-- app/views/blog/index.html.erb -->
<h1><%= @blog.title %></h1>
<h2><%= @blog.subtitle %></h2>
```

뷰에서 @blog객체를 필요로 하기 때문에 컨트롤러에서 생성해준다.

```ruby
# app/controllers/blog_controller.rb
class BlogController < ApplicationController
  def index
    @blog = Blog.new
  end
end
```

Blog라는 클래스의 인스턴스를 생성하기 떄문에, Blog모델이 필요하다는 것을 알 수 있다.

```ruby
# app/models/blog.rb
class Blog
  def title
    "Watching Paint Dry"
  end
  def subtitle
    "The trusted source for drying paint news & opinion"
  end
end
```

서버를 돌리면 기본적인 페이지가 보이게 된다.

## 2. Adding blog entries

엔트리가 없는 블로그는 유용하지 않다. 블로그 포스트들을 app에 추가하자. 단순한 정적 문자열보다 복잡한 것을 추가하기 때문에, TDD를 할 것이다. 테스트 프레임워크는 MiniTest/Spec을 이용한다.

```ruby
# spec/models/blog_spec.rb
require 'minitest/autorun'
require_relative '../../app/models/blog'
describe Blog do
  before do
    @it = Blog.new
  end
  it "has no entries" do
    @it.entries.must_be_empty
  end
end
```

> RSpec 기본 구조
>
> - 테스트의 기대되는 값과 실제 값을 비교하여 성공 여부를 리턴해줍니다.
>
>   `expect(테스트 객체).to 비교하는 Matcher(예상되는 값)`
>
> - describe는 테스트 그룹을 만든다. describe 내부에도 describe를 만들 수 있다.
>
> - 인스턴스 변수를 설정하기 위해 `before do ~ end` 를 사용
> - it는 하나의 테스트 케이스를 의미한다. it는 context와 조합해서 사용한다. 보통 context는 `언제`를 나타낸다.

하지만, blog 클래스에 entries가 정의되지 않았기 때문에 에러가 발생한다.

```ruby
class Blog
    attr_reader :entries
    def initialize
        @entries = []
    end
    # ...
end
```

로 수정후 `ruby spec/models/blog_spec.rb`을 실행하면 테스트가 통과되는 것을 확인할 수 있다.

### Placeholder blog entries

이제 entries 속성을 Blog 클래스에 만들었지만, 그 안에는 아무것도 없다. BlogController에 임시 예제 블로그 포스트를 추가해보자.

```ruby
def index
    @blog = Blog.new
    post1 = @blog.new_post
    post1.title = "Paint just applied"
    post1.body = "Paint just applied. It’s a lovely orangey-purple!"
    post1.publish
    post2 = @blog.new_post(title: "Still wet")
    post2.body = "Paint is still quite wet. No bubbling yet!"
    post2.publish
end
```

하지만, new_post라는 메서드는 아직 존재하지 않는다. 코드를 짜보자.

### Making new entries

new_post 메서드를 명시하자. new_post 메서드는 Blog 객체와 연관이 있는 블로그 포스트 객체를 리턴한다. 그러나, test는 계속해서 isolate시키고 싶고, 한번에 하나의 모델만을 테스트하고 싶다.

새 게시물을 만드는 프로세스를 바꾸기 쉽게 만들자.

 ```ruby
class Blog
    # ...
    attr_writer :post_source
    # ...
    private
    def post_source
        @post_source ||= Post.public_method(:new)
    end
end
 ```

 public_method는 호출가능한 메서드 객체를 인스턴스화 한다. 객체의 `call` 메서드가 호출되면, 원래 객체에서 명명 된 메소드를 호출한 것 처럼된다. `public_method`이름에서 `public`은 `method`라고만 쓰는 것과는 달리, public_method는 public과 private의 경계를 존중하며, private 메서드를 위한 Method 객체를 생성하지 않는다는 것을 의미한다. 

> `public_method` 참고
>
> 1. [why-use-rails-public-method](https://stackoverflow.com/questions/15022621/why-use-rails-public-method)

> `tap`메서드 참고
>
> 1. https://publish.dayone.app/post/1eP1zCQ 
> 2. https://stackoverflow.com/questions/17493080/advantage-of-tap-method-in-ruby

> `call` 메서드 참고
>
> 1. https://stackoverflow.com/questions/35400337/ruby-send-vs-call-method

이 경우 `Post.public_method`는 아직 작성되지 않은 `Post.new 메서드`를 나타내는 `Method`객체에 대한 참조를 가져온다. 정상적인 작동 중에, 블로그는 post 객체를 생성하기 위해 이 메서드 참조(Post.new와 동등한)를 사용할 것이다. 그러나, 이것은 클래스를 테스트할 때 모든 호출가능한 객체로 대체할 수 있다.

이제, `Blog#new_post`가 어떻게 행동해야 하는지에 대한 assertions를 만들 수 있다.

```ruby
# spec/models/blog_spec.rb
require 'ostruct'
describe Blog do
    # ...
    describe "#new_post" do
        before do
            @new_post = OpenStruct.new
            @it.post_source = ->{ @new_post }
        end
        it "returns a new post" do
            @it.new_post.must_equal @new_post
        end
        it "sets the post’s blog reference to itself" do
            @it.new_post.blog.must_equal(@it)
        end
    end
end
```

> OpenStruct를 사용하기 위해 ostruct를 사용했다.
>
> - An *OpenStruct* is a data structure, similar to a Hash, that allows the definition of arbitrary attributes with their accompanying values. 
>
>   (https://ruby-doc.org/stdlib-2.7.1/libdoc/ostruct/rdoc/OpenStruct.html)
>
> `@it.new_post`는 `@new_post`와 같아야 한다. (@it는 Blog의 인스턴스다.)
>
> `@it.new_post.blog`는 `@it`와 같아야한다.

여기서, post_source메서드 대신 `OpenStruct`를 리턴하는 lambda를 사용하는 것을 확인할 수 있다.

이것들을 통과시키는 것은 간단하다.

```ruby
class Blog
    # ...
    def new_post
        post_source.call.tap do |p|
            p.blog = self
        end
    end
end
```

### Aside: subject and let

최신 버전의 MiniTest가 RSpec에서 let과 subject를 메서드를 가져왔다. 모든 예제에 적용하지는 않지만, 간단하게 subject와 let을 사용하는 방법에 대해서 보여주겠다.

blog_spec.rb를 간략하게 표현해보았다.

```ruby
#원래 코드
# spec/models/blog_spec.rb
describe Blog do
    before do
        @it = Blog.new
    end
    it "has no entries" do
        @it.entries.must_be_empty
    end
    #...
end

#subject, let 사용 코드
describe Blog do
    subject { Blog.new(->{entries}) }
    let(:entries) { [] }
    it "has no entries" do
        subject.entries.must_be_empty
    end
    # ...
end
```

- @it는 subject로 바뀌었고 @entries는 이제 entries로 바뀌었다.
- before 블록을 제거하는 것 외에도, let과 subject는 다른 유용한 속성을 가지고 있다. 그것들은 느리게 인스턴스화되고 메모된다. 즉, 테스트에서 항목을 전혀 사용하지 않으면 개체가 인스턴스화되지 않는다. 그리고, 테스트에서 항목을 두 번 이상 참조하면 정의 블록이 한 번만 실행되고 반환되는 값이 재사용된다. 실행에 비용이 많이 드는 객체라면 수행 속도가 빨라 질 수 있다.
- let과 subject에 액세스하려면 gem 버전의 MiniTest 또는 Ruby 1.9.3이 필요하다.

### Posts vs. Entries

Blog는 entries를 가지고 있다가, 이제는 posts 까지 가지고 있다. 둘 중 하나만 사용하면 안될까?

사실, 여러 용어를 사용하는 것은 의도적인 것이다. 예민한 프레임워크 규칙의 단점은 얼마 후에 이 규칙들이 가정으로 바뀐다는 것이다.이 경우, entries 집합을 posts라고 부른다면, Post 클래스와 정신적으로 연관될 가능성이 크다. 결국, blog.posts의 모든것은 Post 객체이다.

이것은 큰문제로 이어질 수 있다. 예를 들어, 만약blog.new_post가 Post.new와 동일하다고 가정하면, Blog part를 건너 뛰고 새 블로그 Entry를 원할 때마다 Post.new(...) 또는 Post.create(...)을 써야할 수 있다.

시간이 지나 사진이나 동영상과 같은다른 클래스로 표시되는 다양한 유형의 게시물을 추가한다고 가정해보자. Blog.new_post (...)를 호출하면 인수를보고 인스턴스화 할 올바른 유형의 객체를 선택할 것 이다. 불행히도, 우리는 모든것에 Post에 대한 참조를 하드 코딩했고 모두 변경해야한다.

이런 종류의 가정은 추가적인 일에서 해방시켜 줄 뿐만 아니라, 보안 허접을 보여줄 수도 있습니다. 블로그 엔트리를 Posts로 만들었다고 가정해보면, 아래와 같이 컨트롤러를 코딩했을 것 이다.

```ruby
def update
    @post = Post.find(params[:id])
    # ...
end
```

그리고, 여러개의 블로그를 호스팅하는 기능을 추가하기로 어느날 결정했다. 싱글톤 블로그 인스턴스 대신에 각각의 다른 유저가 소유한 여러개의 블로그가 있다. 컨트롤러는 블로그가 소유한 유저에 의해서만 수정 될 수 있도록 업데이트 되어야한다.

업그레이드는 쉽고, 모든 것이 잘 작동한다. 그런 다음, 어느 날 영리한 사용자는다른 사람의 게시물의 ID를 추측할 수 있으며 컨텐츠를 수정할 수 있음을 알게 된다. 그 이유는 무엇일까? Post.find()에 대한 모든 호출이 블로그 인스턴스로 부터 게시물에 액세스하는 것을 무시하고 게시물에 직접 접근했기 때문이다.

이런일들은 실제 프로덕션의 코드에서도 종종 보인다. blog entries와 Post 객체에 대한 용어를 각각 사용한다고 문제가 자동으로 해결되는 것은 아니다. 하지만, 다른 용어를 사용하는 것은 블로그에 의해 매니징 되는 entries와 Post 레코드가 같지 않아도 되는 것을 상기시켜준다.

이 책은 Rails 프로젝트를 신선한 관점에서 바라 보는 것이 목적이다.

### The Post class

이제, Post 클래스를 만들어야 한다는 것은 당연하다.

post에 대한 테스트를 작성한다.

```ruby
# spec/models/post_spec.rb
require ’minitest/autorun’
require_relative ’../../app/models/post’
describe Post do
    before do
        @it = Post.new
    end
    it "starts with blank attributes" do
        @it.title.must_be_nil
        @it.body.must_be_nil
    end
    it "supports reading and writing a title" do
        @it.title = "foo"
        @it.title.must_equal "foo"
    end
    it "supports reading and writing a post body" do
        @it.body = "foo"
        @it.body.must_equal "foo"
    end
    it "supports reading and writing a blog reference" do
        blog = Object.new
        @it.blog = blog
        @it.blog.must_equal blog
    end
    describe "#publish" do
        before do
            @blog = MiniTest::Mock.new
            @it.blog = @blog
        end
        after do
            @blog.verify
        end
        it "adds the post to the blog" do
            @blog.expect :add_entry, nil, [@it]
            @it.publish
        end
    end
end
```

post 테스트에 맞는 클래스를 작성한다.

```ruby
# app/models/post.rb
class Post
    attr_accessor :blog, :title, :body
    def publish
        blog.add_entry(self)
    end
end
```

### Why “publish”?

아마 레일즈 app을 만들어 보았다면, save메서드 대신 publush 메서드를 만든이유가 궁금할 것이다.

객체 지향 설계의 중심 요소 중 하나는 우리 모델의 도메인의 언어(용어)를 포착하는 것이다. 아무도 블로그 포스트를 저장했다고 하지 않는다. 블로그 포스트를 publish 했다고 하는 것이 더 적절하다. (“I published a blog post” or “I posted a blog entry”) 

블로그의 기능이 확장되어, 포스트를 예약된 시간에 올려주는 기능, 또는 초안기능 등을 추가 할 수 있다.

publish라는 이름의 메서드를 사용함으로 앞으로 추가될 기능들과 차별을 둘 수 있다.

적절한 도메인 용어를 쓰는 것은 프로그램의 확장을 용이하게 한다.

### Adding entries to the blog

Post를 새로 만들었기 때문에 Blog 모델에 post를 블로그에 추가하는 하나의 메서드가 더 필요로 해졌다. 테스트 코드를 짜고 메서드를 추가하자.

```ruby
describe Blog do
    describe "#add_entry" do
        it "adds the entry to the blog" do
            entry = Object.new
            @it.add_entry(entry)
            @it.entries.must_include(entry)
        end
    end
end
```

```ruby
class Blog
    # ...
    def add_entry(entry)
        entries << entry
    end
    # ...
end
```

BlogController에 있는 demo 코드를 보면, 두 번째 post를 만들 때, 약간 수정을 했고, title을 아규먼트로 전달했다.

```ruby
post2 = @blog.new_post(title: "Still wet")
```

이제 ` Blog#new_post`가 잘 동작할 수 있도록 수정하자.

먼저, spec 테스트 코드를 추가하자.

>  spec/models/blog_spec.rb

```ruby
it "accepts an attribute hash on behalf of the post maker" do
    post_source = MiniTest::Mock.new
    post_source.expect(:call, @new_post, [{x: 42, y: ’z’}])
    @it.post_source = post_source
    @it.new_post(x: 42, y: ’z’)
    post_source.verify
end
```

new_post 메서드를 수정한다.

> Blog#new_post

```ruby
def new_post(*args)
    post_source.call(*args).tap do |p|
        p.blog = self
    end
end
```

이제, 아규먼트를 전달한다. 하지만, Post initializer메서드를 작성해야 한다.

테스트 코드 작성

> spec/models/post_spec.rb

```ruby
it "supports setting attributes in the initializer" do
    it = Post.new(title: "mytitle", body: "mybody")
    it.title.must_equal "mytitle"
    it.body.must_equal "mybody"
end
```

initailize 추가

```ruby
class Post
    # ...
    def initialize(attrs={})
        attrs.each do |k,v| send("#{k}=",v) end
    end
    # ...
end
```

> ex) `sned("name=", "Jason")` => name = Jason

이제 post를 보여주도록 뷰를 업데이트 해보자.

> index

```erb
<!-- app/views/blog/index.html.erb -->
<h1><%= @blog.title %></h1>
<h2><%= @blog.subtitle %></h2>
<%= render partial: "entry", collection: @blog.entries %>
```

> render partial을 이용해 반복되는 부분을 쉽게 표현할 수 있다.

> _entry

```erb
<!-- app/views/blog/_entry.html.erb -->
<article>
<header>
    <h3><%= entry.title %></h3>
</header>
    <p><%= entry.body %></p>
</article>
```

> 파일명 앞에 `_`를 붙이면 render partial:에 사용된다.

## 3. Submitting posts

static 엔트리로 구성된 블로그는 제한적이다. 새로운 엔트리를 추가하는 기능을 만들어 보자.

먼저 `New post` 버튼을 만들자.

```erb
<!-- app/views/layouts/application.html.erb -->
<!-- ... -->
<div class="sidebar two columns">
    <nav>
        <ul>
            <li><%= link_to "New post...", new_post_path %></li>
        </ul>
    </nav>
</div>
<!-- ... -->
```

`new_post_path`를 추가하기 위해 아래를 routes.rb

```ruby
resources :posts
```

> resources
> | HTTP METHOD | PATH            | ACTION  | USED FOR                                           |
> | :---------- | :-------------- | :------ | :------------------------------------------------- |
> | GET         | /posts          | index   | 모든 포스트를보여줍니다.                           |
> | GET         | /posts/new      | new     | 새로운 포스트를등록하기 위한 HTML 폼을 보여줍니다. |
> | POST        | /posts          | create  | 새로운 포스트를 생성합니다.                        |
> | GET         | /posts/:id      | show    | 특정 한개의 포스트를 보여줍니다.                   |
> | GET         | /posts/:id/edit | edit    | 포스트 정보를 수정하기 위한 HTML 폼을 보여줍니다.  |
> | PATCH/PUT   | /posts/:id      | update  | 포스트 정보를 수정합니다.                          |
> | DELETE      | /posts/:id      | destroy | 특정 포스트를 삭제합니다.                          |

라우트를 위한 컨트롤러가 필요하다.

`rails generate controller Posts`

```ruby
class PostsController < ApplicationController
    def new
        @post = @blog.new_post
    end
end
```

@blog 객체가 PostsController와 BolgController 모두에 필요한 것 처럼 보인다. 공통된 부분을 `ApplicationController`으로 이동시켜 보자.

```ruby
# app/controllers/application_controller.rb
class ApplicationController < ActionController::Base
    # ...
    before_filter :init_blog
    private
    def init_blog
        @blog = Blog.new
    end
end
```

링크를 렌더링 하는 것은 끝났다. 이제, new post 폼을 만들어 보자.

```ruby
<!-- app/views/posts/new.html.erb -->
<h1>New Post</h1>
<%= form_for @post do |f| %>
    <%= f.text_field :title %>
    <%= f.text_area :body %>
    <%= f.submit %>
<% end %>
```

### Using ActiveModel

path를 구성하고, form은 렌더링하기 위해서는, 레일즈는 모델 객체가 반응할 프로토콜을 기대한다. 이 프로토콜을 준수하도록 하는 가장 쉬운 방법은 액티브모델에서 두 개의 모듈을 추가하는 것이다. 또한 `persisted?`를 만들었는데, 현재는 단순히 false를 리턴하도록 하자.

```ruby
class Post
    extend ActiveModel::Naming
    include ActiveModel::Conversion
    # ...
    def persisted?
        false
    end
    # ...
end
```

이제 `New post...` 링크를 클릭하면 새로운 post 폼을 볼 수 있다.

### The Post creation action

이제 submit하는 기능을 구현해보자.

PostsController에 create 메서드를 추가하자. ( `PostsController#create`)

```ruby
class PostsController
    # ...
    def create
        @post = @blog.new_post(params[:post])
        @post.publish
        redirect_to root_path, notice: "Post added!"
    end
    # ...
end
```

이제, BlogController에서 demo posts를 지워도 된다.

```ruby
class BlogController < ApplicationController
    def index
    end
end
```

### Making the Blog object into a Singleton

