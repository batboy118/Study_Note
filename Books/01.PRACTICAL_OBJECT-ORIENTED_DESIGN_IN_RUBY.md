# PRACTICAL OBJECT-ORIENTED DESIGN IN RUBY

>PRACTICAL OBJECT-ORIENTED DESIGN IN RUBY 책을 읽고 내용을 정리합니다.

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./README.md)

---

<!-- TOC -->

- [1. Object-Oriented Design](#1-object-oriented-design)
	- [1.1 객체 지향 디자인의 원칙과 디자인 패턴](#11-객체-지향-디자인의-원칙과-디자인-패턴)
	- [1.2 객체 지향 언어](#12-객체-지향-언어)
- [2. Designing Classes with a Single Responsibility](#2-designing-classes-with-a-single-responsibility)
	- [2.1. 클래스에 무엇이 포함될지 정하기](#21-클래스에-무엇이-포함될지-정하기)
		- [2.1.1. 클래스에 Method를 그룹핑하기](#211-클래스에-method를-그룹핑하기)
		- [2.1.2. 쉽게 수정가능한 코드를 구성하기](#212-쉽게-수정가능한-코드를-구성하기)
	- [2.2. 하나의 책임을 지는 클래스 만들기](#22-하나의-책임을-지는-클래스-만들기)
		- [2.2.1. 자전거와 기어](#221-자전거와-기어)
		- [2.2.2. 왜 단일 책임이 중요한가?](#222-왜-단일-책임이-중요한가)
		- [2.2.3. 클래스가 단일 책임을 가지는지 판단하기](#223-클래스가-단일-책임을-가지는지-판단하기)
		- [2.2.4. 언제 디자인을 만들지 판단하기](#224-언제-디자인을-만들지-판단하기)
	- [2.3 Writing Code That Embraces Change](#23-writing-code-that-embraces-change)
		- [2.3.1 데이터가 아닌 행동에 의존하기](#231-데이터가-아닌-행동에-의존하기)
		- [2.3.2. 모든 곳에 단일 책임 원칙 강제하기](#232-모든-곳에-단일-책임-원칙-강제하기)
	- [2.4. Finally, the Real Wheel](#24-finally-the-real-wheel)
- [3. Managing Dependencies](#3-managing-dependencies)
	- [3.1. 의존성 이해하기](#31-의존성-이해하기)
		- [3.1.1. 의존성 알아채기](#311-의존성-알아채기)
		- [3.1.2. 객체들 간의 결합(CBO - Coupling Between Objects)](#312-객체들-간의-결합cbo---coupling-between-objects)
		- [3.1.3. 다른 의존성들](#313-다른-의존성들)
	- [3.2. 약하게 결합된 코드 작성하기](#32-약하게-결합된-코드-작성하기)
		- [3.2.1. 의존성 주입하기](#321-의존성-주입하기)
		- [3.2.2. 의존성 격리시키기](#322-의존성-격리시키기)
		- [3.2.3. 인자 순서에 대한 의존성 제거하기](#323-인자-순서에-대한-의존성-제거하기)
		- [3.3.2. 의존성 방향을 선택하기](#332-의존성-방향을-선택하기)

<!-- /TOC -->

## 1. Object-Oriented Design

세상은 절차적이다. 시간의 흐름대로 사건이 흘러간다. 또한, 세계는 객체지향적이다. 객체들의 행동은 자연스럽게 섞이기 때문에 예상치 못한 행동들의 조합이 나타날 수 있다.

절차적 프로그램은 예상치 못한 행동들의 조합을 프로그래밍하기 어려운 경우가 많다. 이를 해결하기 위해 객체지향 설계가 등장해다. 객체지향 디자인은 이미 정해진 절차들을 묶음으로 생각하지 않고, 객체가 서로 주고받는 메세지들의 연속으로 파악해야 한다. 그렇게 때문에 프로그래머는 객체들의 연관성을 잘 정의해준다면 모든 사건의 조합을 만들어낼 필요가 없다.

객체지향 설계에 실패하는 것은 관점이 제대로 확립되지 않아서이다. 객체지향적 관점을 확실히 가지게 되면 실패할 수 없다.

객체지향 어플리케이션은 상호작용하는 여러 객체로 구성되어 있고 상호작용하는 방석은 서로 메세지를 주고받는 것이다. 여기서 송신하고 수신하는 객체가 두 객체 사이의 의존성을 만들어 내고, 이러한 의존성으로 인해 객체를 수정하는 것이 어려워진다.

객체 지향 설계는 의존성 관리에 관한 것이다. 객체들이 변화를 용인할 수 있도록 의존성을 잘 관리하는 것이 객체 지향 디자인이다. 제대로된 설계가 되지 않으면 객체들이 서로에 대해 너무 많이 알기 떄문에 관리되지 않는 의존성은 큰 혼란을 초래한다.

모든 어플리케이션은 코드의 집합이고, 코드를 어떻게 배열하는 것이 바로 설계이다. 설계를 할 때 고려해야 할 것이 두가지가 있다. 먼저 현재의 기능을 충실히 구현할 수 있어야한다는 것이다. 두번째는 나중에 변경될 수 있는 것을 고려해서 코드를 작성해야 한다는 것이다.

디자인은 나중에 디자인할 수 있는 여지를 남겨 놓기 위한 것이고, 그 최종 목표는 변화의 비용을 최소화하는 것이다.

### 1.1 객체 지향 디자인의 원칙과 디자인 패턴

`SOLID`는 마이클 플레즈가 만들고 로버트 마틴이 대중화한 객체 지향 설계의 5가지 원리이다.

1. Sngle Responsibility - 단일 책임
2. Open-Closed - 개방-폐쇄
3. Liskov Substitution - 리스코프 치환
4. Interface Segregation - 인터페이스 분리
5. Dependency Inversion - 의존성 역전

다른 디자인 원칙으로는 앤디 헌트와 데이브 토머스의 `DRY`(Don't Retape Yourself)와 노스이스트 대학교의 데메터 프로젝트의 `Law of Demeter`(LoD)가 있다. 이러한 설계 원칙들을 이 책을 통해서 다룬다.

또한, 객체지향 디자인의 원칙 외에도 디자인 패턴을 이해하는 것이 중요하다. <GoF의 디자인 패턴>은 패턴이란 객체지향 소프트웨어 디자인에서 명확한 문제를 처리하는 간단하고도 우아한 해결책이라고 말한다. 디자인 패턴은 **동일한 문제를 같은 방식으로 해결할 수 있는 방법**에 이름을 부여한 것을 말한다. 디자인 패턴은 프로그래머들이 서로 소통하고 협업할 수 있는 방법을 제공해 주었다.

디자인은 **반복적인 피드백**과 함께하는 **점진적인 발견**의 과정이다. 그리고 디자인은 지속적인 자기조절 능력을 갖추고, 자연스럽게 발전하는 것이 가장 좋다. 때문에 반복과 점진적인 발전을 중시하는 애자일 소프트웨어 개발은 잘 디자인된 애플리케이션을 만드는 데 매우 적합하다. 좋은 애플리케이션을 위해서는 **초기에 큰 디자인을 구상하지 않고 계속해서 디자인을 변경해주는 게 좋다**.

### 1.2 객체 지향 언어

 일반적인 절차지향적인 언어와 다르게 루비와 같은 객체지향 언어는 데이터와 행동(함수)를 완전히 분리하지 않고 하나의 객체에 결합하여 넣는다. 즉, 객체는 행동과 데이터를 포함하고, 객체만이 제어할 수 있는 데이터를 포함한다. 객체는 서로 메세지를 보내면서 서로의 행동을 불러 일으킨다.

루비는 문자열 데이터 타입 대신 문자열 객체를 가지고 있다. 문자열로 작동하는 연산은 언어의 문법대신에 문자열 객체에 내장되어 있다. 각각의 문자열 객체는 고유한 개인 데이터 문자열을 포함한다는 점에서 다르지만, 모든 문자열 객체는 동일한 동작을 한다는 점에서 유사하다고 볼 수 있다.

문자열 객체가 자체적으로 알맞은 행동을 제공해 주기때문에 문자열 데이터의 타입에 대해서 특별히 신경쓸 필요가 없다. 프로그래머는 객체가 메세지를 보내는 일반적인 방법만 알면 된다.

루비와 같은 클래스 기반의 객체 지향 언어는 유사한 객체의 구성에 대한 청사진을 제공하는 클래스를 정의 할 수 있다. 클래스는 메서드와 프로퍼티를 정의한다. 메서드는 메세지에 응답하여 호출된다. 동일한 메서드 이름은 다른 오브젝트에서도 정의될 수 있다. 전송된 메세지에 대한 올바른 오브젝트의 메서드를 찾고 호출하는 것은 루비의 역할이다.

클래스는 단순한 데이터 이상의 유형을 정의한다. 물체의 유형을 알면 물체가 어떻게 행동할지 예상할 수 있다. 절차지향 언어에서 변수는 단일 데이터 타입을 가진다. 이 데이터 타입에 대한 지식은 어떤 연산이 유효한지에 대한 예상하게 한다. 루비에서는 하나의 객체는 많은 타입을 가질 수 있다. 객체의 타입을 아는 것은 객체가 응답하는 메세지의 대한 예상을 할수 있게 한다.

루비에는 미리 정의된 클래스가 많이 있다. 가장 즉시 알아차릴수 있는 클래스는, 절차지향에서 쓰이는 데이터 타입과 중복되는 것들이다. 예를들면 스트링 클래스나, 정수를 표현하기 위한 Fixnum클래스 등이 있다. 보통은 모든 데이터 타입을 위한 미리정의된 클래스가 있다.

하지만, 객체지향 언어는 그 자체로 객체를 이용하여 만들어지고 이 점이 흥미로운 부분이다. 스트링 클래스 (새로운 문자열 객체를 위한 청사진)은 그 자체로 객체이다. 즉, String 클래스 또한 Class 클래스의 인스턴스이다. 모든 스트링 객체가 데이터가 구체화된 String 클래스의 객체라면, 모든 클래스 객체(String Fixnum ..)는 구체화된 데이터를 가지는 Class클래스의 인스턴스인 것이다. String 클래스가 새로운 문자열들은 만든다면, Class 클래스는 새로운 클래스들을 만든다.

## 2. Designing Classes with a Single Responsibility

객체지향 시스템에서 기초가 되는 것은 메세지이지만, 가장 뚜렷하게 확인할 수 있는 구조는 class이다. 메시지가 디자인의 핵심이지만, 클래스가 더 뚜렷하기 때문에 이번 장에서는 클래스에 속하는 것을 정하는 방법에 대해서 집중할 것이다.

만들려는 클래수가 무엇이고, 얼마나 많으며 어떠한 행동을 포함하고 있고 다른 클래스와의 관계는 어떠한지 정하는지에 대한 질문이 있을 수 있다. 이에 대한 정답은 클래스는 단순해야 한다는 것이다.

어플레케이션을 모델링하고, 클래스를 사용해서 지금 당장 있어야 하면서 나중에 수정하기 쉽게 하는 것이 목표이다. 현재 코드가 동작하게 하는 문제는 쉽지만, 수정하기 쉽게 만드는 것은 다른 문제이다.

### 2.1. 클래스에 무엇이 포함될지 정하기

#### 2.1.1. 클래스에 Method를 그룹핑하기

루비와 같은 객체지향 언어에서 메소드들은 클래스안에 정의되어 있다. 한번 생성된 클래스는 어플리케이션에 영원히 영향을 미칠것이다. 하지만, 메소드들을 알맞게 그룹핑하는것이 중요할지라도 프로젝트의 초반에 그것을 정하는 것이란 어려운 일이다. 또한, 성공적으로 그룹핑 했다고 하더라도 어플리케이션이 변하게 되다면 또 수정해야할 일이 발생할 수 있다. 디자인이란 완벽을 추구하는 행동이 보다는 영구적 변화에 대한 예술이다.

#### 2.1.2. 쉽게 수정가능한 코드를 구성하기

수정하기 쉽다는 것은 명확하지 않기 때문에 그 의미를 정의할 필요가 있다.

> 수정하기 쉬운것의 정의

1. Changes have no unexpected side effects
2. Small changes in requirements require correspondingly small changes in code
3.  Existing code is easy to reuse
4. The easiest way to make a change is to add code that in itself is easy to change

> 수정하기 쉬운것의 기준 (TRUE)

1. **Transparent** The consequences of change should be obvious in the code that is changing and in distant code that relies upon it
2. **Reasonable** The cost of any change should be proportional to the benefits the change achieves
3. **Usable** Existing code should be usable in new and unexpected contexts
4. **Exemplary** The code itself should encourage those who change it to perpetuate these qualities

TURE를 만족하는 코드를 짜는 것의 첫 번째 단계는 각 클래스는 **단 하나의 잘 정의된 책임**을 가지는 것이다.

### 2.2. 하나의 책임을 지는 클래스 만들기

클래스는 최대한 작으면서도 유용해야한다. 즉, 클래스는 단일 책임을 가져야 한다.

#### 2.2.1. 자전거와 기어

자전거를 탈 때는 작은 기어(페달이 가벼워지고 느려짐), 큰 기어(페달이 무겁고 빨라짐) 중에 선택할 수 잇다. 기어는 발이 페달을 돌리는 힘으로 바퀴를 돌린다. 구체적으로는 페달이 회전할 때마다 바퀴가 얼마나 회전하는지를 기어에서 제어한다.

![image](https://user-images.githubusercontent.com/53181778/85508105-65bf2d00-b62e-11ea-9079-42ae9ca02fea.png)

크고 작은 기어를 비율로 표현할 수 있다.

```ruby
chainring = 52 # number of teeth
cog = 11
ratio = chainring / cog.to_f
puts ratio # -> 4.72727272727273

chainring = 30
cog = 27
ratio = chainring / cog.to_f
puts ratio # -> 1.11111111111111
```

위 코드를 기어 클래스로 만들어보자. 기어는 chainring, cog, ratio를 가지고 data와 behavior를 가지게 된다.

```ruby
class Gear
	attr_reader :chainring, :cog

	def initialize(chainring, cog)
	@chainring = chainring
	@cog = cog
	end

	def ratio
    	chainring / cog.to_f
	end
end

puts Gear.new(52, 11).ratio # -> 4.72727272727273
puts Gear.new(30, 27).ratio # -> 1.11111111111111
```

Gear클래스는 Object클래스의 서브 클래스로 많은 메소드들을 상속 받는다. 그렇게 때문에 응답할 수 있는 메세지의 집합(behavior의 집합)이 꽤 큰편이다. 상속은 어플리케이션 설계에 중요하지만, Gear클래스와 같이 간단한 경우는 매우 기본적인 상속에 해당하기 때문에 상속된 메소드가 없다고 생각해도 된다. (상속의 복잡한 형태는 6장에서 다룰 것이다. )

만약, 두대의 자전거를 가지고 있고 서로 같은 기어를 가지고 있지만, 다른 사이즈의 바퀴를 가지는 경우라면 바퀴의 영향도 고려해야 할 것이다. 보통 기어 인치를 이용하여 바퀴와 기어가 다른 자전거들을 비교한다.

`gear inches = wheel diameter * gear ratio` where `wheel diameter = rim diameter + twice tire diameter`

```ruby
class Gear
  attr_reader :chainring, :cog, :rim, :tire
  def initialize(chainring, cog, rim, tire)
    @chainring = chainring
    @cog = cog
    @rim = rim
    @tire = tire
  end

  def ratio
    chainring / cog.to_f
  end

  def gear_inches
    # tire goes around rim twice for diameter
    ratio * (rim + (tire * 2))
  end
end

puts Gear.new(52, 11, 26, 1.5).gear_inches
# -> 137.090909090909
ㄴ
puts Gear.new(52, 11, 24, 1.25).gear_inches
# -> 125.272727272727
```

하지만, 만약 기존에 사용하던 코드에서 `puts Gear.new(52, 11).ratio`와 같이 사용했다면, initialize의 파라미터 수와 맞지 않기 때문에 에러가 난다. gear_inches 기능을 추가하면서 생긴 버그이다. 아직까진 프로그램이 작기 때문에 큰 문제는 되지 않는다.

하지만, 이게 최선일까? 앞으로 더 많은 클래스가 생겨날 것이고 어플리케이션은 더 커질것이다. 더 효율적으로 확장시키기 위해 코드는 더 바꾸기 쉬워야 한다.

#### 2.2.2. 왜 단일 책임이 중요한가?

수정이 쉬운 어플리케이션은 재사용하기 쉬운 클래스들로 이루어져 있다. 재사용 가능한 클래스는 얽힘이 거의 없는 잘 정의된 행동의 접속 가능한 유닛(쉽게 가져다 쓸수 있는 유닛)이다.

하나 보다 많은 책임이 있는 클래스는 재사용하기 어렵다. 여러 책임을 가지는 클래스는 얼기설기 얽혀있는 것과 같다. 만약, 클래스의 전체가 아니라 일부분을 재사용하고 싶다면, 필요한 부분들만 얻는 것은 불가능하다. 이제 두 가지 옵션이 있고 두개다 매력적인 옵션은 아니다.

책임들이 너무 결합되어 필요한 행동들만 사용할 수 없다면, 필요한 코드를 복제하여 사용할 수 있다. 하지만 코드를 복제하는 것은 추가적인 유지보수를 유도하고 버그를 증가시키기 때문에 좋은 방법이 아니다. 만약 필요한 행동들에만 접근할 수 있는 구조화된 클래스가 있다면, 클래스 전체를 재사용 할 수 있을 것이다. 하지만, 이것은 단지 하나의 문제를 다른 문제로 대치하는 것에 불과하다. 재사용하는 클래스는 원래의 목적이 혼동되고, 뒤얽힌 몇몇 책임을 포함하게 되기 때문에, 여러 이유로 바뀌어야 한다. 여러 일을 하는 클래스에 의존하게 되면 어플리케이션이 잘못될 가능성이 높아진다.

#### 2.2.3. 클래스가 단일 책임을 가지는지 판단하기

클래스가 하나의 책임만을 가지는지 판단하는 방법에는 무엇이 있을까?

클래스가 인격이 있는 것처럼 질문을 하는 방법이 있다. 모든 메소드들을 질문으로 바꾸면, 질문을 하는 것이 말이 된다. 예를 들어, Gea에게 `당신의 기어비는 무엇인가요?` 라고 물어볼 수 있다. 하지만, 기어클래스에 `당신의 기어인치는 몇인가요?` 또는 `당신의 타이어 사이즈는 얼마나 되나요?` 와 같은 질문은 이상하다. 하지만 기어 클래스에게 `당신의 타이어는 무엇인가요?` 라고 물어보는 것은 충분히 가능한 일이다. 기어 클래스에서, 타이어는 ratio나 gear_inches와는 다른 종류의 것이다. 다른 모든 객체의 관점으로부터, 기어가 응답할수 있는 것은 또 다른 메세지일 뿐이다. 만약 기어가 메세지에 응답할 수 있다면 무언가가 메세지를 보낼것이고, 기어가 바뀐다면 송신자는 놀랄수도 있다(?).

클래스가 실제로 무엇을 하고있는지 이해하는 또 다른 방법은, 클래스의 책임을 한 문장으로 묘사해 보는 것이다. 클래스는 최대한 작으면서 유용한 것만 해야한다. 그렇기 때문에 간단하게 묘사할 수 있어야 한다. 만약 가장 단순한 표현에 `그리고, 또는`이라는 단어가 들어간다면 여러개의 책임을 가지고 있다고 볼 수 있다.

객체지향 설계는 `cohesion(화합, 결합, 응집력)` 의 단어를 사용하여 단일 책임의 개념을 설명한다. 하나의 클랙스 안에 있는 모든 것들이 클래스의 핵심 목적에 연관되어 있을 때, 이 클래스는 강하게 cohesion(결합)되어 1개의 책임을 가진다고 할 수 있다.

단일 책임 원칙(Single Responsibility Principle (SRP) )은 Wirfs-Brock & Brian Wilkerson의 Responsibility-Driven Design (RDD)에 뿌리를 두고 있다. RDD는 `하나의 클래스는 클래스의 목적을 수행하는 책임들로 구성되어 있다.`고 말한다. SRP는 하나의 클래스가 하나의 매우 좁은 일(목적)을 하거나 사소한 이유로 바뀌는 것을 요구하지 않는다. 대신에 SRP는 응집력있게 클래스가 하는 모든것은 클래스의 목적과 매우 높게 연관이 있어야 하는 것을 요구한다.

기어 클래스의 책임을 표현하자면 “앞, 뒤 톱니바퀴 사이의 기어비를 계산한다”. 만약 그렇다면 위에서 만든 Gear 클래스는 너무나 많은 일을 하고있다. 만약 “자전거에 기어가 미치는 영향을 계산한다”로 표현한다면 더 어울릴 것이다. 그렇다면 gear_inches 는 Gear 에 속하는 것이 맞지만, 타이어의 크기가 Gear에 속하는 것은 애매하다.

#### 2.2.4. 언제 디자인을 만들지 판단하기

클래스에 뭔가 문제가 있다고 느껴지는 순간이 자주 있다. Gear클래스에 왜 바퀴가 있지? 사실은 Bicycle 클래스이지 않을까 하는 고민이 있을 수 있다.

하지만, 우리는 미래에 어떤일이 생길지 모르고 우리에게 그에 대한 ㅈ어보가 없다. 준비가 안된 상태에서 서둘러서 디자인을 결정해야 한다고 느끼는 것은 좋지 않다. 다만, Gear클래스를 보면서 문제를 느꼈다면, `지금 이 문제를 수정하지 않는 다면 나중에 어떤 대가를 치르게 될까?`라고 스스로에게 질문해보자. 어쩌면 더 많은 정보를 얻을때 까지 아무것도 하지 않고 기다려 보는 것이 효율적인 접근일 수도 있다.

Gear클래스의 코드는 투명하고 적잘하지만 훌륭한 디자인은 아니다.아무런 `의존성`도 없기 때문에 코드를 수정한다고 해서 특별한 문제는 발생하지 않을 뿐이다. 만약 다른 객체와 의존성이 생긴다면 Gear 클래스는 투명함과 적절함을 잃게 될 것이다. 이 떄가 코드를 다시 구성해야할 때 이다. 그리고 이 의존성이 좋은 디자인을 결정하는 정보를 제공해준다.

지금 코드를 수정하는 비용이나 나중에 수정하는 비용이나 필요한 비용이 동일하다면 결정을 나중으로 미루는 것이 좋다. **디자인 결정은 꼭 필요한 순간에, 그 순간이 제공하는 정보들을 가지고 해야한다.**

하지만 Gear클래스는 지금당장 수정해야할지, 변경해야할지 의견이 분분할 것이다. 현재 클래스의 구조는 미래의 개발자에게 지금의 디자인 의도를 전달하는 메세지 이다. 미래의 개발자는 현재의 디자인 패턴을 참조할 것이다. 결론적으로, Gear클래스는 디자인 의도를 잘못 전달하고 있다. 사용성이 좋지도 않고, 좋은 코드도 아니다. 여러가지 책임을 가지고 있기 때문에 재사용하면 안되는 코드이다.

### 2.3 Writing Code That Embraces Change

나중에 수정에 필요한 경우에라도 쉽게 수정될 수 있도록 코드를 배치하는 일은 가능하다. 즉, 수정하기 쉬운 방식으로 코드를 하는 것이다.

#### 2.3.1  데이터가 아닌 행동에 의존하기

행동은 메서드에 담겨있고 메세지를 보내는 행위를 통해 실행된다. 하나의 책임을 가지는 클래스를 만들때, 행동의 모든 작은 조각들은 한 장소에 속하게 된다. Don't Repeat Yorself(DRY)라는 문장은 이러한 아이디어를 의미한다. 행동을 바꾸는 것은 코드의 어떤 한 부분만을 바꾸면 되기 때문에, DRY 코드는 변화를 견뎌낼 수 있다.

객체는 행동과 함께 데이터를 가진다. 데이터는 객체의 인스턴스 변수에 속해 있고, 간단한 문자열이나 복잡한 해시일 수 있다. 데이터는 두가지 방법 중 하나로 접근할 수 있다. 인스턴스 변수를 직접 참조하거나, accessor 메서드안에 인스턴스 변수를 감싸는 방법이 있다.

- 인스턴스 변수 숨기기

  아래의 ratio 메서드 처럼, 직접 인스턴스 변수를 참조하는 대신에 인스턴스 변수를 accessor 메서드에 감싸서 접근하라.

  ```ruby
  class Gear
      def initialize(chainring, cog)
          @chainring = chainring
          @cog = cog
      end
      def ratio
          @chainring / @cog.to_f # <-- road to ruin
      end
  end
  ```

  클래스에서 변수들을 정의하고 있을지라고, 메서드로 변수를 감싸서 숨겨라. 루비는 `attr_reader`를 제공하여 캡슐화된 메서드를 쉽게 만들수 있다.

  ```ruby
  class Gear
      attr_reader :chainring, :cog # <-------
      def initialize(chainring, cog)
          @chainring = chainring
          @cog = cog
      end

      def ratio
          chainring / cog.to_f # <-------
      end
  end
  ```

  `attr_reader`는 변수를 감쌀 수 있는 간단한 wrapper 메서드를 생들어 준다.

  > cog를 위한 가상의 wrapper 메서드

  ```ruby
  # default implementation via attr_reader
  def cog
  	@cog
  end
  ```

  cog메서드만이 cog가 무엇을 의미하는지 이해할 수 있는 유일한 방법이다.  cog는 메세지 전송의 결과가 되었다. 이 메서드 구현함으로 cog는 `모든 곳에서 참조되는 데이터`에서 `한 번만 정의된 행동`으로 바뀌었다.

  `@cog` 인스턴스 변수가 10번 참조되고 갑자기 @cog의 내용을 바꿔야 한다면, 코드의 여러 부분을 수정해야 한다. 하지만 @cog가 래퍼 메서드로 감싸져 있었다면 cog 메서드를 직접 구현해서 cog가 어떤 의미인지 다시 정의할 수 있다. 우리가 직접 작성한 새로운 메서드는 아래의 첫 번째 예시처럼 간단할 수도 있고 두 번째 예시처럼 더 복잡할 수도 있다.

  #1

  ```ruby
  # a simple reimplementation of cog
  def cog
      @cog * unanticipated_adjustment_factor
  end
  ```

  #2

  ```ruby
  # a simple reimplementation of cog
  def cog
     	@cog * (foo? ? bar_adjustment : baz_adjustment)
  end
  ```

  데이터를 마치 '메시지를 이해하는 객체' 처럼 취급하는 것은 두 가지 이슈를 품고 있다.

  첫 번째 이슈는 `가시성`이다. `@cog`변수를 public 메서드로 감쌀 경우 다른 객체에 `@cog`변수에 접근할 수 있음을 의미한다. 반대로, private 메서드로 감쌀경우 외부에서는 접근할 수 없다. 이 두 선택지에 대해서는 4장에서 다룬다.

  두 번째 이슈는 조금더 더 추상적이다. 모든 변수를 메서드로 감싸고, 어떤 변수든지 마치 객체인것 처럼 다룰 수 있기 때문에 데이터와 보통의 객체를 구분하는 것이 무의미해진다. 가끔 어플리케이션의 일부분을 행동이 없는 데이터라 생각하는 것이  편리할 수 있지만, 대부분의 경우 데이터를 일반적인 객체로 받아들이는 것이 더 좋다.

  데이터를 감춤으로 예상치 못한 변화로부터 코드를 보호할 수 있다. 개발자도 데이터의 모든 행동을 다 알 수 없다. 변수를 데이터 처럼 생각할 지라도, 변수는 메시지를 보내는 것으로 접한하는 것이 좋다.

- 데이터 구조 숨기기

  인스턴스 변수에 애착을 가지는 것은 안좋지만, 복잡한 데이터 구조를 가지는 것은 더욱 더 좋지 않다. 아래의 ObscuringReferences 클래스를 보자.

  ```ruby
  class ObscuringReferences
      attr_reader :data
      def initialize(data)
          @data = data
      end

      def diameters
          # 0 is rim, 1 is tire
          data.collect {|cell|
              cell[0] + (cell[1] * 2)}
      end
      # ... many other methods that index into the array
  end
  ```

  이 클래스는 2차원 배열의 rims와 tires로 초기화 된다.

  ```ruby
  # rim and tire sizes (now in millimeters!) in a 2d array
  @data = [[622, 20], [622, 23], [559, 30], [559, 40]]
  ```

  ObscuringReferences 는 @data에 초기화 아규먼트를 저장하고, @data를 메서드에 감싸기 위해 attr_reader를 사용했다. diamwters메서드는 data에게 변수의 내용물에 접근하는 메세지를 보낸다. 이렇게 클래스 내부에서도 인스턴스 변수를 숨기고 있다.

  하지만, @data는 복잡한 데이터 구조를 가지고 있다. 단순히 인스턴스 변수를 숨기는 것만으로는 충분하지 ㅇ낳다. data 메서드는 단순히 배열을 반환할 뿐이다. 배열을 가지고 어떤 작업을 하려면, data메서드를 전송하는 객체의 정보를 잘 알고 있어야한다.

  diameters 메서드는 지름을 계산하는 것 뿐만아니라, rims와 tires를 배열의 어디서 찾아야 하는지 알고 있다. 배열의 [0]에 rims가 [1]에는 tires가 있다는 것을 알고 있다.

  이것은 배열의 구조에 의존적이다. 만약 데이터 구조가 바뀐다면 코드는 반드시 바뀌어야 한다. 배열에 데이터를 가지고 있을 때, 어플리케이션 곳곳에서 배열의 구조를 참조하는 코드를 작성해야 한다. 이런 참조는 위험하다. 변수의 캡슐화를 무시하고 배열 구조에 대한 지식을 코드 이곳저곳에 흩뿌려 놓는다. 전혀 DRY하지 않다. rims가 [0]에 있다는 것이 중복되어서는 안된다. 한 장소에서 이러한 것들을 관리해야한다.

  간단한 예시로 이것이 얼마나 나쁜지 충분히 확인할 수 있다. data가 여러 해시들로 이루어진 배열을 반환하고 이 배열을 코드의 여러 곳에서 사용한다고 상상해 보자. data의 구조를 변경한다면 코드 곳곳에 영향을 미칠 것이다. 그리고 각각의 변화는 버그를 만들수 있다.

  루비는 구조에서 의미를 손쉽게 분리할 수 있게 해준다. 메서드로 인스턴스 변수를 손쉽게 감쌀 수 있는 것처럼 루비의 `Struct 클래스`를 이용하면 데이터 구조를 감쌀 수 있다. 앞의 클래스와 동일한 외부 인터페이스를 가지고 있지만, 내부 인터페이스는 전혀 다르게 구현하였다.

  ```ruby
  class RevealingReferences
      attr_reader :wheels
      def initialize(data)
          @wheels = wheelify(data)
      end
      def diameters
          wheels.collect {|wheel|
              wheel.rim + (wheel.tire * 2)}
      end
      # ... now everyone can send rim/tire to wheel

      Wheel = Struct.new(:rim, :tire)
      def wheelify(data)
          data.collect {|cell|
              Wheel.new(cell[0], cell[1])}
      end
  end
  ```

  변경된 클래스의 diameters 메서드는 배열의 내부 구조에 대한 지식이 전혀 없다. diameters가 알고있는 전부는 wheels 메세지가 enumerable를 리턴한다는 것과 각각의 enumerable에 속해 있는 모든 객체가 rim과 tire메서드에 응답할 수 있다는 것이다. 기존에는 cell[1]에 대한 참조였지만, wheel.tire로 메세지를 보내는 방식으로 바뀌었다.

  입력받은 배열의 구조에 대한 모든 지식은 `wheelify` 메서드 속에 격리되었고 이 메서드는 `배열들의 배열`을 `Struct들의 배열`로 변환 시켰다.루비 공식문서에는 `Struct`는 `명시적으로 클래스를 만들지 않고도 accesor 메서드를 이용해 여러 어트리뷰트들을 묶어내는 편리한 방법`이라고 정의한다. 즉, rim과 tire 메서드에 반응하는 작고 가벼운 객체를 만들어 준 것이다.

  `wheelify` 메서드는 입력받은 배열의 구조에 대한 코드로만 이루어져 있다. 만약 입력값이 변한다면 바로 이 지점만 더 작성해야했지만, 이는 반복적으로 복잡한 배열의 구조를 참조해야 하는 비용에 비하면 아주 작은 번거로움에 지나지 않는다.

  이런 스타일의 코드는 외부 데이터 구조의 변화로 부터 코드를 보호해준다. 보다 가독성이 좋고 의미가 잘 드러나는 코드를 작성할 수 있다. 데이터 구조를 들여다 보던 작업을, 객체에 대한 메세지 전송 작업으로 대체한다. wheelify메서드는 구조에 대한 지저분한 정보를 한쪽에 몰아 놓고 코드를 DRY하게 만든다. 클래스가 변화를 쉽게 받아들일 수 있도록 만들다.

#### 2.3.2. 모든 곳에 단일 책임 원칙 강제하기

단일 책임 클래스를 만드는 것은 디자인에 중요한 영향을 주지만, 단일 책임의 아이디어는 코드의 많은 부분들에 유용한게 적용할 수도있다.

- 메서드에서 여분의 책임을 뽑아내기

  클래스와 같이 메서드도 하나의 책임을 가져야 한다. 메서드가 하나의 책임만을 지닐 때 메서드는 수정하기 쉽고 재사용하기도 쉽다. 클래스에 단일 책임을 적용하는 것과 매우 유사하다. 메서드의 하는일을 물어보고, 하나의 문장으로 메서드의 책임을 묘사해보자.

  ```ruby
  def diameters
    wheels.collect {|wheel|
      wheel.rim + (wheel.tire * 2)}
  end
  ```

  이 메서드는 명확하게 두개의 책임을 가지고 있다. wheels 배열을 순회하는 것과, 각 바퀴의 지름을 계산하는 것이다.

  단순화 하기 위해 하나의 책임만을 가지는 두 개의 메서드로 분리할 수 있다. 반지름을 계산하는 부분을 독립적인 메서드로 뽑아내보자. 메세지 전송이라는 추가적인 비용이 발생하지만, 현재는 성능보다 수정할 수 있는 코드를 작성하는 것에 집중하자.

  ```ruby
  first - iterate over the array
  def diameters
    wheels.collect {|wheel| diameter(wheel)}
  end

  # second - calculate diameter of ONE wheel
  def diameter(wheel)
    wheel.rim + (wheel.tire * 2))
  end
  ```

  바퀴 단 한 개의 지름을 계산해야할 일이 있는가? 코드를 다시 살펴보면, 이미 그러고 있다는 것을 알 수 있다. 이 리팩토링은 과도한 디자인을 적용한 것이 아니다. 단순히 사용중인 코드를 재구성했을 뿐이다. 단수형 diameter메서드가 다른 곳에서 불릴 수 있다는 사실은 좋은 부수효과를 얻은 것이다.

  개별 객체에 행해지는 액션과 객체들을 반복 순회하는 것을 분리하는 것은 쉽게 알아 챌 수 있는 다중 책임의 경우이다. 보통의 경우 이렇게 쉽게 보이지 않는다.

  Gear 클래스의 gear_inches메서드를 회상해보자.

  ```ruby
  def gear_inches
    # tire goes around rim twice for diameter
    ratio * (rim + (tire * 2))
  end
  ```

  gear_inches는 Gear클래스의 책임인가? 그럴듯해 보이지만, 아니다. 그 이유는 gear_inches는 단일 책임이 아닌 여러개의 책임을 지니고 있기 때문이다.

  gear_inches에 숨겨져있는 바퀴으 지름을 구하는 부분때문이다. 그 부분을 분리해보자.

  ```ruby
  def gear_inches
    ratio * diameter
  end

  def diameter
    rim + (tire * 2)
  end
  ```

  이제 gear_inches메서드는 메시지를 전송해서 바퀴의 지름을 알아낸다. 이번 리팩토링이 지름을 계산하는 방법을 변경하지 않았다는 사실에 유의하자. 단지 지름을 계산하는 행동을 분리 했을 뿐이다.

  최종적인 결과물을 모르는데도 이러한 리패토링이 필요한 것일까?의 대답은 '그렇다'이다. 리팩토링이 필요한 이유는 디자인이 명확하기 떄문이 아니라 오히려 디자인이 불명확하기 때문이다.

  이 간단한 리팩토링은 문제를 명확하게 드러내준다. Gear클래스에서 gear_inches를 계산할 필요는 있지만, 바퀴의 지름을 계산해서는 안된다.

  하나의 리팩토링의 영햔은 제한적이지만, 이런 코딩스타일이 누적되면 그 영향은 매우 거대해진다. 여러 메서드가 각각의 하나의 책임을 질 때 다음과 같은 이득이 있다.

  - **Expose previously hidden qualities**

    리팩토링을 통해 클래스의 모든 메서드가 단일 책임을 가지면 클래스 자체가 명확해진다. 당장 메서드들을 다른 클래스로 옮기고 재정리 하지 않아도 메서드 하나하나가 하나의 목적을 가지면 클래스가 하는일이 더욱 명확해진다.

  - **Avoid the need for comments**

    주석은 실행이 되는 코드가 아니기 떄문에 시간이 지나면 바스러지는 종이문서같다.  메서드 속에 있는 코드 한 조각에 주석을 달아야 한다면 그 코드를 별도의 메서드로 뽑아내자. 뽑아낸 메서드의 이름이 주석과 동일한 역할을 할 수 있다.

  - **Encourage reuse**

    작은 메서들은 우리의 애플리케이션에 도움을 주는 코딩 습관을 장려한다. 다른 프로그래머들도 코드를 다시쓰기보다는 메서드를 재활용 할 것이다. 결국, 그들은 작고 재사용이 가능한 메서드들을 만들게 될 것이다.

  - **Are easy to move to another class**

    디자인에 필요한 정보를 얻고 코드를 수정하기로 결정했을 때, 작은 메서스들은 이동하기 쉽다 리팩토링하는 수고를 많이 들이지 않고도 클래스의 행동을 재배치할 수 있다.

- 클래스의 추가적인 책임들을 격리 시켜 놓기

  모든 메서드들이 하나의 책임만 지게 되면 클래스의 역할의 범위 역시 분명해진다. Gear클래스에 바퀴의 것으로 보이는 행동이 있다. Wheel클래스를 애플리케이션에 추가해야 하는가?

  현재 Wheel클래스를 만드는 데 큰 무리가 없다면 만드는 방법도 괜찮아 보인다. 하지만 일단은 만들지 않기로 마음을 먹었다고 가정해보자. 어떤 디자인 이수가 있어 클래스를 만들고 싶지 않을 수도있고 지금 코드가 발전해가는 방향에 확신이 없어서 새로운 클래스를 만들었을 때 이 클래스를 다른 프로그래머가 사용하는 것이 꺼려질 수 있다.

  Gear가 하나의 책임만 지려면, Wheel 의 것으로 보이는 행동을 분리해야 할 것 같다. Gear클래스에 그대로 두거나 제거하거나, 두 가지의 양자택일의 문제에 따라 디자인을 결정하는 것은 근시안적이다.

  우리게에는 하나의 선택지가 더 있다. 최대한 특정 디자인에 종속되지 않으면서, Gear가 하나의 책임만을 지도록 하는 것이다.왜냐하면 수정하기 쉬운 코드를 작성하려면 진짜 어쩔수 없는 순간이 올 때까지 최대한 결정을 미루는 것이 좋기 때문이다. 진짜 필요하기 전에 내린 모든 결정은 단지 추측에 불과하다.

  루비는 바퀴 지름을 계산하는 책임을 Gear 클래스로부터 제거하면서도 새로운 클래스에 이 책임을 부여하지 않을 수 있는 방법을 제공한다. 다음 코드는 기존의 **Wheel Struct**에 **블록**을 이용해서 **지름을 계산**하는 메서드를 추가한다.

  ```ruby
  class Gear
    attr_reader :chainring, :cog, :wheel
    def initialize(chainring, cog, rim, tire)
      @chainring = chainring
      @cog = cog
      @wheel = Wheel.new(rim, tire)
    end

    def ratio
      chainring / cog.to_f
    end

    def gear_inches
      ratio * wheel.diameter
    end

    Wheel = Struct.new(:rim, :tire) do
      def diameter
        rim + (tire * 2)
      end
    end
  end
  ```

  이제 자신의 diameter를 계산할 수 있는 Wheel을 가지게 되었다. Gear에 이 Wheel을 주입하는 것은 물론 우리의 장기적인 디자인 목표에 전혀 부합하지 않는다. 차라리 코드 구성을 위한 실험에 가깝다. 이제 Gear클래스는 꺠끗해졌고, Wheel에 대한 판단을 미룰수 있게 되었다.

  Gear안에 Wheel을 끼워두는 것은 Wheel이 언제나 Gear와 함께 사용된다는 것을 의미한다. (하지만 현실에서는 그렇지 않다.)

### 2.4. Finally, the Real Wheel

Gear 클래스의 디자인과 씨름하는 동안 때가 다가와다. 결국, 자전거 바퀴 둘레를 계산하는 기능도 필요해졌다. 자전거에는 속도를 계산해주는 장치가 있고 그 기능을 이용하기 위해서는 자전거의 바퀴 사이즈를 알아야한다.

바퀴의 둘레는 지름 * 원주율이다. 지름을 계산할 수 있는 Wheel을 Gear안에 넣어 두었기에 둘레를 계산하는 메서드를 추가하는 것은 쉽다. 더 중요한 점은 Gear클래스와 독립된 Wheel클래스가 명시적으로 필요해졌다는 점이다.

이미 Gear클래스에서 Wheel의 행동을 구분해 놓았기 때문에 이 수정은 전혀 어렵지 않게 진행될 수 있다. Wheel Struct를 Wheel클래스로 변경하면 된다

```ruby
class Gear
  attr_reader :chainring, :cog, :wheel
  def initialize(chainring, cog, wheel=nil)
    @chainring = chainring
    @cog = cog
    @wheel = wheel
  end
  def ratio
    chainring / cog.to_f
  end

  def gear_inches
    ratio * wheel.diameter
  end
end

class Wheel
  attr_reader :rim, :tire

  def initialize(rim, tire)
    @rim = rim
    @tire = tire
  end

  def diameter
    rim + (tire * 2)
  end

  def circumference
    diameter * Math::PI
  end
end

@wheel = Wheel.new(26, 1.5)
puts @wheel.circumference
# -> 91.106186954104

puts Gear.new(52, 11, @wheel).gear_inches
# -> 137.090909090909

puts Gear.new(52, 11).ratio
# -> 4.72727272727273
```

이제 Gear와 Wheel 모두 1개의 책임만 지게되어다. 코드가 완벽하다고는 할 수 없지만, 높은 수준에 도달했다고는 할 수 있다.

## 3. Managing Dependencies

현실을 모델링하는 방법 떄무에 객체지향 프로그래밍 언어는 효율적이며 효과적이라고 말한다. 객체는 현실세계의 문제의 특성을 반영하고, 두개의 객체 사이의 상호작용은 해결법을 제공한다. 이런 상호작용은 필수적이다. 하나의 객체가 모든 것을 알고 있을 수는 없기때문에 객체끼리의 소통은 필수이다.

객체들의 상호작용을 멀리서 바라보면 하나의 패턴이 존재한다. 각 메세지는 하나의 객체에서 시작되며 특정한 행동을 유발하기 위해 존재한다. 이 모든 행동은 객체 사이에 퍼져있고, 어떤 원하는 행동을 위해 객체는 그 행동을 개인적으로 알고있거나, 상속을 받거나 그 행동을 아는 객체를 알아야한다.

2장에서는 행동을 미리 알고있는 경우에 집중을 했다면, 3장에서는 행동을 알고있는 다른 클래스를 아는 것에대해서 다룰 것이다. (상속에 대해서는 6장)

잘 디자인된 객체는 하나의 책임만을 가지고 있기 때문에 객체끼리 서로 상호작용을 할 수 밖에 없다. 서로 협업하기 위해 객체는 서로에 대한 지식을 가져야 하고 이 지식이 의존성을 만들어 낸다. 의존성을 제대로 관리하지 못한다면 어플리케이션은 엉망이 될 것이다.

### 3.1. 의존성 이해하기

만약 하나의 객체를 수정했을 때 다른 객체를 수정해햐 한다면, 후자에 해당하는 객체들은 전자에 해당하는 객체에 의존적이라고 할 수 있다.

아래에는 2장에서 다루었던 Gear클래스가 조금 변형되었다. Gear_inches메서드에서 rim과 tire를 이용하여 새로운 Wheel 인스턴스를 생성한다.

```ruby
class Gear
  attr_reader :chainring, :cog, :rim, :tire
  def initialize(chainring, cog, rim, tire)
    @chainring = chainring
    @cog = cog
    @rim = rim
    @tire = tire
  end

  def gear_inches
    ratio * Wheel.new(rim, tire).diameter
  end

  def ratio
    chainring / cog.to_f
  end
  # ...
end

class Wheel
  attr_reader :rim, :tire
  def initialize(rim, tire)
    @rim = rim
    @tire = tire
  end

  def diameter
    rim + (tire * 2)
  end
  # ...
end

Gear.new(52, 11, 26, 1.5).gear_inches
```

코드를 보고 Wheel 이 변경되었을 때 Gear도  변경되어야 하는 상황이 어떤 경우가 있을지 생각해보자. 이 코드는 생각보다 복잡함을 가지고 있다. Gear는 Wheel에 대해 적어도 4개의 의존성을 가지고 있다. Gear는 이런 의존성 없이도 잘 작동할 수 있고 이런 의존성이 있다는 것 자체가 Gear클래스를 수정하기 어렵고 연약하게 만들고 있다.

#### 3.1.1. 의존성 알아채기

객체는 다음과 같은 내용을 알고있을 때 의존성을 가진다.

- **다른 클래스의 이름** : Gear는 Wheel이라는 클래스가 존재한다고 예상한다.
- **자기 자신을 제외한 다른 객체에게 전송할 메세지 이름** : Gear는 Wheel의 인스턴스가 diameter라는 메서드를 이해할 수 있다는 것을 예상한다.
- **메세지가 필요로하는 아규먼트** : Gear는 Wheel.new가 rim과 tire를 필요로 한다는 것을 안다.
- **아규먼트들의 순서** : Gear는 Wheel.new의 첫 아규먼트로 rim을 두번째 아규먼트로 tire를 사용한다는 것은 안다.

위에서 나열한 의존성들은 Wheel을 변경했을 때 어쩔수 없이 Gear도 수정해야 하는 상황을 만든다. 의존성이 생기는 것은 어쩔수 없지만, 나열된 의존성의 대부분은 불필요한 것이다. 우리의 과제는 각 클래스가 자신이 해야하는 일을 하기 위한 **최소한의 지식만을 알고 그 외에는 아무것도 모르도록 의존성을 관리** 하는 것이다.

#### 3.1.2. 객체들 간의 결합(CBO - Coupling Between Objects)

이러한 의존성들은 Gear를 Wheel에 결합시킨다. 즉, 결합이 의존성을 만들어 낸다. Gear가 Wheel을 더 많이 알 수록 더욱 견고하게 결합한다. 두 객체가 견고하게 결합될수록 하나인것 처럼 행동한다.

Wheel을 바꾸면 Gear를 바꾸는게 필수적이라는 것을 안다. Gear를 재사용하고 싶다면, Wheel또한 따라오게 된다. Gear를 테스트하려면 Wheel도 테스트 해야한다.

![image](https://user-images.githubusercontent.com/53181778/85681361-2c59f080-b706-11ea-882d-45bfd3607101.png)

Gear는 A,B,C,D,Wheel에 의존하고 있으로 Gear는 다섯개의 객체와 결합하고 있다. Gear를 다른 곳에서 사용하려고 하기 전, 또는 Gear가 의존하고 있는 클래스를 수정하기 전까지 무엇이 문제인지 파악하기 어렵다. Gear는 전혀 독립적이지 않다. 의존성은 다른 객체가 한 객체 내부에 깊이 관여하고 있는 부분이다. 의존성이 높은 객체들은 마치 하나인듯 행동하며 이들은 발맞추어 움직인다.(톱니바퀴와 같다고 생각하면 될듯)

둘 이상의 객체가 강력하게 결합되어 있다면 이들 중 하나만 재사용하는 것은 불가능하다. 하나를 바꾸려면 다른 것도 바꾸어야 한다. 미처 확인하지 못한 제대로 관리하지 않은 의존성들이 남아 있다면 어플리케이션 자체가 엉망진창이 될 것이다.

#### 3.1.3. 다른 의존성들

위에서 살펴본 4가지 의존성을 컴토하고 이들로 인해 생겨나는 문제를 해결하기 위한 기술을 다루기 전에 다른 장에서 다루게 될 몇몇 일반적인 의존성 이슈를 다루고 넘어가겠다.

먼저 하나의 객체가 다른 객체에 대해 알고있고, 이 다른 객체가 또 다른 무언가를 알고 있는 또 다른 객체에 대해 알고 있는 경우( 0 - 0 - 0 - 0 이런식으로 체인처럼 연결된 경우) 멀리 있는 객체이 행동을 실행시키려 할 때 가장 심각한 피해를 야기하게 된다. 이 의존성은 기본적으로 **자기 자신을 제외한 다른 객체에게 전송할 메세지의 이름을 아는 의존성**이다. 단지 확장된 형태일 뿐이며, 메세지 연쇄(메세지 체이닝)은 원래 있던 두 객체 사이의 의존성뿐 아니라, 중간에 거쳐간 모든 객체와 메세지들 사이에도 의존성을 만들어 낸다. 만약에 중간의 하나의 어떤 객체가 변하게 되면 이 변화는 첫 번쨰 객체에 까지 영향을 미치기 때문에 첫 번째 객체에 수정을 강제할 가능성이 무척 높다. 이런 경우를 Law of Demeter가 위반되었다고 말한다. 자세한 내용은 4장에서 다루도록 하겠다.

의존성의 또 다른 영역은 테스트가 코드에 대해 가지는 의존성이다. 코드보다 테스트를 먼저 작성하는 사람들이 있다. 테스트가 디자인을 이끌어 낸다. 하지만 테스트는 코드를 참조하고 그런 의미에서 코드에 의존적이다. 테스트를 처음 접하는 프로그래머들은 종종 코드와 지나치게 결합된 테스트를 작성하는 경향이 있다. 이 강한 결합은 결국 엄청난 좌절감을 낳곤한다. 코드의 핵심적인 내용은 전혀 바뀌지 않았는 데도 불구하고 리팩토링 때마다 테스트가 깨져나간다. 테스트를 유지하는 비용이 테스트를 통해 얻는 가치보다 더 높아지기 시작한다. 테스트-코드 사이의 지나친 결합은 코드-코드 사이의 지나친 결합과 동일한 결과를 낳는다. 이 결합은 코드의 수정이 뒤이어 테스트의 수정을 강제하는 의존성이다. 테스트 디자인에 대해서는 9장에서 다루도록 하겠다.

### 3.2. 약하게 결합된 코드 작성하기

의존성은 클래스 그리고 클래스가 건드리는 것을 붙여버리는 본드와 같다. 약간의 본드는 필요하지만 너무 많은 본드는 좋지않다. 의존성을 줄이는 작업은 곧 불필요한 본드가 무엇인지 알고 제거하는 과정이다.

#### 3.2.1. 의존성 주입하기

클래스의 이름을 통해 다른 클래스를 참조하는 방식은 상당히 끈끈한 spot을 만든다. 지금까지 작성했던 Gear클래스에서 gear_inches 메서드는 Wheel 클래스를 명시적으로 참조하고 있다.

```ruby
class Gear
  attr_reader :chainring, :cog, :rim, :tire
  def initialize(chainring, cog, rim, tire)
    @chainring = chainring
    @cog = cog
    @rim = rim
    @tire = tire
  end

  def gear_inches
    ratio * Wheel.new(rim, tire).diameter
  end
  # ...
end

Gear.new(52, 11, 26, 1.5).gear_inches
```

Wheel클래스의 이름을 직접 참조할 때 가장 눈에 띄는 부분은 Wheel 클래스의 이름을 변경하면 gear_inches의 메서드도 함꼐 변해야 한다는 점이다. 사실 Wheel클래스의 이름을 변경하는 것은 큰 문제를 만들어내지 않는다. 진짜 문제는 잘 드러나지 않고 더 큰 문제를 야기하는 곳에 숨겨져있다.

Gear가 Wheel을 참조하는 부분을 저 쪽에 있는 gear_inches 메서드 속에 하드코딩해 놓았을 때 Gear는 Wheel 인스턴스의 기어의 인치만을 계산하겠다고 명시적으로 보여주고 있는 것이다. Gear는 다른 종류의 객체와 협업하기를 거부하고 있다.

자전거 디스크나 실린더 같은 객체를 다루게 되었을 경우, 실린더와 디스크 객체를 사용하는 기어의 기어인치를 알아야한다. 하지만 우리는 기어 인치를 계산할 수 없다.디스크와 실린더는 지름을 가지고 있지만, Gear는 Wheel에 찰싹 붙어 있기 때문에 기어인치를 계산할 수 없다.

위 코드는 고정된 타입에 불필요하게 들러 붙어 있는 클래스에 얼마나 문제가 많은지 보여준다. 중요한 것은 '객체의 클래스가 무엇인지'가 아니라, '우리가 전송하는 메세지가 무엇인지'이다. 즉, 기어에게는 diameter메서드에 반응 할 수 있는 객체가 필요한 것이다. Gear는 대상이 되는 객체의 클래스가 무엇인지는 관심도 없고 알 필요도 ㅇ벗다. Gear_inches를 계산하기 위해 Gear가 Wheel의 존재를 알 필요는 없다. 더욱더 Wheel이 초기화되기 위해 rim과 tire가 필요하다는 것을 알 필요가 없다. Gear에게는 diameter를 알고 있는 객체만 있으면 된다.

Gear의 쓸모 없는 의존성으로 재사용성이 떨어지고 수정해야할 일이 많이 생긴다. 아래 코드는 Gear 클래스를 diameter에 반응할 수 있는 객체만 가지고도 초기화 할 수 있다.

```ruby
class Gear
  attr_reader :chainring, :cog, :wheel
  def initialize(chainring, cog, wheel)
    @chainring = chainring
    @cog = cog
    @wheel = wheel
  end

  def gear_inches
    ratio * wheel.diameter
  end
  # ...
end

# Gear expects a ‘Duck’ that knows ‘diameter’
Gear.new(52, 11, Wheel.new(26, 1.5)).gear_inches
```

Gear는 @wheel 변수를 사용하여 wheel 메서드로 변수에 접근한다. 하지만 Gear가 알고있는 것은 자기 자신이 diameter메서드에 반응할 줄 아는 객체를 가지고 있다는 것 뿐이다.(Wheel의 인스턴스인지는 관심 없음)

아주 작은 변화처럼 보이지만, Wheel의 인스턴스를 Gear 클래스 밖에서 생성하기 때문에 Gear와 Wheel 사이의 결합이 없어졌다. 이제 Gears는 diameter를 구현하고 있는 어떤 객체와도 협업할 수 있게 되었다.

이 기술을 **의존성 주입**(dependency injection)이라고 부른다. 엄청 대단한 기술로 알려져 있지만 사실 이렇게 단순하다. Gear는 Wheel클래스, Wheel을 초기화할 때 넘겨줘야 하는 인자와 인자의 순서에 대해 명시적으로 의존하고 있었지만 의존성 중비을 통해 이 모든 의존성이 diameter 메서드에 대한 단 하나의 의존성으로 줄어 들었다. 아는 것을 줄임으로 더 똑똑한 코드를 만든 것이다.

종속성 주입을 사용하여 코드를 형상화하는 것은 클래스의 이름을 알고 있는 책임과 해당 클래스에 보낼 메시지의 이름을 아는 책임이 서로 다른 객체에 속할 수 있다는 것을 인식하는 능력으로 부터 나온다. Gear가 어딘가로 diameter메세지를 전송해야 한다고해서 Gear가 Wheel에 대해서 알필요 가 없는 것처럼 말이다.

그렇다면 실제 Wheel 클래스에 대해 알아야 할 책임은 누구에게 있을까? 이 부분에 대해서는 나중에 다루도록 하겠다. 일단은 Gear가 그것을 몰라도 된다는 것이 중요하다.

#### 3.2.2. 의존성 격리시키기

불필요한 의존성을 모두 제거하면 가장 좋겠지만 현실적으로 어려운 문제이다.  이미 작동 중인 어플리케이션을 가지고 작업할 때 실제로 수정할 수 있는 부분은 매우 제한적이다. 완벽함을 추구할 수 없다면 우리의 목표는 전반적인 상태를 발전시키는 것에 만족해야 한다.

그렇기 때문에 불필요한 의존성을 제거할 수 없는 경우라면 의존성을 클래스 안에서 격리시켜 놓아야 한다. 불필요한 의존성이 어디에 있는지 쉽게 찾고 줄일 수 있도록 의존성을 고립시키는 방법을 알아보자.

- 인스턴스 생성을 격리시키기

  만약 제약조건이 너무 낳아서 Gear에 Wheel을 주입할 수 없다면 새로운 Wheel 인스턴스를 만드는 과정을 Gear클래스 내부에 격리시켜 놓을 필요가 있다. 이는 의존성을 명시적으로 노출하는 작업인 동시에 Wheel이 Gear클래스 내부에 스며드는 것을 막는다.

  두 개의 예시를 통해 접근법을 살펴보자.

  첫 예시는 새로운 Wheel 인스턴스를 생성하는 과정을 Gear의 gear_inches 메서드에서 initialize 메서드 속으로 옮겼다. gear_inches 메서드는 조금더 깔끔해졌고, wheel에 대한 의존성을 더욱 뚜렷하게 드러낼 수 있게 되었다.이런 접근은 Gear가 새로운 인스턴스를 만들때마다 무조건 새로운 Wheel 인스턴스를 생성한다는 사실에 주의해야한다.

  ```ruby
  class Gear
    attr_reader :chainring, :cog, :rim, :tire
    def initialize(chainring, cog, rim, tire)
      @chainring = chainring
      @cog = cog
      @wheel = Wheel.new(rim, tire)
    end

    def gear_inches
      ratio * wheel.diameter
    end
    # ...
  ```

  다른 방법은 명시적으로 정의된 wheel 메서드를 통해 새로운 Wheel 인스턴스를 만드는 방법이다. 이는 루비의 `||=` 연산자를 이용해서 객체가 필요한 순간에 왔을 때, Wheel인스턴스를 만든다. 이런 경우 gear_inches 가 Wheel 메서드를 호출하기 전까지 Wheel의 인스턴스가 만들어 지지않는다.

  ```ruby
  class Gear
    attr_reader :chainring, :cog, :rim, :tire
    def initialize(chainring, cog, rim, tire)
      @chainring = chainring
      @cog = cog
      @rim = rim
      @tire = tire
    end

    def gear_inches
      ratio * wheel.diameter
    end

    def wheel
      @wheel ||= Wheel.new(rim, tire)
    end
    # ...
  ```

  위 두 예시에서도 Gear는 너무 많은 거을 알고 이다. 여전히 rim과 tire를 초기화 인자로 전달해줄 수 있어야 하고 Gear내부에서 Wheel인스턴스를 생성해야한다. 또한, Wheel과 너무 밀접하게 연관되어서 Wheel을 제외한 인스턴스를 가지고는 gear_inch를 구할 수 없다.

  그럼에도 어느정도의 발전은 있다. Gear_inches가 가지고 있던 몇몇 의존성을 줄였으며 Gear가 Wheel에 의존하고 있다는 사실을 뚜렷하게 보여줄 수 있다. 의존성을 오히려 잘 보이게 함으로 재사용의 장벽을 낮추고 리팩토링을 더 쉽게 할 수 있게 만들어 주었다.

  외부 클래스 이름에 대한 으존성을 이렇게 관리하게 되면 의존성을 고려하면서 설계를 하기 때문에 클래스는 자연스럽게 덜 결합된 형태를 띈다.

- 취약한 외부 메세지 격리시키키

  **외부 클래스 이름을 참조**하는 지점을 격리시켰으니, **외부로 전송되는 메세지에 대한 의존성**에 대해 살펴보자. 즉, 나 자신이 아닌 외부의 어떤 객체에 보내는 메세지를 살펴보자. 예를 들어, gear_inches는 ratio와 wheel 메세지를 자기 자신에게 보내고 있지만 diameter 메세지는 wheel에게 보내고 있다.

  ```ruby
  def gear_inches
    ratio * wheel.diameter
  end
  ```

  간다한 코드이기에 별 문제가 없어 보이지만, 더 복잡한 코드로 변경시켜야할 경우 문제가 될 수 있다. 아래 예시를 보자

  ```ruby
  def gear_inches
    #... a few lines of scary math
    foo = some_intermediate_result * wheel.diameter
    #... more lines of scary math
  end
  ```

  Wheel.diameter는 엄청난 수학공식들 사이에 숨겨져있다. 되면 gear_inches가 wheel 메서드에 반응한다는 사실에 의존하고 이 wheel이 diameter메서드에 반응한다는 사실에도 의존한다. Gear_inches메서드 속에 외부에 대한 의존성을 심어 놓는 것은 불필요한 일이고 코드를 취약하게 만든다.

  외부 의존성을 걷어내고 의존성을 클래스 내부의 메서드 속에 캡슐화시켜 놓으면 gear_inches 메서드를 수정해야 하는 상황도 줄일 수 있다.

  ```ruby
  def gear_inches
    #... a few lines of scary math
    foo = some_intermediate_result * diameter
    #... more lines of scary math
  end

  def diameter
    wheel.diameter
  end
  ```

  만약 이전에 diameter를 Gear클래스 내부의 이곳저곳에서 사용해야 했다면 아마 DRY를 유지하기 위해 처음부터 diameter 메서드를 만들었을 것이다. 여기서 차이점은 타이밍이다.

  원래 코드에서 gear_inches는 wheel이 diameter를 가지고 있다는 사실을 알고 있었다. 이 지식은 gear_inches를 외부의 객체에 그리고 이 외부 객체의 메서드들에 결합시켜 버리는 위험한 의존성이다 수정 이후 gear_inches는 조금 더 추상화 되었다. Gear는 wheel.diameter를 별도의 메서드에 분리하여 gear_inches가 자기자신에게 전송하는 메세지에 의존할 수 있게 했다.

  Wheel에서 diameter 메서드의 이름을 바꾸더라도 Gear에 미치는 영향은 diameter메서드(Wrapping method)에 한정될 것 이다. 클래스가 그 내부에서 변하기 쉬운 메세지를 참조하고 있을 때 이 기술을 유용하게 사용할 수 있다.

  이런 문제를 제거하는 또 다른 방법은 의존성이 시작되는 지점으로 돌아가서 의존성의 방향을 반대로 돌려버리는 것이다. 이렇게 함으로 문제 자체를 회피하는 방법이 있다. 이 방법에 대해 설명하기 전에 먼저 짚고가야할 코딩 스킬이 하나있다.

#### 3.2.3. 인자 순서에 대한 의존성 제거하기

필요한 인자를 전달할 때, 보내는 입장에서 인자에 대한 지식을 아는 것을 피할 수 없다. 이 의존성은 피할 수 없는 것이다. 하지만, 인자를 전달하는 것은 종종 감지하기 어려운 두 번째 의존성을 발생시킨다. 많은 메서드 시그니처는 인자를 필요로할 뿐만 아니라, 특정한 순서를 지키길 기대한다.

아래 예시에서 Gear의 initialize 메서드는 세개의 인자를 넘겨받는다. 파라미터가 기본값을 제공하지 않기 때문에 모든 인자를 넘겨주어야 하고, 반드시 순서대로 전달해야 한다.

```ruby
class Gear
  attr_reader :chainring, :cog, :wheel
  def initialize(chainring, cog, wheel)
    @chainring = chainring
    @cog = cog
    @wheel = wheel
  end
  ...
  end

Gear.new(
  52,
  11,
  Wheel.new(26, 1.5)).gear_inches
```

new 메서드를 전송하는 송신자는 Gear의 초기화 메서드에서 정의된 인자의 순서에 의존적이다. 불행하게 인자를 손봐야 하는일은 자주 발생한다. 하지만 인자를 손보는 일은 해당 메서드에 의존적인 객체들을 수정해야 하는 것을 의미한다. 더욱 곤란한 것은 우리가 인자들을 변경하지 않으려 할 수도 있다는 점이다. 디자인 관점에서는 인자를 변경해야 겠지만 모든 의존성을 또 다시 변경하고 싶지 않기 때문이다.

- 초기화 인자로 해시 사용하기

  고정된 인자에 대한 의존을 피하는 가장 간단한 방법으로 해시를 사용할 수 있다. 순서가 고정된 인자대신 옵션을 해시로 만들어서 넘기는 것이 좋다.

  다음은 예시이다.

  ```ruby
  class Gear
    attr_reader :chainring, :cog, :wheel
    def initialize(args)
      @chainring = args[:chainring]
      @cog = args[:cog]
      @wheel = args[:wheel]
    end
    ...
    end

  Gear.new(
    :chainring => 52,
    :cog => 11,
    :wheel => Wheel.new(26, 1.5)).gear_inches
  ```

  이 방법의 가장 뚜렷한 장점은 인자의 순서성을 제거했다는 것이다. 코드가 장황해지긴 했지만, 그 효과에 비하면 별거 아닌 문제점이다.

  인자의 순서의 의존성을 없애는 대신에 해시 키에대한 의존성이 생겼다. 키에 대한 의존성은 기존의 의존성 보다 훨씬 안정적인 의존성이기 때문에 문제가 되지 않는다. 또한, 인자들에 대한 문서의 역할도 해주게 된다.

  하지만, 별거 아닌 기능을 만드는데 해시를 쓴다면 조금 부담스러울 수도 있다. 그리고 고정된 인자에 더해 추가적으로 해시를 이용하여 사용하기도한다.

- 기본값을 정의하기

  인자에 기본값을 추가하는 방법은 여러가지가 있다. boolean이 아닌 간단한 기본값은 루비의 `||`메서드를 이용해 추가할 수 있다.

  ```ruby
  # specifying defaults using ||
  def initialize(args)
    @chainring = args[:chainring] || 40
    @cog = args[:cog] || 18
    @wheel = args[:wheel]
  end
  ```

  일반 적인 방법이지만, 주의해야할 점이 있다. ||를 사용하는 것은 hash에 등록되지 않은 키에 대한 요청을 하게되면 nil을 반환하는 특성에 의존하고 있다. 해시 인자가 :boolean_thing이라는 키를 가지고 있고 이 키의 기본값을 true로 설정하고 싶은 경우가 있을 수 있다. 이런 경우에도 ||를 사용하면 :boolean_thing의 키의 값을 false나 nil로 설정할 수 없게 된다.

  예를 들어 아래의 경우는 :boolean_thing키가 정의되지 않을 경우 뿐만 아니라, nil이나 false의 값을 가지고 있을 경우에도 @bool의 값을 true로 만든다.

  ```ruby
  @bool = args[:boolean_thing] || true
  ```

  ||의 특성 때문에 불린 값을 인자로 받고 싶거나 false와 nil을 구부해야 하는 경우에 fetch메서드를 사용하는 것이 좋다. fetch메서드는 우리가 사용하는 키가 해시에 정의되어 있기를  기대하며 키가 없는 경우에 별도의 처리방식을 제공한다. fetch는 우리가 찾는 키가 없을 때 자동으로 **nil을 반환하지 않는다는 장점**이 있다.

  아래 예시에서 fetch를 사용한 기본값을 정의하였다. 이렇게 하면 키가 존재하고 값이 false나 nil일 경우에 그대로 사용할 수 있다.

  ```ruby
  # specifying defaults using fetch
  def initialize(args)
    @chainring = args.fetch(:chainring, 40)
    @cog = args.fetch(:cog, 18)
    @wheel = args[:wheel]
  end
  ```

  initialize메서드 속에 기본값을 설정하는 코드를 완전히 제거하고 별도의 Warpping method에서 기본값을 설정하는 방법도 있다. 아래 코드의 default 메서드는 초기화 과정에서 args 인수에 **merge** 될 기본 해시를 정의하고 있다. 이렇게 사용하면 fetch와 동일한 효과를 얻을 수 있다. 즉, args 해시에 키값이 없는 경우에만 기본 해시의 값이 사용된다.

  ```ruby
  # specifying defaults by merging a defaults hash
  def initialize(args)
    args = defaults.merge(args)
    @chainring = args[:chainring]
    # ...
  end

  def defaults
    {:chainring => 40, :cog => 18}
  end
  ```

  별도의 메서드를 사용하는 방법은 앞의 경우에도 잘 적용할 수 있지만 기본값이 훨씬 복잡한 경우에 특히 좋다. 기본 값이 단순한 스트링이나 숫자가 아닌고 어떠한 연산의 결과라면 defaults내부에서 구현하면 된다.

- 멀티파라미터 초기화를 격리시키기

  메서드를 수정하지 못하는 경우도 존재한다. 예를 들면 외부 프레임워크의 경우이다. 만약 기어를 외부 프레임 워크의 한 부분으로 생각한다면, initialize 메서드는 순서가 고정된 인자들을 필요로 할 것이다.  하지만 Gear이느턴스를 생성하는 지점을 하나의 메서드로 감싸서 코드를 DRY하게 만들 수 있다. 우리가 만드는 어플리케이션은 우리가 작성한 코드에 의존해야 한다.

  이 의존성을 해결하기 위해 GearWapper 모듈을 만들어 보자. 모듈을 이용함으로 외부 인터페이스에 대한 모든 지식을 한 곳에 집중시킬 수 있을 뿐만 아니라 어플리케이션이 사용할 수 있는 조금 더 좋은 인터페이스를 제공하게 된다.

  ```ruby
  # When Gear is part of an external interface
  module SomeFramework
    class Gear
      attr_reader :chainring, :cog, :wheel
      def initialize(chainring, cog, wheel)
        @chainring = chainring
        @cog = cog
        @wheel = wheel
      end
      # ...
    end
  end

  # wrap the interface to protect yourself from changes
  module GearWrapper
    def self.gear(args)
      SomeFramework::Gear.new(args[:chainring],
        args[:cog],
        args[:wheel])
    end
  end

  GearWrapper.gear(
    :chainring => 52,
    :cog => 11,
    :wheel => Wheel.new(26, 1.5)).gear_inches
  ```

  SomeFramework라는 외부 프레임워크에 Gear라는 클래스는 고정된 인자를 가지고 있다.  GearWrapper는 옵션 해시를 이용하여 새로운 Gear인스턴스를 생성한다.

  두 가지 기억해야할 점이 있다. GearWrapper는 클래스가 아닌 모듈이라는 점이다. 모듈을 이용함으로 우리는 GearWrapper 이느턴스를 만들지 않고도 gear메시지를 전송하는 명시적이고 독립적인 객체를 얻었다. 아마 클래스에 특정 모듈을 include하는 것과  혼동 될 수 있겠지만, GearWrapper는 특정 클래스를 인클루드 하기 위한 것이 아니라, gear메세지에 인스턴스 생성없이 직접 반응하기 위한 것이다.

  또 다른 점은 오로지 클래스의 인스턴스를 생성하기 위해서만 GearWrapper가 존재한다는 점이다. 객체지향에서 이런 객체를 `팩토리(Factory)`라고 부른다. 팩토리는 다른 객체를 만들기 위해 존재하는 객체이다.

  지금까지 고정된 인자들을 옵션 해시로 대체하는 기술에 대해 학습했다. 외부에 대한 의존성이 코드 속으로 스며들게 내버려 두지 말자. 애플리케이션이 직접 통제할 수 있는 래퍼 메서드를 만들어 어플리케이션을 보호하자.

  ### 3.3. 의존성 방향 관리하기

  모든 의존성은 방향이 있다. 의존성의 방향을 반대로 돌려 의존성을 관리하는 방법이 있다는 것을 앞에서 살짝 언급하여였다. 그에 대해서 조금더 심도있게 다루어보자.

  #### 3.3.1. 의존성 뒤짚기

  지금까지 사용했던 모든 예시에서 Gear는 Wheel이나 diameter에 의존했다. 하지만 이 의존성을 반대로 설정할 수도 있다. Wheel이 Gear나 ratio에 의존할 수 도 있었다. 아래 코드는 이런 뒤바뀐 의존성의 한 예를 보여준다.

  ```ruby
  class Gear
    attr_reader :chainring, :cog
    def initialize(chainring, cog)
      @chainring = chainring
      @cog = cog
    end

    def gear_inches(diameter)
      ratio * diameter
    end

    def ratio
      chainring / cog.to_f
    end
    # ...
  end

  class Wheel
    attr_reader :rim, :tire, :gear
    def initialize(rim, tire, chainring, cog)
      @rim = rim
      @tire = tire
      @gear = Gear.new(chainring, cog)
    end

    def diameter
      rim + (tire * 2)
    end

    def gear_inches
      gear.gear_inches(diameter)
    end
    # ...
  end

  Wheel.new(26, 1.5, 52, 11).gear_inches
  ```

  Wheel이 Gear인스턴스에 의존하는 것을 확인 할 수 있다. 의존성의 방향이 바뀌어도 별 문제가 없어보인다 방향성이 바뀌었다고 결과가 달라지지도 않았다. 방향성은 코드가 수정될 일이 없다면 크게 중요한 문제는 아니다.

  하지만, 방향성을 설정하는 것은 추후에 있을 변화에 대해 지대한 영향을 미친다.

#### 3.3.2. 의존성 방향을 선택하기

클래스가 사람이라고 해보자. 크래스에게 어떻게 행동해야하는지 조언해야 한다면, 스스로 보다 더 조금 변하는 것들에 의존하라고 말할 수 있다. 이 간단한 문장은 코드에 대한 단순한 사실 세가지를 기반으로 조금더 다듬을 수 있다.

- 어떤 클래스는 다른 클래스에 비해 요구사항이 자주 바뀐다.
- 콘크리트 클래스는 추상 클래스보다 수정해야 하는 경우가 빈번히 발생한다.
- 의존성이 높은 클래스를 변경하는 것은 코드의 여러 곳에 영향을 미친다.

이 세가지는 종종 겹치기도 하고 독립적이기도 하며, 그 의미가 뚜렷하다.

- 변경 가능성 이해하기

  어떤 클래스가 다른 클래스보다 변결될 가능성이 높다는 인식은, 우리가 작성한 코드 이외에도 우리가 작성하지는 않았지만 사용하는 코드에도 적용된다. 루비의 베이스 클래스나 또는 다른 프레임워크 코드도 변경이 될 가능성이 있다.

  우리가 작성하는 코드보다 루비의 베이스 클래스가 잘 바뀌지 않는다는 것은 정말 다행이다. 루비의 베이스 클래스는 사실 크게 변할 일이 없기 때문에 많이 고려하지 않아도된다.

  하지만 다른 프레임워크는 다른 상황이다. 프레임워크의 코드는 안정적이긴 하지만 그렇지 않은 경우도 존재한다.

  변경 가능성을 아는 방법은 어플리케이션에서 사용하는 모든 클래스를 다른 클래스와 비교하여 얼마나 변경되지 않았는지를 기준으로 순위를 매겨볼 수 있다. 이 순위는 의존성의 방향을 결정하는데 핵심적이다.

- 구체적인것과 추상적인것 인식하기

  두 번째는 코드의 구체성과 추상성을 이해하는데서 출발한다. 여기서 추상이라는 개념은 "모든 구체적인 것으로부터 분리된"이라는 뜻으로  사용된다. 그리고 이 개념은 코드에 대한 루비의 기본적인 태도, 특정한 기술적 제약이나 스타일에 반대하는 입장에 잘 어울린디.

  Gear가 Wheel, Wheel.new 등에 의존적일 때 Gear는 매우 구체적인 코드에 의존하고 있는 것이다. 반대로, Wheel을 Gear에 주입하는 방식의 코드는 Gear는 훨씬 추상적인 것에 의존하는 것이다.

  > 만약 정적 타입 언어에서 이와 같은 기능을 구현하려면 어떻게 해야할까? 정적 언어는 마치 타입에 대한 단위 테스트 처럼 작동하는 컴파일러를 가지고 있기 때문에 Gear에 우리가 내키는 대로 아무 객체나 주입할 수 없다. 인터페이스를 먼저 작성하고 diameter를 인터페이스의 일부로 정의하고 이 인터페이스를 Wheel 클래스에 포함시키고 gear에게 우리가 지금 주입하는 클래스가 이런 인터페이스의 한 종류라고 알려줘야 할 것이다.
  >
  > 루비 사용자들은 이런 반복잡업을 하지 않아도 된다. 하지만 변경 사항을 명시적으로 표시하도록 강제하는 언어가 지니는 이점도 있다. 이런 언어들은 우리가 추상적인 인터페이스를 만들고 있다는 사실을 명시적으로 드러내준다. 실수로 또는 의도치 않게 추상화된 코드를 만드는 것은 불가능하다. 정적 언어에서는 언제나 명확인 의도를 가지고 인터페이스를 정의한다.
  >
  > 루비의 경우, Gear에 Wheel을 주입하고 Gear가 diameter라는 메서드에 반응하는 오리타입에 의존하도록 했을 때 우리는 별 생각없이 인터페이스를 정의한 것이다. 어떤 종류의 것들은 지름을 가지고 있다는 생각을 추상화한 것이 이 인터페이스 이다. 이 추상화는 구체 클래스들로부터 추출되었고, 구체적인것들로 부터 분리되었다.

  추상화의 훌륭한 점은 일반적이고 안정적인 성질을 지닌다는 점이다. 추상화된 인터페이스는 인터페이스가 기반하고 있던 구체 클래스보다 변경될 일이 훨씬 적다. 앞으로 이어질 내용에서 클래스라는 표현은 일반적인 클래스 뿐만아니라 이런 인터페이스 역시 지칭한다. 이런 인터페이스도 의존성을 가지고 있기 때문에 디자인을 할 떄 고려를 해야한다.

- 의존성높은 클래스 피하기

  마지막은 의존성이 높은 클래스를 만들면 그 대가를 반드시 치뤄야한다는 것이다. 의존성이 높은 클래스를 수정할 떄 감내해야 하는 부정적인 효과는 매우 자명하다. 의존성이 높은 클래스가 갖는 효과에 대해서는 좀더 설명이 필요하다. 작은 수정으로 전체를 수정해야 한다면 아무도 수정하고 싶지 않을 것이다. 즉, 평생 어플리케이션에서 이 문제를 안고 가야한다.

- 문제가 되는 의존성 찾아내기

  지금까지 검토했던 내용을 어플리케이션의 모든 코드 속에서 종합적으로 검토해보자. 언제 변화에 봉착하게 될지, 어느 정도로 추상화되어 있는지, 의존성이 몇 군데 있는지를 검토한다.

  중요한 디자인 결정을 내려야 하는 순간은 **수정을 해야 할수도 있는 가능성이** **여러 의존성**과 만나는 지점에서 발생한다. 이 둘의 조합은 어플리케이션의 도움이 될수도 치명적일 수도있다.

  ![image](https://user-images.githubusercontent.com/53181778/85717426-79e75500-b728-11ea-9df8-1893d5e54937.png)

그림의 가로축은 **요구사항의 변경이 발생할 가능성**, 세로축은 **클래스에 의존하고 있는 객체의 수**를 반영한다. 어플리케이션의 모든 클래스를 각각 A,B,C,D 영역과 매칭 시킬 수 있을 것이다.

변경이 발생할 가능성이 낮지만 이 클래스에 의존하고 있는 객체가 많은 클래스는 A영역에 속한다. 이 영역에는 추상클래스나 인터페이스가 속한다. 충분히 잘 디자인된 어플리케이션에서는 의존성이 추상화 된것 근처에 몰려있을 수 밖에 없다. 추상화 된것은 변경가능성이 낮기 떄문이다.

하지만, 클래스가 A영역에 속하기 때문에 추상화된 것이 아니라는 것은 확실히 해야한다. (추상화되고 잘 설계된 경우에 A에 속하는 것임, A에 속한다고 추상화 됐다고는 할 수없다.) A영역에 있는 클래스가 추상화가 되지 않았다면, 추상화 될 필요가 있다.

B영역을 보기전에 C영역을 보자 C영역은 A영역과 정반대다. C영역은 변경될 가능성은 높지만 클래스에 딸린 객체가 적은 클래스들로 채워져있다. 이곳의 클래스들은 보다 구체적인 경향이 있어 변경될 가능성이 높지만, 의존적인 클래스가 적기 때문에 큰 문제가 되지 않는다.

B역영의 클래스들은 디자인의 관점에서 보면 가장 중요성이 낮다. 어떤 변화에 대해 가장 적은 영향을 받는 클래스들이기 때문이다.

A, B, C 영역에 있는 클래스들은 큰 문제가 없다. 문제는 D영역이다. D영역은 위험영역이라는 이름이 어울린다. D영역의 클래스들은 어플리케이션의 건강상태를 드러내는 지표이다.

`자기 자신보다 덜 변하는 것들에 의존하라`라는 것이 좋은 디자인의 핵심이다.

