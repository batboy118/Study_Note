# PRACTICAL OBJECT-ORIENTED DESIGN IN RUBY

>PRACTICAL OBJECT-ORIENTED DESIGN IN RUBY 책을 읽고 내용을 정리합니다.
>
>참고로, 번역본도 있지만 원서를 추천합니다. 오역된 부분이 많고 오타도 많이 보이네요.

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./README.md)

---

<!-- TOC -->

- [1. Object-Oriented Design](#1-object-oriented-design)
	- [1.1. 객체 지향 디자인의 원칙과 디자인 패턴](#11-객체-지향-디자인의-원칙과-디자인-패턴)
	- [1.2. 객체 지향 언어](#12-객체-지향-언어)
- [2. Designing Classes with a Single Responsibility](#2-designing-classes-with-a-single-responsibility)
	- [2.1. 클래스에 무엇이 포함될지 정하기](#21-클래스에-무엇이-포함될지-정하기)
		- [2.1.1. 클래스에 Method를 그룹핑하기](#211-클래스에-method를-그룹핑하기)
		- [2.1.2. 쉽게 수정가능한 코드를 구성하기](#212-쉽게-수정가능한-코드를-구성하기)
	- [2.2. 하나의 책임을 지는 클래스 만들기](#22-하나의-책임을-지는-클래스-만들기)
		- [2.2.1. 자전거와 기어](#221-자전거와-기어)
		- [2.2.2. 왜 단일 책임이 중요한가?](#222-왜-단일-책임이-중요한가)
		- [2.2.3. 클래스가 단일 책임을 가지는지 판단하기](#223-클래스가-단일-책임을-가지는지-판단하기)
		- [2.2.4. 언제 디자인을 만들지 판단하기](#224-언제-디자인을-만들지-판단하기)
	- [2.3. Writing Code That Embraces Change](#23-writing-code-that-embraces-change)
		- [2.3.1. 데이터가 아닌 행동에 의존하기](#231-데이터가-아닌-행동에-의존하기)
		- [2.3.2. 모든 곳에 단일 책임 원칙 강제하기](#232-모든-곳에-단일-책임-원칙-강제하기)
	- [2.4. Finally, the Real Wheel](#24-finally-the-real-wheel)
- [3. Managing Dependencies](#3-managing-dependencies)
	- [3.1. 의존성 이해하기](#31-의존성-이해하기)
		- [3.1.1. 의존성 알아채기](#311-의존성-알아채기)
		- [3.1.2. 객체들 간의 결합(CBO - Coupling Between Objects)](#312-객체들-간의-결합cbo---coupling-between-objects)
		- [3.1.3. 다른 의존성들](#313-다른-의존성들)
	- [3.2. 약하게 결합된 코드 작성하기](#32-약하게-결합된-코드-작성하기)
		- [3.2.1. 의존성 주입하기](#321-의존성-주입하기)
		- [3.2.2. 의존성 격리시키기](#322-의존성-격리시키기)
		- [3.2.3. 인자 순서에 대한 의존성 제거하기](#323-인자-순서에-대한-의존성-제거하기)
		- [3.2.4. 의존성 방향을 선택하기](#324-의존성-방향을-선택하기)
- [4. Creating Flexible Interfaces](#4-creating-flexible-interfaces)
	- [4.1. 인터페이스 이해하기](#41-인터페이스-이해하기)
	- [4.2. 인터페이스 정의하기](#42-인터페이스-정의하기)
		- [4.2.1. 퍼블릭 인터페이스](#421-퍼블릭-인터페이스)
		- [4.2.2. 프라이빗 인터페이스](#422-프라이빗-인터페이스)
		- [4.2.3. 책임, 의존성, 인터페이스](#423-책임-의존성-인터페이스)
	- [4.3. 퍼블릭 인터페이스 찾기](#43-퍼블릭-인터페이스-찾기)
		- [4.3.1. (예시) 자전거 여행 회사](#431-예시-자전거-여행-회사)
		- [4.3.2. 의도를 구성하기](#432-의도를-구성하기)
		- [4.3.3. 시퀀스 다이어그램 사용하기](#433-시퀀스-다이어그램-사용하기)
		- [4.3.4. '어떻게' 해야하는지 알려주는 대신 '무엇을' 달라고 요구하기](#434-어떻게-해야하는지-알려주는-대신-무엇을-달라고-요구하기)
		- [4.3.5. 맥락 의존성 찾기](#435-맥락-의존성-찾기)
		- [4.3.6. 다른 객체를 믿기](#436-다른-객체를-믿기)
		- [4.3.7. 새로운 객체를 찾아내기 위해 메세지를 사용하기](#437-새로운-객체를-찾아내기-위해-메세지를-사용하기)
		- [4.3.8. 메세지 기반 어플리케이션 만들기](#438-메세지-기반-어플리케이션-만들기)
	- [4.4. 자신의 인터페이스를 드러내는 코드 작성하기](#44-자신의-인터페이스를-드러내는-코드-작성하기)
		- [4.4.1. 명시적인 인터페이스 만들기](#441-명시적인-인터페이스-만들기)
		- [4.4.2. 다른 사람의 퍼블릭 인터페이스 존중하기](#442-다른-사람의-퍼블릭-인터페이스-존중하기)
		- [4.4.3. 프라이빗 인터페이스에 의존할 때 주의하기](#443-프라이빗-인터페이스에-의존할-때-주의하기)
		- [4.4.4. 맥락 최소화 시키기](#444-맥락-최소화-시키기)
	- [4.5. 데메테르 원칙](#45-데메테르-원칙)
		- [4.5.1. 데메테르 원칙의 정의](#451-데메테르-원칙의-정의)
		- [4.5.2. 위반의 결과](#452-위반의-결과)
		- [4.5.3. 원칙 위반을 피하기](#453-원칙-위반을-피하기)
		- [4.5.4. 데메테르의 원칙 듣기](#454-데메테르의-원칙-듣기)
- [5. Reducing Costs with Duck Typing](#5-reducing-costs-with-duck-typing)
	- [5.1. 오리타입 이해하기](#51-오리타입-이해하기)
		- [5.1.1. 오리 타입 무시하기](#511-오리-타입-무시하기)
		- [5.1.2. 문제를 조합하기](#512-문제를-조합하기)
		- [5.1.3. 오리 타입 찾기](#513-오리-타입-찾기)
		- [5.1.4. 오리 타입의 중요성](#514-오리-타입의-중요성)
	- [5.2. 오리 타입에 의존하는 코드 작성하기](#52-오리-타입에-의존하는-코드-작성하기)
		- [5.2.1. 숨겨진 오리파일 인지하기](#521-숨겨진-오리파일-인지하기)
		- [5.2.2. 오리 타입 신뢰하기](#522-오리-타입-신뢰하기)
		- [5.2.3. 오리 타입 문서작성](#523-오리-타입-문서작성)
		- [5.2.4. 오리타입 사이에서 코드 공유하기](#524-오리타입-사이에서-코드-공유하기)
		- [5.2.5. 현명하게 오리타입 선택하기](#525-현명하게-오리타입-선택하기)
	- [5.3. 오리 타입의 무서움을 정복하기](#53-오리-타입의-무서움을-정복하기)
		- [5.3.1. 정적 타입으로 오리 타입 거부하기](#531-정적-타입으로-오리-타입-거부하기)
		- [5.3.2. 정적 타입 vs 동적 타입](#532-정적-타입-vs-동적-타입)
		- [5.3.3. 동적 타입 언어 받아들이기](#533-동적-타입-언어-받아들이기)
- [6. Acquiring Behavior Through Inheritance](#6-acquiring-behavior-through-inheritance)
	- [6.1. 고전적인 상속 이해하기](#61-고전적인-상속-이해하기)
	- [6.2. 상속을 사용하는 곳을 인지하기](#62-상속을-사용하는-곳을-인지하기)
		- [6.2.1. 구체적인 클래스에서 시작하기](#621-구체적인-클래스에서-시작하기)
		- [6.2.2. 여러 타입 임베딩하기](#622-여러-타입-임베딩하기)
		- [6.2.3. 숨겨진 타입 찾기](#623-숨겨진-타입-찾기)
		- [6.2.4. 상속 선택하기](#624-상속-선택하기)
		- [6.2.5. 상속 관계 그리기](#625-상속-관계-그리기)
	- [6.3. 상속의 오용](#63-상속의-오용)
	- [6.4. 추상화 찾기](#64-추상화-찾기)
		- [6.4.1. 추상화 상위 클래스 만들기](#641-추상화-상위-클래스-만들기)
		- [6.4.2. 추상적인 행동을 상위로 올리기](#642-추상적인-행동을-상위로-올리기)
		- [6.4.3. 구체적인 것에서 추상적인 것 분리하기](#643-구체적인-것에서-추상적인-것-분리하기)
		- [6.4.4. 템플릿 메서드 패턴 사용하기](#644-템플릿-메서드-패턴-사용하기)
		- [6.4.5. 모든 템플릿 메서드 구현하기](#645-모든-템플릿-메서드-구현하기)
	- [6.5. 상위클래스와 하위클래스 사이의 커플링 관리하기](#65-상위클래스와-하위클래스-사이의-커플링-관리하기)
		- [6.5.1. 커플링 이해하기](#651-커플링-이해하기)
		- [6.5.2. Hook 메세지를 사용하여 하위클래스 커플링 제거하기](#652-hook-메세지를-사용하여-하위클래스-커플링-제거하기)
- [7. Sharing Role Behavior with Modules](#7-sharing-role-behavior-with-modules)
	- [7.1. 역할 이해하기](#71-역할-이해하기)
		- [7.1.1. 역할 찾기](#711-역할-찾기)
		- [7.1.2. 책임 관리하기](#712-책임-관리하기)
		- [7.1.3. 불필요한 의존성 제거하기](#713-불필요한-의존성-제거하기)
		- [7.1.4. 구체적인 코드 작성하기](#714-구체적인-코드-작성하기)
		- [7.1.5. 추상화하기](#715-추상화하기)
		- [7.1.6. 메서드 찾아 올라가기](#716-메서드-찾아-올라가기)
	- [7.2. 상속가능한 코드 만들기](#72-상속가능한-코드-만들기)
		- [7.2.1. 안티패턴 알아채기](#721-안티패턴-알아채기)
		- [7.2.2. 추상화된 코드 사용하기](#722-추상화된-코드-사용하기)
		- [7.2.3. 약속을 존중하라](#723-약속을-존중하라)
		- [7.2.4. 템플릿 메서드 패턴 사용하기](#724-템플릿-메서드-패턴-사용하기)
		- [7.2.5. 미리 클래스 디커플링하기](#725-미리-클래스-디커플링하기)
		- [7.2.6. 상속 구조를 낮게 만들기](#726-상속-구조를-낮게-만들기)
- [8. Combining Objects with Composition](#8-combining-objects-with-composition)
	- [8.1. 자전거 부품 구성하기](#81-자전거-부품-구성하기)
		- [8.1.1. Bicycle 클래스 업데이팅](#811-bicycle-클래스-업데이팅)
		- [8.1.2. Parts의 상속 관계 만들기](#812-parts의-상속-관계-만들기)
	- [8.2. Parts 객체 조합하기](#82-parts-객체-조합하기)
		- [8.2.1. Part 만들기](#821-part-만들기)
		- [8.2.2. Parts를 보다 배열과 비슷하게 만들기](#822-parts를-보다-배열과-비슷하게-만들기)
	- [8.3. Parts 생산하기](#83-parts-생산하기)
		- [8.3.1. PartsFactory(부품 공장)만들기](#831-partsfactory부품-공장만들기)
		- [8.3.2. PartsFactory 발전시키기](#832-partsfactory-발전시키기)
	- [8.4. 조합된 Bicycle](#84-조합된-bicycle)
	- [8.5. 상속과 조합 중 하나 선택하기](#85-상속과-조합-중-하나-선택하기)
		- [8.5.1. 상속의 결과 받아들이기](#851-상속의-결과-받아들이기)
		- [8.5.2. 조합의 결과 받아들이기](#852-조합의-결과-받아들이기)
		- [8.5.3. 올바른 관계 선택하기](#853-올바른-관계-선택하기)
- [9. Designing Cost-Effective Tests](#9-designing-cost-effective-tests)
	- [9.1. 의도를 가지고 테스트하기](#91-의도를-가지고-테스트하기)
		- [9.1.1. 의도 파악](#911-의도-파악)
		- [9.1.2. 무엇을 테스트할지 알기](#912-무엇을-테스트할지-알기)
		- [9.1.3. 언제 테스트할지 알기](#913-언제-테스트할지-알기)
		- [9.1.4. 어떻게 테스트할지 알기](#914-어떻게-테스트할지-알기)
	- [9.2. 들어오는 메세지 테스트하기](#92-들어오는-메세지-테스트하기)
		- [9.2.1. 사용하지 않는 인터페이스 삭제하기](#921-사용하지-않는-인터페이스-삭제하기)
		- [9.2.2. 퍼블릭 인터페이스 검증하기](#922-퍼블릭-인터페이스-검증하기)
		- [9.2.3. 테스트 중인 객체 고립시키기](#923-테스트-중인-객체-고립시키기)
		- [9.2.4. 클래스를 사용해서 의존성 주입하기.](#924-클래스를-사용해서-의존성-주입하기)
		- [9.2.5. 역할에 대한 의존성 주입하기](#925-역할에-대한-의존성-주입하기)
	- [9.3. 프라이빗 메서드 테스트하기](#93-프라이빗-메서드-테스트하기)
		- [9.3.1. 테스트에서 프라이빗 메서드 무시하기](#931-테스트에서-프라이빗-메서드-무시하기)
		- [9.3.2. 테스트 중인 클래스에서 프라이빗 메서드 제거하기](#932-테스트-중인-클래스에서-프라이빗-메서드-제거하기)
		- [9.2.3. 프라이빗 메서드 테스트 선택하기](#923-프라이빗-메서드-테스트-선택하기)
	- [9.4. 밖으로 나가는 메세지 테스트하기](#94-밖으로-나가는-메세지-테스트하기)
		- [9.4.1. 쿼리 메세지 무시하기](#941-쿼리-메세지-무시하기)
		- [9.4.2. 커맨드 메세지 검증하기](#942-커맨드-메세지-검증하기)
	- [9.5 오리 타입 테스트하기](#95-오리-타입-테스트하기)

<!-- /TOC -->

## 1. Object-Oriented Design

세상은 절차적이다. 시간의 흐름대로 사건이 흘러간다. 또한, 세계는 객체지향적이다. 객체들의 행동은 자연스럽게 섞이기 때문에 예상치 못한 행동들의 조합이 나타날 수 있다.

절차적 프로그램은 예상치 못한 행동들의 조합을 프로그래밍하기 어려운 경우가 많다. 이를 해결하기 위해 객체지향 설계가 등장해다. 객체지향 디자인은 이미 정해진 절차들을 묶음으로 생각하지 않고, 객체가 서로 주고받는 메세지들의 연속으로 파악해야 한다. 그렇게 때문에 프로그래머는 객체들의 연관성을 잘 정의해준다면 모든 사건의 조합을 만들어낼 필요가 없다.

객체지향 설계에 실패하는 것은 관점이 제대로 확립되지 않아서이다. 객체지향적 관점을 확실히 가지게 되면 실패할 수 없다.

객체지향 어플리케이션은 상호작용하는 여러 객체로 구성되어 있고 상호작용하는 방석은 서로 메세지를 주고받는 것이다. 여기서 송신하고 수신하는 객체가 두 객체 사이의 의존성을 만들어 내고, 이러한 의존성으로 인해 객체를 수정하는 것이 어려워진다.

객체 지향 설계는 의존성 관리에 관한 것이다. 객체들이 변화를 용인할 수 있도록 의존성을 잘 관리하는 것이 객체 지향 디자인이다. 제대로된 설계가 되지 않으면 객체들이 서로에 대해 너무 많이 알기 떄문에 관리되지 않는 의존성은 큰 혼란을 초래한다.

모든 어플리케이션은 코드의 집합이고, 코드를 어떻게 배열하는 것이 바로 설계이다. 설계를 할 때 고려해야 할 것이 두가지가 있다. 먼저 현재의 기능을 충실히 구현할 수 있어야한다는 것이다. 두번째는 나중에 변경될 수 있는 것을 고려해서 코드를 작성해야 한다는 것이다.

디자인은 나중에 디자인할 수 있는 여지를 남겨 놓기 위한 것이고, 그 최종 목표는 변화의 비용을 최소화하는 것이다.

### 1.1. 객체 지향 디자인의 원칙과 디자인 패턴

`SOLID`는 마이클 플레즈가 만들고 로버트 마틴이 대중화한 객체 지향 설계의 5가지 원리이다.

1. Sngle Responsibility - 단일 책임
2. Open-Closed - 개방-폐쇄
3. Liskov Substitution - 리스코프 치환
4. Interface Segregation - 인터페이스 분리
5. Dependency Inversion - 의존성 역전

다른 디자인 원칙으로는 앤디 헌트와 데이브 토머스의 `DRY`(Don't Retape Yourself)와 노스이스트 대학교의 데메터 프로젝트의 `Law of Demeter`(LoD)가 있다. 이러한 설계 원칙들을 이 책을 통해서 다룬다.

또한, 객체지향 디자인의 원칙 외에도 디자인 패턴을 이해하는 것이 중요하다. <GoF의 디자인 패턴>은 패턴이란 객체지향 소프트웨어 디자인에서 명확한 문제를 처리하는 간단하고도 우아한 해결책이라고 말한다. 디자인 패턴은 **동일한 문제를 같은 방식으로 해결할 수 있는 방법**에 이름을 부여한 것을 말한다. 디자인 패턴은 프로그래머들이 서로 소통하고 협업할 수 있는 방법을 제공해 주었다.

디자인은 **반복적인 피드백**과 함께하는 **점진적인 발견**의 과정이다. 그리고 디자인은 지속적인 자기조절 능력을 갖추고, 자연스럽게 발전하는 것이 가장 좋다. 때문에 반복과 점진적인 발전을 중시하는 애자일 소프트웨어 개발은 잘 디자인된 애플리케이션을 만드는 데 매우 적합하다. 좋은 애플리케이션을 위해서는 **초기에 큰 디자인을 구상하지 않고 계속해서 디자인을 변경해주는 게 좋다**.

### 1.2. 객체 지향 언어

 일반적인 절차지향적인 언어와 다르게 루비와 같은 객체지향 언어는 데이터와 행동(함수)를 완전히 분리하지 않고 하나의 객체에 결합하여 넣는다. 즉, 객체는 행동과 데이터를 포함하고, 객체만이 제어할 수 있는 데이터를 포함한다. 객체는 서로 메세지를 보내면서 서로의 행동을 불러 일으킨다.

루비는 문자열 데이터 타입 대신 문자열 객체를 가지고 있다. 문자열로 작동하는 연산은 언어의 문법대신에 문자열 객체에 내장되어 있다. 각각의 문자열 객체는 고유한 개인 데이터 문자열을 포함한다는 점에서 다르지만, 모든 문자열 객체는 동일한 동작을 한다는 점에서 유사하다고 볼 수 있다.

문자열 객체가 자체적으로 알맞은 행동을 제공해 주기때문에 문자열 데이터의 타입에 대해서 특별히 신경쓸 필요가 없다. 프로그래머는 객체가 메세지를 보내는 일반적인 방법만 알면 된다.

루비와 같은 클래스 기반의 객체 지향 언어는 유사한 객체의 구성에 대한 청사진을 제공하는 클래스를 정의 할 수 있다. 클래스는 메서드와 프로퍼티를 정의한다. 메서드는 메세지에 응답하여 호출된다. 동일한 메서드 이름은 다른 오브젝트에서도 정의될 수 있다. 전송된 메세지에 대한 올바른 오브젝트의 메서드를 찾고 호출하는 것은 루비의 역할이다.

클래스는 단순한 데이터 이상의 유형을 정의한다. 물체의 유형을 알면 물체가 어떻게 행동할지 예상할 수 있다. 절차지향 언어에서 변수는 단일 데이터 타입을 가진다. 이 데이터 타입에 대한 지식은 어떤 연산이 유효한지에 대한 예상하게 한다. 루비에서는 하나의 객체는 많은 타입을 가질 수 있다. 객체의 타입을 아는 것은 객체가 응답하는 메세지의 대한 예상을 할수 있게 한다.

루비에는 미리 정의된 클래스가 많이 있다. 가장 즉시 알아차릴수 있는 클래스는, 절차지향에서 쓰이는 데이터 타입과 중복되는 것들이다. 예를들면 스트링 클래스나, 정수를 표현하기 위한 Fixnum클래스 등이 있다. 보통은 모든 데이터 타입을 위한 미리정의된 클래스가 있다.

하지만, 객체지향 언어는 그 자체로 객체를 이용하여 만들어지고 이 점이 흥미로운 부분이다. 스트링 클래스 (새로운 문자열 객체를 위한 청사진)은 그 자체로 객체이다. 즉, String 클래스 또한 Class 클래스의 인스턴스이다. 모든 스트링 객체가 데이터가 구체화된 String 클래스의 객체라면, 모든 클래스 객체(String Fixnum ..)는 구체화된 데이터를 가지는 Class클래스의 인스턴스인 것이다. String 클래스가 새로운 문자열들은 만든다면, Class 클래스는 새로운 클래스들을 만든다.

## 2. Designing Classes with a Single Responsibility

객체지향 시스템에서 기초가 되는 것은 메세지이지만, 가장 뚜렷하게 확인할 수 있는 구조는 class이다. 메시지가 디자인의 핵심이지만, 클래스가 더 뚜렷하기 때문에 이번 장에서는 클래스에 속하는 것을 정하는 방법에 대해서 집중할 것이다.

만들려는 클래수가 무엇이고, 얼마나 많으며 어떠한 행동을 포함하고 있고 다른 클래스와의 관계는 어떠한지 정하는지에 대한 질문이 있을 수 있다. 이에 대한 정답은 클래스는 단순해야 한다는 것이다.

어플레케이션을 모델링하고, 클래스를 사용해서 지금 당장 있어야 하면서 나중에 수정하기 쉽게 하는 것이 목표이다. 현재 코드가 동작하게 하는 문제는 쉽지만, 수정하기 쉽게 만드는 것은 다른 문제이다.

### 2.1. 클래스에 무엇이 포함될지 정하기

#### 2.1.1. 클래스에 Method를 그룹핑하기

루비와 같은 객체지향 언어에서 메소드들은 클래스안에 정의되어 있다. 한번 생성된 클래스는 어플리케이션에 영원히 영향을 미칠것이다. 하지만, 메소드들을 알맞게 그룹핑하는것이 중요할지라도 프로젝트의 초반에 그것을 정하는 것이란 어려운 일이다. 또한, 성공적으로 그룹핑 했다고 하더라도 어플리케이션이 변하게 되다면 또 수정해야할 일이 발생할 수 있다. 디자인이란 완벽을 추구하는 행동이 보다는 영구적 변화에 대한 예술이다.

#### 2.1.2. 쉽게 수정가능한 코드를 구성하기

수정하기 쉽다는 것은 명확하지 않기 때문에 그 의미를 정의할 필요가 있다.

> 수정하기 쉬운것의 정의

1. Changes have no unexpected side effects
2. Small changes in requirements require correspondingly small changes in code
3.  Existing code is easy to reuse
4. The easiest way to make a change is to add code that in itself is easy to change

> 수정하기 쉬운것의 기준 (TRUE)

1. **Transparent** The consequences of change should be obvious in the code that is changing and in distant code that relies upon it
2. **Reasonable** The cost of any change should be proportional to the benefits the change achieves
3. **Usable** Existing code should be usable in new and unexpected contexts
4. **Exemplary** The code itself should encourage those who change it to perpetuate these qualities

TURE를 만족하는 코드를 짜는 것의 첫 번째 단계는 각 클래스는 **단 하나의 잘 정의된 책임**을 가지는 것이다.

### 2.2. 하나의 책임을 지는 클래스 만들기

클래스는 최대한 작으면서도 유용해야한다. 즉, 클래스는 단일 책임을 가져야 한다.

#### 2.2.1. 자전거와 기어

자전거를 탈 때는 작은 기어(페달이 가벼워지고 느려짐), 큰 기어(페달이 무겁고 빨라짐) 중에 선택할 수 잇다. 기어는 발이 페달을 돌리는 힘으로 바퀴를 돌린다. 구체적으로는 페달이 회전할 때마다 바퀴가 얼마나 회전하는지를 기어에서 제어한다.

![image](https://user-images.githubusercontent.com/53181778/85508105-65bf2d00-b62e-11ea-9079-42ae9ca02fea.png)

크고 작은 기어를 비율로 표현할 수 있다.

```ruby
chainring = 52 # number of teeth
cog = 11
ratio = chainring / cog.to_f
puts ratio # -> 4.72727272727273

chainring = 30
cog = 27
ratio = chainring / cog.to_f
puts ratio # -> 1.11111111111111
```

위 코드를 기어 클래스로 만들어보자. 기어는 chainring, cog, ratio를 가지고 data와 behavior를 가지게 된다.

```ruby
class Gear
	attr_reader :chainring, :cog

	def initialize(chainring, cog)
	@chainring = chainring
	@cog = cog
	end

	def ratio
    	chainring / cog.to_f
	end
end

puts Gear.new(52, 11).ratio # -> 4.72727272727273
puts Gear.new(30, 27).ratio # -> 1.11111111111111
```

Gear클래스는 Object클래스의 서브 클래스로 많은 메소드들을 상속 받는다. 그렇게 때문에 응답할 수 있는 메세지의 집합(behavior의 집합)이 꽤 큰편이다. 상속은 어플리케이션 설계에 중요하지만, Gear클래스와 같이 간단한 경우는 매우 기본적인 상속에 해당하기 때문에 상속된 메소드가 없다고 생각해도 된다. (상속의 복잡한 형태는 6장에서 다룰 것이다. )

만약, 두대의 자전거를 가지고 있고 서로 같은 기어를 가지고 있지만, 다른 사이즈의 바퀴를 가지는 경우라면 바퀴의 영향도 고려해야 할 것이다. 보통 기어 인치를 이용하여 바퀴와 기어가 다른 자전거들을 비교한다.

`gear inches = wheel diameter * gear ratio` where `wheel diameter = rim diameter + twice tire diameter`

```ruby
class Gear
  attr_reader :chainring, :cog, :rim, :tire
  def initialize(chainring, cog, rim, tire)
    @chainring = chainring
    @cog = cog
    @rim = rim
    @tire = tire
  end

  def ratio
    chainring / cog.to_f
  end

  def gear_inches
    # tire goes around rim twice for diameter
    ratio * (rim + (tire * 2))
  end
end

puts Gear.new(52, 11, 26, 1.5).gear_inches
# -> 137.090909090909
ㄴ
puts Gear.new(52, 11, 24, 1.25).gear_inches
# -> 125.272727272727
```

하지만, 만약 기존에 사용하던 코드에서 `puts Gear.new(52, 11).ratio`와 같이 사용했다면, initialize의 파라미터 수와 맞지 않기 때문에 에러가 난다. gear_inches 기능을 추가하면서 생긴 버그이다. 아직까진 프로그램이 작기 때문에 큰 문제는 되지 않는다.

하지만, 이게 최선일까? 앞으로 더 많은 클래스가 생겨날 것이고 어플리케이션은 더 커질것이다. 더 효율적으로 확장시키기 위해 코드는 더 바꾸기 쉬워야 한다.

#### 2.2.2. 왜 단일 책임이 중요한가?

수정이 쉬운 어플리케이션은 재사용하기 쉬운 클래스들로 이루어져 있다. 재사용 가능한 클래스는 얽힘이 거의 없는 잘 정의된 행동의 접속 가능한 유닛(쉽게 가져다 쓸수 있는 유닛)이다.

하나 보다 많은 책임이 있는 클래스는 재사용하기 어렵다. 여러 책임을 가지는 클래스는 얼기설기 얽혀있는 것과 같다. 만약, 클래스의 전체가 아니라 일부분을 재사용하고 싶다면, 필요한 부분들만 얻는 것은 불가능하다. 이제 두 가지 옵션이 있고 두개다 매력적인 옵션은 아니다.

책임들이 너무 결합되어 필요한 행동들만 사용할 수 없다면, 필요한 코드를 복제하여 사용할 수 있다. 하지만 코드를 복제하는 것은 추가적인 유지보수를 유도하고 버그를 증가시키기 때문에 좋은 방법이 아니다. 만약 필요한 행동들에만 접근할 수 있는 구조화된 클래스가 있다면, 클래스 전체를 재사용 할 수 있을 것이다. 하지만, 이것은 단지 하나의 문제를 다른 문제로 대치하는 것에 불과하다. 재사용하는 클래스는 원래의 목적이 혼동되고, 뒤얽힌 몇몇 책임을 포함하게 되기 때문에, 여러 이유로 바뀌어야 한다. 여러 일을 하는 클래스에 의존하게 되면 어플리케이션이 잘못될 가능성이 높아진다.

#### 2.2.3. 클래스가 단일 책임을 가지는지 판단하기

클래스가 하나의 책임만을 가지는지 판단하는 방법에는 무엇이 있을까?

클래스가 인격이 있는 것처럼 질문을 하는 방법이 있다. 모든 메소드들을 질문으로 바꾸면, 질문을 하는 것이 말이 된다. 예를 들어, Gea에게 `당신의 기어비는 무엇인가요?` 라고 물어볼 수 있다. 하지만, 기어클래스에 `당신의 기어인치는 몇인가요?` 또는 `당신의 타이어 사이즈는 얼마나 되나요?` 와 같은 질문은 이상하다. 하지만 기어 클래스에게 `당신의 타이어는 무엇인가요?` 라고 물어보는 것은 충분히 가능한 일이다. 기어 클래스에서, 타이어는 ratio나 gear_inches와는 다른 종류의 것이다. 다른 모든 객체의 관점으로부터, 기어가 응답할수 있는 것은 또 다른 메세지일 뿐이다. 만약 기어가 메세지에 응답할 수 있다면 무언가가 메세지를 보낼것이고, 기어가 바뀐다면 송신자는 놀랄수도 있다(?).

클래스가 실제로 무엇을 하고있는지 이해하는 또 다른 방법은, 클래스의 책임을 한 문장으로 묘사해 보는 것이다. 클래스는 최대한 작으면서 유용한 것만 해야한다. 그렇기 때문에 간단하게 묘사할 수 있어야 한다. 만약 가장 단순한 표현에 `그리고, 또는`이라는 단어가 들어간다면 여러개의 책임을 가지고 있다고 볼 수 있다.

객체지향 설계는 `cohesion(화합, 결합, 응집력)` 의 단어를 사용하여 단일 책임의 개념을 설명한다. 하나의 클랙스 안에 있는 모든 것들이 클래스의 핵심 목적에 연관되어 있을 때, 이 클래스는 강하게 cohesion(결합)되어 1개의 책임을 가진다고 할 수 있다.

단일 책임 원칙(Single Responsibility Principle (SRP) )은 Wirfs-Brock & Brian Wilkerson의 Responsibility-Driven Design (RDD)에 뿌리를 두고 있다. RDD는 `하나의 클래스는 클래스의 목적을 수행하는 책임들로 구성되어 있다.`고 말한다. SRP는 하나의 클래스가 하나의 매우 좁은 일(목적)을 하거나 사소한 이유로 바뀌는 것을 요구하지 않는다. 대신에 SRP는 응집력있게 클래스가 하는 모든것은 클래스의 목적과 매우 높게 연관이 있어야 하는 것을 요구한다.

기어 클래스의 책임을 표현하자면 “앞, 뒤 톱니바퀴 사이의 기어비를 계산한다”. 만약 그렇다면 위에서 만든 Gear 클래스는 너무나 많은 일을 하고있다. 만약 “자전거에 기어가 미치는 영향을 계산한다”로 표현한다면 더 어울릴 것이다. 그렇다면 gear_inches 는 Gear 에 속하는 것이 맞지만, 타이어의 크기가 Gear에 속하는 것은 애매하다.

#### 2.2.4. 언제 디자인을 만들지 판단하기

클래스에 뭔가 문제가 있다고 느껴지는 순간이 자주 있다. Gear클래스에 왜 바퀴가 있지? 사실은 Bicycle 클래스이지 않을까 하는 고민이 있을 수 있다.

하지만, 우리는 미래에 어떤일이 생길지 모르고 우리에게 그에 대한 ㅈ어보가 없다. 준비가 안된 상태에서 서둘러서 디자인을 결정해야 한다고 느끼는 것은 좋지 않다. 다만, Gear클래스를 보면서 문제를 느꼈다면, `지금 이 문제를 수정하지 않는 다면 나중에 어떤 대가를 치르게 될까?`라고 스스로에게 질문해보자. 어쩌면 더 많은 정보를 얻을때 까지 아무것도 하지 않고 기다려 보는 것이 효율적인 접근일 수도 있다.

Gear클래스의 코드는 투명하고 적잘하지만 훌륭한 디자인은 아니다.아무런 `의존성`도 없기 때문에 코드를 수정한다고 해서 특별한 문제는 발생하지 않을 뿐이다. 만약 다른 객체와 의존성이 생긴다면 Gear 클래스는 투명함과 적절함을 잃게 될 것이다. 이 떄가 코드를 다시 구성해야할 때 이다. 그리고 이 의존성이 좋은 디자인을 결정하는 정보를 제공해준다.

지금 코드를 수정하는 비용이나 나중에 수정하는 비용이나 필요한 비용이 동일하다면 결정을 나중으로 미루는 것이 좋다. **디자인 결정은 꼭 필요한 순간에, 그 순간이 제공하는 정보들을 가지고 해야한다.**

하지만 Gear클래스는 지금당장 수정해야할지, 변경해야할지 의견이 분분할 것이다. 현재 클래스의 구조는 미래의 개발자에게 지금의 디자인 의도를 전달하는 메세지 이다. 미래의 개발자는 현재의 디자인 패턴을 참조할 것이다. 결론적으로, Gear클래스는 디자인 의도를 잘못 전달하고 있다. 사용성이 좋지도 않고, 좋은 코드도 아니다. 여러가지 책임을 가지고 있기 때문에 재사용하면 안되는 코드이다.

### 2.3. Writing Code That Embraces Change

나중에 수정에 필요한 경우에라도 쉽게 수정될 수 있도록 코드를 배치하는 일은 가능하다. 즉, 수정하기 쉬운 방식으로 코드를 하는 것이다.

#### 2.3.1. 데이터가 아닌 행동에 의존하기

행동은 메서드에 담겨있고 메세지를 보내는 행위를 통해 실행된다. 하나의 책임을 가지는 클래스를 만들때, 행동의 모든 작은 조각들은 한 장소에 속하게 된다. Don't Repeat Yorself(DRY)라는 문장은 이러한 아이디어를 의미한다. 행동을 바꾸는 것은 코드의 어떤 한 부분만을 바꾸면 되기 때문에, DRY 코드는 변화를 견뎌낼 수 있다.

객체는 행동과 함께 데이터를 가진다. 데이터는 객체의 인스턴스 변수에 속해 있고, 간단한 문자열이나 복잡한 해시일 수 있다. 데이터는 두가지 방법 중 하나로 접근할 수 있다. 인스턴스 변수를 직접 참조하거나, accessor 메서드안에 인스턴스 변수를 감싸는 방법이 있다.

- 인스턴스 변수 숨기기

  아래의 ratio 메서드 처럼, 직접 인스턴스 변수를 참조하는 대신에 인스턴스 변수를 accessor 메서드에 감싸서 접근하라.

  ```ruby
  class Gear
      def initialize(chainring, cog)
          @chainring = chainring
          @cog = cog
      end
      def ratio
          @chainring / @cog.to_f # <-- road to ruin
      end
  end
  ```

  클래스에서 변수들을 정의하고 있을지라고, 메서드로 변수를 감싸서 숨겨라. 루비는 `attr_reader`를 제공하여 캡슐화된 메서드를 쉽게 만들수 있다.

  ```ruby
  class Gear
      attr_reader :chainring, :cog # <-------
      def initialize(chainring, cog)
          @chainring = chainring
          @cog = cog
      end

      def ratio
          chainring / cog.to_f # <-------
      end
  end
  ```

  `attr_reader`는 변수를 감쌀 수 있는 간단한 wrapper 메서드를 생들어 준다.

  > cog를 위한 가상의 wrapper 메서드

  ```ruby
  # default implementation via attr_reader
  def cog
  	@cog
  end
  ```

  cog메서드만이 cog가 무엇을 의미하는지 이해할 수 있는 유일한 방법이다.  cog는 메세지 전송의 결과가 되었다. 이 메서드 구현함으로 cog는 `모든 곳에서 참조되는 데이터`에서 `한 번만 정의된 행동`으로 바뀌었다.

  `@cog` 인스턴스 변수가 10번 참조되고 갑자기 @cog의 내용을 바꿔야 한다면, 코드의 여러 부분을 수정해야 한다. 하지만 @cog가 래퍼 메서드로 감싸져 있었다면 cog 메서드를 직접 구현해서 cog가 어떤 의미인지 다시 정의할 수 있다. 우리가 직접 작성한 새로운 메서드는 아래의 첫 번째 예시처럼 간단할 수도 있고 두 번째 예시처럼 더 복잡할 수도 있다.

  #1

  ```ruby
  # a simple reimplementation of cog
  def cog
      @cog * unanticipated_adjustment_factor
  end
  ```

  #2

  ```ruby
  # a simple reimplementation of cog
  def cog
     	@cog * (foo? ? bar_adjustment : baz_adjustment)
  end
  ```

  데이터를 마치 '메시지를 이해하는 객체' 처럼 취급하는 것은 두 가지 이슈를 품고 있다.

  첫 번째 이슈는 `가시성`이다. `@cog`변수를 public 메서드로 감쌀 경우 다른 객체에 `@cog`변수에 접근할 수 있음을 의미한다. 반대로, private 메서드로 감쌀경우 외부에서는 접근할 수 없다. 이 두 선택지에 대해서는 4장에서 다룬다.

  두 번째 이슈는 조금더 더 추상적이다. 모든 변수를 메서드로 감싸고, 어떤 변수든지 마치 객체인것 처럼 다룰 수 있기 때문에 데이터와 보통의 객체를 구분하는 것이 무의미해진다. 가끔 어플리케이션의 일부분을 행동이 없는 데이터라 생각하는 것이  편리할 수 있지만, 대부분의 경우 데이터를 일반적인 객체로 받아들이는 것이 더 좋다.

  데이터를 감춤으로 예상치 못한 변화로부터 코드를 보호할 수 있다. 개발자도 데이터의 모든 행동을 다 알 수 없다. 변수를 데이터 처럼 생각할 지라도, 변수는 메시지를 보내는 것으로 접한하는 것이 좋다.

- 데이터 구조 숨기기

  인스턴스 변수에 애착을 가지는 것은 안좋지만, 복잡한 데이터 구조를 가지는 것은 더욱 더 좋지 않다. 아래의 ObscuringReferences 클래스를 보자.

  ```ruby
  class ObscuringReferences
      attr_reader :data
      def initialize(data)
          @data = data
      end

      def diameters
          # 0 is rim, 1 is tire
          data.collect {|cell|
              cell[0] + (cell[1] * 2)}
      end
      # ... many other methods that index into the array
  end
  ```

  이 클래스는 2차원 배열의 rims와 tires로 초기화 된다.

  ```ruby
  # rim and tire sizes (now in millimeters!) in a 2d array
  @data = [[622, 20], [622, 23], [559, 30], [559, 40]]
  ```

  ObscuringReferences 는 @data에 초기화 아규먼트를 저장하고, @data를 메서드에 감싸기 위해 attr_reader를 사용했다. diamwters메서드는 data에게 변수의 내용물에 접근하는 메세지를 보낸다. 이렇게 클래스 내부에서도 인스턴스 변수를 숨기고 있다.

  하지만, @data는 복잡한 데이터 구조를 가지고 있다. 단순히 인스턴스 변수를 숨기는 것만으로는 충분하지 ㅇ낳다. data 메서드는 단순히 배열을 반환할 뿐이다. 배열을 가지고 어떤 작업을 하려면, data메서드를 전송하는 객체의 정보를 잘 알고 있어야한다.

  diameters 메서드는 지름을 계산하는 것 뿐만아니라, rims와 tires를 배열의 어디서 찾아야 하는지 알고 있다. 배열의 [0]에 rims가 [1]에는 tires가 있다는 것을 알고 있다.

  이것은 배열의 구조에 의존적이다. 만약 데이터 구조가 바뀐다면 코드는 반드시 바뀌어야 한다. 배열에 데이터를 가지고 있을 때, 어플리케이션 곳곳에서 배열의 구조를 참조하는 코드를 작성해야 한다. 이런 참조는 위험하다. 변수의 캡슐화를 무시하고 배열 구조에 대한 지식을 코드 이곳저곳에 흩뿌려 놓는다. 전혀 DRY하지 않다. rims가 [0]에 있다는 것이 중복되어서는 안된다. 한 장소에서 이러한 것들을 관리해야한다.

  간단한 예시로 이것이 얼마나 나쁜지 충분히 확인할 수 있다. data가 여러 해시들로 이루어진 배열을 반환하고 이 배열을 코드의 여러 곳에서 사용한다고 상상해 보자. data의 구조를 변경한다면 코드 곳곳에 영향을 미칠 것이다. 그리고 각각의 변화는 버그를 만들수 있다.

  루비는 구조에서 의미를 손쉽게 분리할 수 있게 해준다. 메서드로 인스턴스 변수를 손쉽게 감쌀 수 있는 것처럼 루비의 `Struct 클래스`를 이용하면 데이터 구조를 감쌀 수 있다. 앞의 클래스와 동일한 외부 인터페이스를 가지고 있지만, 내부 인터페이스는 전혀 다르게 구현하였다.

  ```ruby
  class RevealingReferences
      attr_reader :wheels
      def initialize(data)
          @wheels = wheelify(data)
      end
      def diameters
          wheels.collect {|wheel|
              wheel.rim + (wheel.tire * 2)}
      end
      # ... now everyone can send rim/tire to wheel

      Wheel = Struct.new(:rim, :tire)
      def wheelify(data)
          data.collect {|cell|
              Wheel.new(cell[0], cell[1])}
      end
  end
  ```

  변경된 클래스의 diameters 메서드는 배열의 내부 구조에 대한 지식이 전혀 없다. diameters가 알고있는 전부는 wheels 메세지가 enumerable를 리턴한다는 것과 각각의 enumerable에 속해 있는 모든 객체가 rim과 tire메서드에 응답할 수 있다는 것이다. 기존에는 cell[1]에 대한 참조였지만, wheel.tire로 메세지를 보내는 방식으로 바뀌었다.

  입력받은 배열의 구조에 대한 모든 지식은 `wheelify` 메서드 속에 격리되었고 이 메서드는 `배열들의 배열`을 `Struct들의 배열`로 변환 시켰다.루비 공식문서에는 `Struct`는 `명시적으로 클래스를 만들지 않고도 accesor 메서드를 이용해 여러 어트리뷰트들을 묶어내는 편리한 방법`이라고 정의한다. 즉, rim과 tire 메서드에 반응하는 작고 가벼운 객체를 만들어 준 것이다.

  `wheelify` 메서드는 입력받은 배열의 구조에 대한 코드로만 이루어져 있다. 만약 입력값이 변한다면 바로 이 지점만 더 작성해야했지만, 이는 반복적으로 복잡한 배열의 구조를 참조해야 하는 비용에 비하면 아주 작은 번거로움에 지나지 않는다.

  이런 스타일의 코드는 외부 데이터 구조의 변화로 부터 코드를 보호해준다. 보다 가독성이 좋고 의미가 잘 드러나는 코드를 작성할 수 있다. 데이터 구조를 들여다 보던 작업을, 객체에 대한 메세지 전송 작업으로 대체한다. wheelify메서드는 구조에 대한 지저분한 정보를 한쪽에 몰아 놓고 코드를 DRY하게 만든다. 클래스가 변화를 쉽게 받아들일 수 있도록 만들다.

#### 2.3.2. 모든 곳에 단일 책임 원칙 강제하기

단일 책임 클래스를 만드는 것은 디자인에 중요한 영향을 주지만, 단일 책임의 아이디어는 코드의 많은 부분들에 유용한게 적용할 수도있다.

- 메서드에서 여분의 책임을 뽑아내기

  클래스와 같이 메서드도 하나의 책임을 가져야 한다. 메서드가 하나의 책임만을 지닐 때 메서드는 수정하기 쉽고 재사용하기도 쉽다. 클래스에 단일 책임을 적용하는 것과 매우 유사하다. 메서드의 하는일을 물어보고, 하나의 문장으로 메서드의 책임을 묘사해보자.

  ```ruby
  def diameters
    wheels.collect {|wheel|
      wheel.rim + (wheel.tire * 2)}
  end
  ```

  이 메서드는 명확하게 두개의 책임을 가지고 있다. wheels 배열을 순회하는 것과, 각 바퀴의 지름을 계산하는 것이다.

  단순화 하기 위해 하나의 책임만을 가지는 두 개의 메서드로 분리할 수 있다. 반지름을 계산하는 부분을 독립적인 메서드로 뽑아내보자. 메세지 전송이라는 추가적인 비용이 발생하지만, 현재는 성능보다 수정할 수 있는 코드를 작성하는 것에 집중하자.

  ```ruby
  first - iterate over the array
  def diameters
    wheels.collect {|wheel| diameter(wheel)}
  end

  # second - calculate diameter of ONE wheel
  def diameter(wheel)
    wheel.rim + (wheel.tire * 2))
  end
  ```

  바퀴 단 한 개의 지름을 계산해야할 일이 있는가? 코드를 다시 살펴보면, 이미 그러고 있다는 것을 알 수 있다. 이 리팩토링은 과도한 디자인을 적용한 것이 아니다. 단순히 사용중인 코드를 재구성했을 뿐이다. 단수형 diameter메서드가 다른 곳에서 불릴 수 있다는 사실은 좋은 부수효과를 얻은 것이다.

  개별 객체에 행해지는 액션과 객체들을 반복 순회하는 것을 분리하는 것은 쉽게 알아 챌 수 있는 다중 책임의 경우이다. 보통의 경우 이렇게 쉽게 보이지 않는다.

  Gear 클래스의 gear_inches메서드를 회상해보자.

  ```ruby
  def gear_inches
    # tire goes around rim twice for diameter
    ratio * (rim + (tire * 2))
  end
  ```

  gear_inches는 Gear클래스의 책임인가? 그럴듯해 보이지만, 아니다. 그 이유는 gear_inches는 단일 책임이 아닌 여러개의 책임을 지니고 있기 때문이다.

  gear_inches에 숨겨져있는 바퀴으 지름을 구하는 부분때문이다. 그 부분을 분리해보자.

  ```ruby
  def gear_inches
    ratio * diameter
  end

  def diameter
    rim + (tire * 2)
  end
  ```

  이제 gear_inches메서드는 메시지를 전송해서 바퀴의 지름을 알아낸다. 이번 리팩토링이 지름을 계산하는 방법을 변경하지 않았다는 사실에 유의하자. 단지 지름을 계산하는 행동을 분리 했을 뿐이다.

  최종적인 결과물을 모르는데도 이러한 리패토링이 필요한 것일까?의 대답은 '그렇다'이다. 리팩토링이 필요한 이유는 디자인이 명확하기 떄문이 아니라 오히려 디자인이 불명확하기 때문이다.

  이 간단한 리팩토링은 문제를 명확하게 드러내준다. Gear클래스에서 gear_inches를 계산할 필요는 있지만, 바퀴의 지름을 계산해서는 안된다.

  하나의 리팩토링의 영햔은 제한적이지만, 이런 코딩스타일이 누적되면 그 영향은 매우 거대해진다. 여러 메서드가 각각의 하나의 책임을 질 때 다음과 같은 이득이 있다.

  - **Expose previously hidden qualities**

    리팩토링을 통해 클래스의 모든 메서드가 단일 책임을 가지면 클래스 자체가 명확해진다. 당장 메서드들을 다른 클래스로 옮기고 재정리 하지 않아도 메서드 하나하나가 하나의 목적을 가지면 클래스가 하는일이 더욱 명확해진다.

  - **Avoid the need for comments**

    주석은 실행이 되는 코드가 아니기 떄문에 시간이 지나면 바스러지는 종이문서같다.  메서드 속에 있는 코드 한 조각에 주석을 달아야 한다면 그 코드를 별도의 메서드로 뽑아내자. 뽑아낸 메서드의 이름이 주석과 동일한 역할을 할 수 있다.

  - **Encourage reuse**

    작은 메서들은 우리의 애플리케이션에 도움을 주는 코딩 습관을 장려한다. 다른 프로그래머들도 코드를 다시쓰기보다는 메서드를 재활용 할 것이다. 결국, 그들은 작고 재사용이 가능한 메서드들을 만들게 될 것이다.

  - **Are easy to move to another class**

    디자인에 필요한 정보를 얻고 코드를 수정하기로 결정했을 때, 작은 메서스들은 이동하기 쉽다 리팩토링하는 수고를 많이 들이지 않고도 클래스의 행동을 재배치할 수 있다.

- 클래스의 추가적인 책임들을 격리 시켜 놓기

  모든 메서드들이 하나의 책임만 지게 되면 클래스의 역할의 범위 역시 분명해진다. Gear클래스에 바퀴의 것으로 보이는 행동이 있다. Wheel클래스를 애플리케이션에 추가해야 하는가?

  현재 Wheel클래스를 만드는 데 큰 무리가 없다면 만드는 방법도 괜찮아 보인다. 하지만 일단은 만들지 않기로 마음을 먹었다고 가정해보자. 어떤 디자인 이수가 있어 클래스를 만들고 싶지 않을 수도있고 지금 코드가 발전해가는 방향에 확신이 없어서 새로운 클래스를 만들었을 때 이 클래스를 다른 프로그래머가 사용하는 것이 꺼려질 수 있다.

  Gear가 하나의 책임만 지려면, Wheel 의 것으로 보이는 행동을 분리해야 할 것 같다. Gear클래스에 그대로 두거나 제거하거나, 두 가지의 양자택일의 문제에 따라 디자인을 결정하는 것은 근시안적이다.

  우리게에는 하나의 선택지가 더 있다. 최대한 특정 디자인에 종속되지 않으면서, Gear가 하나의 책임만을 지도록 하는 것이다.왜냐하면 수정하기 쉬운 코드를 작성하려면 진짜 어쩔수 없는 순간이 올 때까지 최대한 결정을 미루는 것이 좋기 때문이다. 진짜 필요하기 전에 내린 모든 결정은 단지 추측에 불과하다.

  루비는 바퀴 지름을 계산하는 책임을 Gear 클래스로부터 제거하면서도 새로운 클래스에 이 책임을 부여하지 않을 수 있는 방법을 제공한다. 다음 코드는 기존의 **Wheel Struct**에 **블록**을 이용해서 **지름을 계산**하는 메서드를 추가한다.

  ```ruby
  class Gear
    attr_reader :chainring, :cog, :wheel
    def initialize(chainring, cog, rim, tire)
      @chainring = chainring
      @cog = cog
      @wheel = Wheel.new(rim, tire)
    end

    def ratio
      chainring / cog.to_f
    end

    def gear_inches
      ratio * wheel.diameter
    end

    Wheel = Struct.new(:rim, :tire) do
      def diameter
        rim + (tire * 2)
      end
    end
  end
  ```

  이제 자신의 diameter를 계산할 수 있는 Wheel을 가지게 되었다. Gear에 이 Wheel을 주입하는 것은 물론 우리의 장기적인 디자인 목표에 전혀 부합하지 않는다. 차라리 코드 구성을 위한 실험에 가깝다. 이제 Gear클래스는 꺠끗해졌고, Wheel에 대한 판단을 미룰수 있게 되었다.

  Gear안에 Wheel을 끼워두는 것은 Wheel이 언제나 Gear와 함께 사용된다는 것을 의미한다. (하지만 현실에서는 그렇지 않다.)

### 2.4. Finally, the Real Wheel

Gear 클래스의 디자인과 씨름하는 동안 때가 다가와다. 결국, 자전거 바퀴 둘레를 계산하는 기능도 필요해졌다. 자전거에는 속도를 계산해주는 장치가 있고 그 기능을 이용하기 위해서는 자전거의 바퀴 사이즈를 알아야한다.

바퀴의 둘레는 지름 * 원주율이다. 지름을 계산할 수 있는 Wheel을 Gear안에 넣어 두었기에 둘레를 계산하는 메서드를 추가하는 것은 쉽다. 더 중요한 점은 Gear클래스와 독립된 Wheel클래스가 명시적으로 필요해졌다는 점이다.

이미 Gear클래스에서 Wheel의 행동을 구분해 놓았기 때문에 이 수정은 전혀 어렵지 않게 진행될 수 있다. Wheel Struct를 Wheel클래스로 변경하면 된다

```ruby
class Gear
  attr_reader :chainring, :cog, :wheel
  def initialize(chainring, cog, wheel=nil)
    @chainring = chainring
    @cog = cog
    @wheel = wheel
  end
  def ratio
    chainring / cog.to_f
  end

  def gear_inches
    ratio * wheel.diameter
  end
end

class Wheel
  attr_reader :rim, :tire

  def initialize(rim, tire)
    @rim = rim
    @tire = tire
  end

  def diameter
    rim + (tire * 2)
  end

  def circumference
    diameter * Math::PI
  end
end

@wheel = Wheel.new(26, 1.5)
puts @wheel.circumference
# -> 91.106186954104

puts Gear.new(52, 11, @wheel).gear_inches
# -> 137.090909090909

puts Gear.new(52, 11).ratio
# -> 4.72727272727273
```

이제 Gear와 Wheel 모두 1개의 책임만 지게되어다. 코드가 완벽하다고는 할 수 없지만, 높은 수준에 도달했다고는 할 수 있다.

## 3. Managing Dependencies

현실을 모델링하는 방법 떄무에 객체지향 프로그래밍 언어는 효율적이며 효과적이라고 말한다. 객체는 현실세계의 문제의 특성을 반영하고, 두개의 객체 사이의 상호작용은 해결법을 제공한다. 이런 상호작용은 필수적이다. 하나의 객체가 모든 것을 알고 있을 수는 없기때문에 객체끼리의 소통은 필수이다.

객체들의 상호작용을 멀리서 바라보면 하나의 패턴이 존재한다. 각 메세지는 하나의 객체에서 시작되며 특정한 행동을 유발하기 위해 존재한다. 이 모든 행동은 객체 사이에 퍼져있고, 어떤 원하는 행동을 위해 객체는 그 행동을 개인적으로 알고있거나, 상속을 받거나 그 행동을 아는 객체를 알아야한다.

2장에서는 행동을 미리 알고있는 경우에 집중을 했다면, 3장에서는 행동을 알고있는 다른 클래스를 아는 것에대해서 다룰 것이다. (상속에 대해서는 6장)

잘 디자인된 객체는 하나의 책임만을 가지고 있기 때문에 객체끼리 서로 상호작용을 할 수 밖에 없다. 서로 협업하기 위해 객체는 서로에 대한 지식을 가져야 하고 이 지식이 의존성을 만들어 낸다. 의존성을 제대로 관리하지 못한다면 어플리케이션은 엉망이 될 것이다.

### 3.1. 의존성 이해하기

만약 하나의 객체를 수정했을 때 다른 객체를 수정해햐 한다면, 후자에 해당하는 객체들은 전자에 해당하는 객체에 의존적이라고 할 수 있다.

아래에는 2장에서 다루었던 Gear클래스가 조금 변형되었다. Gear_inches메서드에서 rim과 tire를 이용하여 새로운 Wheel 인스턴스를 생성한다.

```ruby
class Gear
  attr_reader :chainring, :cog, :rim, :tire
  def initialize(chainring, cog, rim, tire)
    @chainring = chainring
    @cog = cog
    @rim = rim
    @tire = tire
  end

  def gear_inches
    ratio * Wheel.new(rim, tire).diameter
  end

  def ratio
    chainring / cog.to_f
  end
  # ...
end

class Wheel
  attr_reader :rim, :tire
  def initialize(rim, tire)
    @rim = rim
    @tire = tire
  end

  def diameter
    rim + (tire * 2)
  end
  # ...
end

Gear.new(52, 11, 26, 1.5).gear_inches
```

코드를 보고 Wheel 이 변경되었을 때 Gear도  변경되어야 하는 상황이 어떤 경우가 있을지 생각해보자. 이 코드는 생각보다 복잡함을 가지고 있다. Gear는 Wheel에 대해 적어도 4개의 의존성을 가지고 있다. Gear는 이런 의존성 없이도 잘 작동할 수 있고 이런 의존성이 있다는 것 자체가 Gear클래스를 수정하기 어렵고 연약하게 만들고 있다.

#### 3.1.1. 의존성 알아채기

객체는 다음과 같은 내용을 알고있을 때 의존성을 가진다.

- **다른 클래스의 이름** : Gear는 Wheel이라는 클래스가 존재한다고 예상한다.
- **자기 자신을 제외한 다른 객체에게 전송할 메세지 이름** : Gear는 Wheel의 인스턴스가 diameter라는 메서드를 이해할 수 있다는 것을 예상한다.
- **메세지가 필요로하는 아규먼트** : Gear는 Wheel.new가 rim과 tire를 필요로 한다는 것을 안다.
- **아규먼트들의 순서** : Gear는 Wheel.new의 첫 아규먼트로 rim을 두번째 아규먼트로 tire를 사용한다는 것은 안다.

위에서 나열한 의존성들은 Wheel을 변경했을 때 어쩔수 없이 Gear도 수정해야 하는 상황을 만든다. 의존성이 생기는 것은 어쩔수 없지만, 나열된 의존성의 대부분은 불필요한 것이다. 우리의 과제는 각 클래스가 자신이 해야하는 일을 하기 위한 **최소한의 지식만을 알고 그 외에는 아무것도 모르도록 의존성을 관리** 하는 것이다.

#### 3.1.2. 객체들 간의 결합(CBO - Coupling Between Objects)

이러한 의존성들은 Gear를 Wheel에 결합시킨다. 즉, 결합이 의존성을 만들어 낸다. Gear가 Wheel을 더 많이 알 수록 더욱 견고하게 결합한다. 두 객체가 견고하게 결합될수록 하나인것 처럼 행동한다.

Wheel을 바꾸면 Gear를 바꾸는게 필수적이라는 것을 안다. Gear를 재사용하고 싶다면, Wheel또한 따라오게 된다. Gear를 테스트하려면 Wheel도 테스트 해야한다.

![image](https://user-images.githubusercontent.com/53181778/85681361-2c59f080-b706-11ea-882d-45bfd3607101.png)

Gear는 A,B,C,D,Wheel에 의존하고 있으로 Gear는 다섯개의 객체와 결합하고 있다. Gear를 다른 곳에서 사용하려고 하기 전, 또는 Gear가 의존하고 있는 클래스를 수정하기 전까지 무엇이 문제인지 파악하기 어렵다. Gear는 전혀 독립적이지 않다. 의존성은 다른 객체가 한 객체 내부에 깊이 관여하고 있는 부분이다. 의존성이 높은 객체들은 마치 하나인듯 행동하며 이들은 발맞추어 움직인다.(톱니바퀴와 같다고 생각하면 될듯)

둘 이상의 객체가 강력하게 결합되어 있다면 이들 중 하나만 재사용하는 것은 불가능하다. 하나를 바꾸려면 다른 것도 바꾸어야 한다. 미처 확인하지 못한 제대로 관리하지 않은 의존성들이 남아 있다면 어플리케이션 자체가 엉망진창이 될 것이다.

#### 3.1.3. 다른 의존성들

위에서 살펴본 4가지 의존성을 컴토하고 이들로 인해 생겨나는 문제를 해결하기 위한 기술을 다루기 전에 다른 장에서 다루게 될 몇몇 일반적인 의존성 이슈를 다루고 넘어가겠다.

먼저 하나의 객체가 다른 객체에 대해 알고있고, 이 다른 객체가 또 다른 무언가를 알고 있는 또 다른 객체에 대해 알고 있는 경우( 0 - 0 - 0 - 0 이런식으로 체인처럼 연결된 경우) 멀리 있는 객체이 행동을 실행시키려 할 때 가장 심각한 피해를 야기하게 된다. 이 의존성은 기본적으로 **자기 자신을 제외한 다른 객체에게 전송할 메세지의 이름을 아는 의존성**이다. 단지 확장된 형태일 뿐이며, 메세지 연쇄(메세지 체이닝)은 원래 있던 두 객체 사이의 의존성뿐 아니라, 중간에 거쳐간 모든 객체와 메세지들 사이에도 의존성을 만들어 낸다. 만약에 중간의 하나의 어떤 객체가 변하게 되면 이 변화는 첫 번쨰 객체에 까지 영향을 미치기 때문에 첫 번째 객체에 수정을 강제할 가능성이 무척 높다. 이런 경우를 Law of Demeter가 위반되었다고 말한다. 자세한 내용은 4장에서 다루도록 하겠다.

의존성의 또 다른 영역은 테스트가 코드에 대해 가지는 의존성이다. 코드보다 테스트를 먼저 작성하는 사람들이 있다. 테스트가 디자인을 이끌어 낸다. 하지만 테스트는 코드를 참조하고 그런 의미에서 코드에 의존적이다. 테스트를 처음 접하는 프로그래머들은 종종 코드와 지나치게 결합된 테스트를 작성하는 경향이 있다. 이 강한 결합은 결국 엄청난 좌절감을 낳곤한다. 코드의 핵심적인 내용은 전혀 바뀌지 않았는 데도 불구하고 리팩토링 때마다 테스트가 깨져나간다. 테스트를 유지하는 비용이 테스트를 통해 얻는 가치보다 더 높아지기 시작한다. 테스트-코드 사이의 지나친 결합은 코드-코드 사이의 지나친 결합과 동일한 결과를 낳는다. 이 결합은 코드의 수정이 뒤이어 테스트의 수정을 강제하는 의존성이다. 테스트 디자인에 대해서는 9장에서 다루도록 하겠다.

### 3.2. 약하게 결합된 코드 작성하기

의존성은 클래스 그리고 클래스가 건드리는 것을 붙여버리는 본드와 같다. 약간의 본드는 필요하지만 너무 많은 본드는 좋지않다. 의존성을 줄이는 작업은 곧 불필요한 본드가 무엇인지 알고 제거하는 과정이다.

#### 3.2.1. 의존성 주입하기

클래스의 이름을 통해 다른 클래스를 참조하는 방식은 상당히 끈끈한 spot을 만든다. 지금까지 작성했던 Gear클래스에서 gear_inches 메서드는 Wheel 클래스를 명시적으로 참조하고 있다.

```ruby
class Gear
  attr_reader :chainring, :cog, :rim, :tire
  def initialize(chainring, cog, rim, tire)
    @chainring = chainring
    @cog = cog
    @rim = rim
    @tire = tire
  end

  def gear_inches
    ratio * Wheel.new(rim, tire).diameter
  end
  # ...
end

Gear.new(52, 11, 26, 1.5).gear_inches
```

Wheel클래스의 이름을 직접 참조할 때 가장 눈에 띄는 부분은 Wheel 클래스의 이름을 변경하면 gear_inches의 메서드도 함꼐 변해야 한다는 점이다. 사실 Wheel클래스의 이름을 변경하는 것은 큰 문제를 만들어내지 않는다. 진짜 문제는 잘 드러나지 않고 더 큰 문제를 야기하는 곳에 숨겨져있다.

Gear가 Wheel을 참조하는 부분을 저 쪽에 있는 gear_inches 메서드 속에 하드코딩해 놓았을 때 Gear는 Wheel 인스턴스의 기어의 인치만을 계산하겠다고 명시적으로 보여주고 있는 것이다. Gear는 다른 종류의 객체와 협업하기를 거부하고 있다.

자전거 디스크나 실린더 같은 객체를 다루게 되었을 경우, 실린더와 디스크 객체를 사용하는 기어의 기어인치를 알아야한다. 하지만 우리는 기어 인치를 계산할 수 없다.디스크와 실린더는 지름을 가지고 있지만, Gear는 Wheel에 찰싹 붙어 있기 때문에 기어인치를 계산할 수 없다.

위 코드는 고정된 타입에 불필요하게 들러 붙어 있는 클래스에 얼마나 문제가 많은지 보여준다. 중요한 것은 '객체의 클래스가 무엇인지'가 아니라, '우리가 전송하는 메세지가 무엇인지'이다. 즉, 기어에게는 diameter메서드에 반응 할 수 있는 객체가 필요한 것이다. Gear는 대상이 되는 객체의 클래스가 무엇인지는 관심도 없고 알 필요도 없다. Gear_inches를 계산하기 위해 Gear가 Wheel의 존재를 알 필요는 없다. 더욱더 Wheel이 초기화되기 위해 rim과 tire가 필요하다는 것을 알 필요가 없다. Gear에게는 diameter를 알고 있는 객체만 있으면 된다.

Gear의 쓸모 없는 의존성으로 재사용성이 떨어지고 수정해야할 일이 많이 생긴다. 아래 코드는 Gear 클래스를 diameter에 반응할 수 있는 객체만 가지고도 초기화 할 수 있다.

```ruby
class Gear
  attr_reader :chainring, :cog, :wheel
  def initialize(chainring, cog, wheel)
    @chainring = chainring
    @cog = cog
    @wheel = wheel
  end

  def gear_inches
    ratio * wheel.diameter
  end
  # ...
end

# Gear expects a ‘Duck’ that knows ‘diameter’
Gear.new(52, 11, Wheel.new(26, 1.5)).gear_inches
```

Gear는 @wheel 변수를 사용하여 wheel 메서드로 변수에 접근한다. 하지만 Gear가 알고있는 것은 자기 자신이 diameter메서드에 반응할 줄 아는 객체를 가지고 있다는 것 뿐이다.(Wheel의 인스턴스인지는 관심 없음)

아주 작은 변화처럼 보이지만, Wheel의 인스턴스를 Gear 클래스 밖에서 생성하기 때문에 Gear와 Wheel 사이의 결합이 없어졌다. 이제 Gears는 diameter를 구현하고 있는 어떤 객체와도 협업할 수 있게 되었다.

이 기술을 **의존성 주입**(dependency injection)이라고 부른다. 엄청 대단한 기술로 알려져 있지만 사실 이렇게 단순하다. Gear는 Wheel클래스, Wheel을 초기화할 때 넘겨줘야 하는 인자와 인자의 순서에 대해 명시적으로 의존하고 있었지만 의존성 중비을 통해 이 모든 의존성이 diameter 메서드에 대한 단 하나의 의존성으로 줄어 들었다. 아는 것을 줄임으로 더 똑똑한 코드를 만든 것이다.

종속성 주입을 사용하여 코드를 형상화하는 것은 클래스의 이름을 알고 있는 책임과 해당 클래스에 보낼 메시지의 이름을 아는 책임이 서로 다른 객체에 속할 수 있다는 것을 인식하는 능력으로 부터 나온다. Gear가 어딘가로 diameter메세지를 전송해야 한다고해서 Gear가 Wheel에 대해서 알필요 가 없는 것처럼 말이다.

그렇다면 실제 Wheel 클래스에 대해 알아야 할 책임은 누구에게 있을까? 이 부분에 대해서는 나중에 다루도록 하겠다. 일단은 Gear가 그것을 몰라도 된다는 것이 중요하다.

#### 3.2.2. 의존성 격리시키기

불필요한 의존성을 모두 제거하면 가장 좋겠지만 현실적으로 어려운 문제이다.  이미 작동 중인 어플리케이션을 가지고 작업할 때 실제로 수정할 수 있는 부분은 매우 제한적이다. 완벽함을 추구할 수 없다면 우리의 목표는 전반적인 상태를 발전시키는 것에 만족해야 한다.

그렇기 때문에 불필요한 의존성을 제거할 수 없는 경우라면 의존성을 클래스 안에서 격리시켜 놓아야 한다. 불필요한 의존성이 어디에 있는지 쉽게 찾고 줄일 수 있도록 의존성을 고립시키는 방법을 알아보자.

- 인스턴스 생성을 격리시키기

  만약 제약조건이 너무 낳아서 Gear에 Wheel을 주입할 수 없다면 새로운 Wheel 인스턴스를 만드는 과정을 Gear클래스 내부에 격리시켜 놓을 필요가 있다. 이는 의존성을 명시적으로 노출하는 작업인 동시에 Wheel이 Gear클래스 내부에 스며드는 것을 막는다.

  두 개의 예시를 통해 접근법을 살펴보자.

  첫 예시는 새로운 Wheel 인스턴스를 생성하는 과정을 Gear의 gear_inches 메서드에서 initialize 메서드 속으로 옮겼다. gear_inches 메서드는 조금더 깔끔해졌고, wheel에 대한 의존성을 더욱 뚜렷하게 드러낼 수 있게 되었다.이런 접근은 Gear가 새로운 인스턴스를 만들때마다 무조건 새로운 Wheel 인스턴스를 생성한다는 사실에 주의해야한다.

  ```ruby
  class Gear
    attr_reader :chainring, :cog, :rim, :tire
    def initialize(chainring, cog, rim, tire)
      @chainring = chainring
      @cog = cog
      @wheel = Wheel.new(rim, tire)
    end

    def gear_inches
      ratio * wheel.diameter
    end
    # ...
  ```

  다른 방법은 명시적으로 정의된 wheel 메서드를 통해 새로운 Wheel 인스턴스를 만드는 방법이다. 이는 루비의 `||=` 연산자를 이용해서 객체가 필요한 순간에 왔을 때, Wheel인스턴스를 만든다. 이런 경우 gear_inches 가 Wheel 메서드를 호출하기 전까지 Wheel의 인스턴스가 만들어 지지않는다.

  ```ruby
  class Gear
    attr_reader :chainring, :cog, :rim, :tire
    def initialize(chainring, cog, rim, tire)
      @chainring = chainring
      @cog = cog
      @rim = rim
      @tire = tire
    end

    def gear_inches
      ratio * wheel.diameter
    end

    def wheel
      @wheel ||= Wheel.new(rim, tire)
    end
    # ...
  ```

  위 두 예시에서도 Gear는 너무 많은 거을 알고 이다. 여전히 rim과 tire를 초기화 인자로 전달해줄 수 있어야 하고 Gear내부에서 Wheel인스턴스를 생성해야한다. 또한, Wheel과 너무 밀접하게 연관되어서 Wheel을 제외한 인스턴스를 가지고는 gear_inch를 구할 수 없다.

  그럼에도 어느정도의 발전은 있다. Gear_inches가 가지고 있던 몇몇 의존성을 줄였으며 Gear가 Wheel에 의존하고 있다는 사실을 뚜렷하게 보여줄 수 있다. 의존성을 오히려 잘 보이게 함으로 재사용의 장벽을 낮추고 리팩토링을 더 쉽게 할 수 있게 만들어 주었다.

  외부 클래스 이름에 대한 으존성을 이렇게 관리하게 되면 의존성을 고려하면서 설계를 하기 때문에 클래스는 자연스럽게 덜 결합된 형태를 띈다.

- 취약한 외부 메세지 격리시키키

  **외부 클래스 이름을 참조**하는 지점을 격리시켰으니, **외부로 전송되는 메세지에 대한 의존성**에 대해 살펴보자. 즉, 나 자신이 아닌 외부의 어떤 객체에 보내는 메세지를 살펴보자. 예를 들어, gear_inches는 ratio와 wheel 메세지를 자기 자신에게 보내고 있지만 diameter 메세지는 wheel에게 보내고 있다.

  ```ruby
  def gear_inches
    ratio * wheel.diameter
  end
  ```

  간다한 코드이기에 별 문제가 없어 보이지만, 더 복잡한 코드로 변경시켜야할 경우 문제가 될 수 있다. 아래 예시를 보자

  ```ruby
  def gear_inches
    #... a few lines of scary math
    foo = some_intermediate_result * wheel.diameter
    #... more lines of scary math
  end
  ```

  Wheel.diameter는 엄청난 수학공식들 사이에 숨겨져있다. 되면 gear_inches가 wheel 메서드에 반응한다는 사실에 의존하고 이 wheel이 diameter메서드에 반응한다는 사실에도 의존한다. Gear_inches메서드 속에 외부에 대한 의존성을 심어 놓는 것은 불필요한 일이고 코드를 취약하게 만든다.

  외부 의존성을 걷어내고 의존성을 클래스 내부의 메서드 속에 캡슐화시켜 놓으면 gear_inches 메서드를 수정해야 하는 상황도 줄일 수 있다.

  ```ruby
  def gear_inches
    #... a few lines of scary math
    foo = some_intermediate_result * diameter
    #... more lines of scary math
  end

  def diameter
    wheel.diameter
  end
  ```

  만약 이전에 diameter를 Gear클래스 내부의 이곳저곳에서 사용해야 했다면 아마 DRY를 유지하기 위해 처음부터 diameter 메서드를 만들었을 것이다. 여기서 차이점은 타이밍이다.

  원래 코드에서 gear_inches는 wheel이 diameter를 가지고 있다는 사실을 알고 있었다. 이 지식은 gear_inches를 외부의 객체에 그리고 이 외부 객체의 메서드들에 결합시켜 버리는 위험한 의존성이다 수정 이후 gear_inches는 조금 더 추상화 되었다. Gear는 wheel.diameter를 별도의 메서드에 분리하여 gear_inches가 자기자신에게 전송하는 메세지에 의존할 수 있게 했다.

  Wheel에서 diameter 메서드의 이름을 바꾸더라도 Gear에 미치는 영향은 diameter메서드(Wrapping method)에 한정될 것 이다. 클래스가 그 내부에서 변하기 쉬운 메세지를 참조하고 있을 때 이 기술을 유용하게 사용할 수 있다.

  이런 문제를 제거하는 또 다른 방법은 의존성이 시작되는 지점으로 돌아가서 의존성의 방향을 반대로 돌려버리는 것이다. 이렇게 함으로 문제 자체를 회피하는 방법이 있다. 이 방법에 대해 설명하기 전에 먼저 짚고가야할 코딩 스킬이 하나있다.

#### 3.2.3. 인자 순서에 대한 의존성 제거하기

필요한 인자를 전달할 때, 보내는 입장에서 인자에 대한 지식을 아는 것을 피할 수 없다. 이 의존성은 피할 수 없는 것이다. 하지만, 인자를 전달하는 것은 종종 감지하기 어려운 두 번째 의존성을 발생시킨다. 많은 메서드 시그니처는 인자를 필요로할 뿐만 아니라, 특정한 순서를 지키길 기대한다.

아래 예시에서 Gear의 initialize 메서드는 세개의 인자를 넘겨받는다. 파라미터가 기본값을 제공하지 않기 때문에 모든 인자를 넘겨주어야 하고, 반드시 순서대로 전달해야 한다.

```ruby
class Gear
  attr_reader :chainring, :cog, :wheel
  def initialize(chainring, cog, wheel)
    @chainring = chainring
    @cog = cog
    @wheel = wheel
  end
  ...
  end

Gear.new(
  52,
  11,
  Wheel.new(26, 1.5)).gear_inches
```

new 메서드를 전송하는 송신자는 Gear의 초기화 메서드에서 정의된 인자의 순서에 의존적이다. 불행하게 인자를 손봐야 하는일은 자주 발생한다. 하지만 인자를 손보는 일은 해당 메서드에 의존적인 객체들을 수정해야 하는 것을 의미한다. 더욱 곤란한 것은 우리가 인자들을 변경하지 않으려 할 수도 있다는 점이다. 디자인 관점에서는 인자를 변경해야 겠지만 모든 의존성을 또 다시 변경하고 싶지 않기 때문이다.

- 초기화 인자로 해시 사용하기

  고정된 인자에 대한 의존을 피하는 가장 간단한 방법으로 해시를 사용할 수 있다. 순서가 고정된 인자대신 옵션을 해시로 만들어서 넘기는 것이 좋다.

  다음은 예시이다.

  ```ruby
  class Gear
    attr_reader :chainring, :cog, :wheel
    def initialize(args)
      @chainring = args[:chainring]
      @cog = args[:cog]
      @wheel = args[:wheel]
    end
    ...
    end

  Gear.new(
    :chainring => 52,
    :cog => 11,
    :wheel => Wheel.new(26, 1.5)).gear_inches
  ```

  이 방법의 가장 뚜렷한 장점은 인자의 순서성을 제거했다는 것이다. 코드가 장황해지긴 했지만, 그 효과에 비하면 별거 아닌 문제점이다.

  인자의 순서의 의존성을 없애는 대신에 해시 키에대한 의존성이 생겼다. 키에 대한 의존성은 기존의 의존성 보다 훨씬 안정적인 의존성이기 때문에 문제가 되지 않는다. 또한, 인자들에 대한 문서의 역할도 해주게 된다.

  하지만, 별거 아닌 기능을 만드는데 해시를 쓴다면 조금 부담스러울 수도 있다. 그리고 고정된 인자에 더해 추가적으로 해시를 이용하여 사용하기도한다.

- 기본값을 정의하기

  인자에 기본값을 추가하는 방법은 여러가지가 있다. boolean이 아닌 간단한 기본값은 루비의 `||`메서드를 이용해 추가할 수 있다.

  ```ruby
  # specifying defaults using ||
  def initialize(args)
    @chainring = args[:chainring] || 40
    @cog = args[:cog] || 18
    @wheel = args[:wheel]
  end
  ```

  일반 적인 방법이지만, 주의해야할 점이 있다. ||를 사용하는 것은 hash에 등록되지 않은 키에 대한 요청을 하게되면 nil을 반환하는 특성에 의존하고 있다. 해시 인자가 :boolean_thing이라는 키를 가지고 있고 이 키의 기본값을 true로 설정하고 싶은 경우가 있을 수 있다. 이런 경우에도 ||를 사용하면 :boolean_thing의 키의 값을 false나 nil로 설정할 수 없게 된다.

  예를 들어 아래의 경우는 :boolean_thing키가 정의되지 않을 경우 뿐만 아니라, nil이나 false의 값을 가지고 있을 경우에도 @bool의 값을 true로 만든다.

  ```ruby
  @bool = args[:boolean_thing] || true
  ```

  ||의 특성 때문에 불린 값을 인자로 받고 싶거나 false와 nil을 구부해야 하는 경우에 fetch메서드를 사용하는 것이 좋다. fetch메서드는 우리가 사용하는 키가 해시에 정의되어 있기를  기대하며 키가 없는 경우에 별도의 처리방식을 제공한다. fetch는 우리가 찾는 키가 없을 때 자동으로 **nil을 반환하지 않는다는 장점**이 있다.

  아래 예시에서 fetch를 사용한 기본값을 정의하였다. 이렇게 하면 키가 존재하고 값이 false나 nil일 경우에 그대로 사용할 수 있다.

  ```ruby
  # specifying defaults using fetch
  def initialize(args)
    @chainring = args.fetch(:chainring, 40)
    @cog = args.fetch(:cog, 18)
    @wheel = args[:wheel]
  end
  ```

  initialize메서드 속에 기본값을 설정하는 코드를 완전히 제거하고 별도의 Warpping method에서 기본값을 설정하는 방법도 있다. 아래 코드의 default 메서드는 초기화 과정에서 args 인수에 **merge** 될 기본 해시를 정의하고 있다. 이렇게 사용하면 fetch와 동일한 효과를 얻을 수 있다. 즉, args 해시에 키값이 없는 경우에만 기본 해시의 값이 사용된다.

  ```ruby
  # specifying defaults by merging a defaults hash
  def initialize(args)
    args = defaults.merge(args)
    @chainring = args[:chainring]
    # ...
  end

  def defaults
    {:chainring => 40, :cog => 18}
  end
  ```

  별도의 메서드를 사용하는 방법은 앞의 경우에도 잘 적용할 수 있지만 기본값이 훨씬 복잡한 경우에 특히 좋다. 기본 값이 단순한 스트링이나 숫자가 아닌고 어떠한 연산의 결과라면 defaults내부에서 구현하면 된다.

- 멀티파라미터 초기화를 격리시키기

  메서드를 수정하지 못하는 경우도 존재한다. 예를 들면 외부 프레임워크의 경우이다. 만약 기어를 외부 프레임 워크의 한 부분으로 생각한다면, initialize 메서드는 순서가 고정된 인자들을 필요로 할 것이다.  하지만 Gear이느턴스를 생성하는 지점을 하나의 메서드로 감싸서 코드를 DRY하게 만들 수 있다. 우리가 만드는 어플리케이션은 우리가 작성한 코드에 의존해야 한다.

  이 의존성을 해결하기 위해 GearWapper 모듈을 만들어 보자. 모듈을 이용함으로 외부 인터페이스에 대한 모든 지식을 한 곳에 집중시킬 수 있을 뿐만 아니라 어플리케이션이 사용할 수 있는 조금 더 좋은 인터페이스를 제공하게 된다.

  ```ruby
  # When Gear is part of an external interface
  module SomeFramework
    class Gear
      attr_reader :chainring, :cog, :wheel
      def initialize(chainring, cog, wheel)
        @chainring = chainring
        @cog = cog
        @wheel = wheel
      end
      # ...
    end
  end

  # wrap the interface to protect yourself from changes
  module GearWrapper
    def self.gear(args)
      SomeFramework::Gear.new(args[:chainring],
        args[:cog],
        args[:wheel])
    end
  end

  GearWrapper.gear(
    :chainring => 52,
    :cog => 11,
    :wheel => Wheel.new(26, 1.5)).gear_inches
  ```

  SomeFramework라는 외부 프레임워크에 Gear라는 클래스는 고정된 인자를 가지고 있다.  GearWrapper는 옵션 해시를 이용하여 새로운 Gear인스턴스를 생성한다.

  두 가지 기억해야할 점이 있다. GearWrapper는 클래스가 아닌 모듈이라는 점이다. 모듈을 이용함으로 우리는 GearWrapper 이느턴스를 만들지 않고도 gear메시지를 전송하는 명시적이고 독립적인 객체를 얻었다. 아마 클래스에 특정 모듈을 include하는 것과  혼동 될 수 있겠지만, GearWrapper는 특정 클래스를 인클루드 하기 위한 것이 아니라, gear메세지에 인스턴스 생성없이 직접 반응하기 위한 것이다.

  또 다른 점은 오로지 클래스의 인스턴스를 생성하기 위해서만 GearWrapper가 존재한다는 점이다. 객체지향에서 이런 객체를 `팩토리(Factory)`라고 부른다. 팩토리는 다른 객체를 만들기 위해 존재하는 객체이다.

  지금까지 고정된 인자들을 옵션 해시로 대체하는 기술에 대해 학습했다. 외부에 대한 의존성이 코드 속으로 스며들게 내버려 두지 말자. 애플리케이션이 직접 통제할 수 있는 래퍼 메서드를 만들어 어플리케이션을 보호하자.

  ### 3.3. 의존성 방향 관리하기

  모든 의존성은 방향이 있다. 의존성의 방향을 반대로 돌려 의존성을 관리하는 방법이 있다는 것을 앞에서 살짝 언급하여였다. 그에 대해서 조금더 심도있게 다루어보자.

  #### 3.3.1. 의존성 뒤짚기

  지금까지 사용했던 모든 예시에서 Gear는 Wheel이나 diameter에 의존했다. 하지만 이 의존성을 반대로 설정할 수도 있다. Wheel이 Gear나 ratio에 의존할 수 도 있었다. 아래 코드는 이런 뒤바뀐 의존성의 한 예를 보여준다.

  ```ruby
  class Gear
    attr_reader :chainring, :cog
    def initialize(chainring, cog)
      @chainring = chainring
      @cog = cog
    end

    def gear_inches(diameter)
      ratio * diameter
    end

    def ratio
      chainring / cog.to_f
    end
    # ...
  end

  class Wheel
    attr_reader :rim, :tire, :gear
    def initialize(rim, tire, chainring, cog)
      @rim = rim
      @tire = tire
      @gear = Gear.new(chainring, cog)
    end

    def diameter
      rim + (tire * 2)
    end

    def gear_inches
      gear.gear_inches(diameter)
    end
    # ...
  end

  Wheel.new(26, 1.5, 52, 11).gear_inches
  ```

  Wheel이 Gear인스턴스에 의존하는 것을 확인 할 수 있다. 의존성의 방향이 바뀌어도 별 문제가 없어보인다 방향성이 바뀌었다고 결과가 달라지지도 않았다. 방향성은 코드가 수정될 일이 없다면 크게 중요한 문제는 아니다.

  하지만, 방향성을 설정하는 것은 추후에 있을 변화에 대해 지대한 영향을 미친다.

#### 3.2.4. 의존성 방향을 선택하기

클래스가 사람이라고 해보자. 크래스에게 어떻게 행동해야하는지 조언해야 한다면, 스스로 보다 더 조금 변하는 것들에 의존하라고 말할 수 있다. 이 간단한 문장은 코드에 대한 단순한 사실 세가지를 기반으로 조금더 다듬을 수 있다.

- 어떤 클래스는 다른 클래스에 비해 요구사항이 자주 바뀐다.
- 콘크리트 클래스는 추상 클래스보다 수정해야 하는 경우가 빈번히 발생한다.
- 의존성이 높은 클래스를 변경하는 것은 코드의 여러 곳에 영향을 미친다.

이 세가지는 종종 겹치기도 하고 독립적이기도 하며, 그 의미가 뚜렷하다.

- 변경 가능성 이해하기

  어떤 클래스가 다른 클래스보다 변결될 가능성이 높다는 인식은, 우리가 작성한 코드 이외에도 우리가 작성하지는 않았지만 사용하는 코드에도 적용된다. 루비의 베이스 클래스나 또는 다른 프레임워크 코드도 변경이 될 가능성이 있다.

  우리가 작성하는 코드보다 루비의 베이스 클래스가 잘 바뀌지 않는다는 것은 정말 다행이다. 루비의 베이스 클래스는 사실 크게 변할 일이 없기 때문에 많이 고려하지 않아도된다.

  하지만 다른 프레임워크는 다른 상황이다. 프레임워크의 코드는 안정적이긴 하지만 그렇지 않은 경우도 존재한다.

  변경 가능성을 아는 방법은 어플리케이션에서 사용하는 모든 클래스를 다른 클래스와 비교하여 얼마나 변경되지 않았는지를 기준으로 순위를 매겨볼 수 있다. 이 순위는 의존성의 방향을 결정하는데 핵심적이다.

- 구체적인것과 추상적인것 인식하기

  두 번째는 코드의 구체성과 추상성을 이해하는데서 출발한다. 여기서 추상이라는 개념은 "모든 구체적인 것으로부터 분리된"이라는 뜻으로  사용된다. 그리고 이 개념은 코드에 대한 루비의 기본적인 태도, 특정한 기술적 제약이나 스타일에 반대하는 입장에 잘 어울린디.

  Gear가 Wheel, Wheel.new 등에 의존적일 때 Gear는 매우 구체적인 코드에 의존하고 있는 것이다. 반대로, Wheel을 Gear에 주입하는 방식의 코드는 Gear는 훨씬 추상적인 것에 의존하는 것이다.

  > 만약 정적 타입 언어에서 이와 같은 기능을 구현하려면 어떻게 해야할까? 정적 언어는 마치 타입에 대한 단위 테스트 처럼 작동하는 컴파일러를 가지고 있기 때문에 Gear에 우리가 내키는 대로 아무 객체나 주입할 수 없다. 인터페이스를 먼저 작성하고 diameter를 인터페이스의 일부로 정의하고 이 인터페이스를 Wheel 클래스에 포함시키고 gear에게 우리가 지금 주입하는 클래스가 이런 인터페이스의 한 종류라고 알려줘야 할 것이다.
  >
  > 루비 사용자들은 이런 반복잡업을 하지 않아도 된다. 하지만 변경 사항을 명시적으로 표시하도록 강제하는 언어가 지니는 이점도 있다. 이런 언어들은 우리가 추상적인 인터페이스를 만들고 있다는 사실을 명시적으로 드러내준다. 실수로 또는 의도치 않게 추상화된 코드를 만드는 것은 불가능하다. 정적 언어에서는 언제나 명확인 의도를 가지고 인터페이스를 정의한다.
  >
  > 루비의 경우, Gear에 Wheel을 주입하고 Gear가 diameter라는 메서드에 반응하는 오리타입에 의존하도록 했을 때 우리는 별 생각없이 인터페이스를 정의한 것이다. 어떤 종류의 것들은 지름을 가지고 있다는 생각을 추상화한 것이 이 인터페이스 이다. 이 추상화는 구체 클래스들로부터 추출되었고, 구체적인것들로 부터 분리되었다.

  추상화의 훌륭한 점은 일반적이고 안정적인 성질을 지닌다는 점이다. 추상화된 인터페이스는 인터페이스가 기반하고 있던 구체 클래스보다 변경될 일이 훨씬 적다. 앞으로 이어질 내용에서 클래스라는 표현은 일반적인 클래스 뿐만아니라 이런 인터페이스 역시 지칭한다. 이런 인터페이스도 의존성을 가지고 있기 때문에 디자인을 할 떄 고려를 해야한다.

- 의존성높은 클래스 피하기

  마지막은 의존성이 높은 클래스를 만들면 그 대가를 반드시 치뤄야한다는 것이다. 의존성이 높은 클래스를 수정할 떄 감내해야 하는 부정적인 효과는 매우 자명하다. 의존성이 높은 클래스가 갖는 효과에 대해서는 좀더 설명이 필요하다. 작은 수정으로 전체를 수정해야 한다면 아무도 수정하고 싶지 않을 것이다. 즉, 평생 어플리케이션에서 이 문제를 안고 가야한다.

- 문제가 되는 의존성 찾아내기

  지금까지 검토했던 내용을 어플리케이션의 모든 코드 속에서 종합적으로 검토해보자. 언제 변화에 봉착하게 될지, 어느 정도로 추상화되어 있는지, 의존성이 몇 군데 있는지를 검토한다.

  중요한 디자인 결정을 내려야 하는 순간은 **수정을 해야 할수도 있는 가능성이** **여러 의존성**과 만나는 지점에서 발생한다. 이 둘의 조합은 어플리케이션의 도움이 될수도 치명적일 수도있다.

  ![image](https://user-images.githubusercontent.com/53181778/85717426-79e75500-b728-11ea-9df8-1893d5e54937.png)

그림의 가로축은 **요구사항의 변경이 발생할 가능성**, 세로축은 **클래스에 의존하고 있는 객체의 수**를 반영한다. 어플리케이션의 모든 클래스를 각각 A,B,C,D 영역과 매칭 시킬 수 있을 것이다.

변경이 발생할 가능성이 낮지만 이 클래스에 의존하고 있는 객체가 많은 클래스는 A영역에 속한다. 이 영역에는 추상클래스나 인터페이스가 속한다. 충분히 잘 디자인된 어플리케이션에서는 의존성이 추상화 된것 근처에 몰려있을 수 밖에 없다. 추상화 된것은 변경가능성이 낮기 떄문이다.

하지만, 클래스가 A영역에 속하기 때문에 추상화된 것이 아니라는 것은 확실히 해야한다. (추상화되고 잘 설계된 경우에 A에 속하는 것임, A에 속한다고 추상화 됐다고는 할 수없다.) A영역에 있는 클래스가 추상화가 되지 않았다면, 추상화 될 필요가 있다.

B영역을 보기전에 C영역을 보자 C영역은 A영역과 정반대다. C영역은 변경될 가능성은 높지만 클래스에 딸린 객체가 적은 클래스들로 채워져있다. 이곳의 클래스들은 보다 구체적인 경향이 있어 변경될 가능성이 높지만, 의존적인 클래스가 적기 때문에 큰 문제가 되지 않는다.

B역영의 클래스들은 디자인의 관점에서 보면 가장 중요성이 낮다. 어떤 변화에 대해 가장 적은 영향을 받는 클래스들이기 때문이다.

A, B, C 영역에 있는 클래스들은 큰 문제가 없다. 문제는 D영역이다. D영역은 위험영역이라는 이름이 어울린다. D영역의 클래스들은 어플리케이션의 건강상태를 드러내는 지표이다.

`자기 자신보다 덜 변하는 것들에 의존하라`라는 것이 좋은 디자인의 핵심이다.

## 4. Creating Flexible Interfaces

객체지향 어플리케이션을 클래스들을 합치는 것이라고 생각하기 쉽다. 클래스는 눈에 잘 보이기 때문에 클래스의 책임이나 의존송을 중심으로 디자인에 대해 논하는 경우가 많다.

클래스 레벨에서 다루어야 하는 디자인 이슈들도 있지만, 클래스 이상의 것들이 존재한다. 어플리케이션은 클래스로 구성되어 있지만, **메세지**를 통해서 정의된다. 디자인은 객체 사이를 가로지르는 메세지에 관심을 가지고 해야한다. 객체가 무엇을 알고(객체의 책임), 누구를 알고(객체의 의존성)있는지 뿐만 아니라, 객체끼리 서로 소통하는 방법을 알아야 한다.

객체 사이의 소통은 인터페이스를 통해 이루어진다.

### 4.1. 인터페이스 이해하기

![image](https://user-images.githubusercontent.com/53181778/85817884-32091200-b7aa-11ea-9aa6-82fce40fa665.png)

그림과 같은 두 종류의 어플리케이션이 있다고 생각해 보자. 왼쪽의 어플리케이션은 특정한 패턴이 존재하지 않아 보인다. 모든 객체가 다른 모든 객체와 연결되어 있다. 반면에 오른쪽 어플리케이셔의 메세지들은 정확하게 드러나는 패턴을 보여준다.

왼쪽 어플리케이션은 객체를 재사용하기가 어렵다. 자기 자신을 너무 많이 드러내고 주변 객체에 대해 너무 많이 알고있다. 독립적으로 존재하는 객체는 없고, 하나를 재사용하기 위해서는 전체를 사용해야 하고 하나를 수정하려면 전체를 수정해야 한다.

오른쪽 어플리케이션은 조립 가능한 구성으로 되어있다. 부품처럼 작동하는 객체로 이루어져 있으며, 자신을 최소한으로 드러내며 다른 객체에 대해서도 최소로 알고 있다.

오해하기 쉬우나, 왼쪽 어플리케이션은 의존성 주입이나 단일 책임 원칙과는 무관하다. 즉, 의존성 주입과 단일 책임 원칙만으로는 문제를 해결할 수 없다. 이 문제의 핵심은 클래스가 무엇을 하는지에 있는 것이 아니라, 무엇을 드러내는지에 있다.

오른쪽 어플리케이션의 메세지 패턴은 나름의 제약사향을 보여준다. 객체가 어떤 메세지를 주고 받을지에 대한 일종의 합의가 되어있다. 즉, 각 객체는 다른 객체가 사용할 수 있는 메서드의 묶음을 잘 정해놓았다.

밖으로 노출된 메서드가 클래스의 **퍼블릭 인터페이스**를 구성한다. 여기서 말하는 인터페이스는 클래스 안에 있는 인터페이스를 지칭한다. 클래스는 메서드를 구현하고 그중 일부는 클래스의 외부의 객체가 사용하기 위한 것이고, 그것이 클래스의 퍼블릭 인터페이스를 구성한다.

하나의 클래스로부터 독립되어 있고, 여러 클래스사이를 돌아다니는 또 다른 종류의 인터페이스도 있다. 이런 의미의 인터페이스는 `메시지의 묶음`을 의미한다. 메세지들 자체가 인터페이스를 정의하는 것이다. 각 클래스는 이런 인터페이스가 요구하는 메서드들을 구현한다. 이는 마치 인터페이스가 가상의 클래스를 저의하고 있는 것과 같다. 인터페이스가 요구하는 메서드를 구현하고 있다면 어떤 클래스든 `인터페이스 같은 것` 처럼 동작한다.

### 4.2. 인터페이스 정의하기

식당을 예로들면, 손님은 메뉴판보고 주문을 하고 손님의 주문내역은 홀과 주방을 이어주는 작은 창을 지나 주방으로 전달된다. 손님은 주문을 하면 그만이지만, 부엌은 각 주문마다 다른 프로세스로 요리를 제공해준다. 여기서 메뉴판을 퍼블릭 인터페이스로 볼 수 있다. 주방은 많은 일이 벌어지고 수많은 메세지가 오고 가지만, 손님들에게는 private하기에 보이지 않는다.

퍼블릭과 프라이빗의 구분은 일을 가장 효육적으로 처리하기 위해 존재한다. 손님은 요리를 어떻게 하는지 몰라도 메뉴판을 보고 주문을 할 수 있다. 클래스는 주방과도 같다. 클래스는 하나의 책임을 제대로 수행하기 위해 존재하며 수 많은 메서드를 구현하고 있다. 클래스의 핵심 책임을 메인으로 다루는 메서드부터, 클래스 내부에서만 사용하기 위해 만들어진 유틸리티 메서드까지 그 범위는 다양하다. 어떤 메서드는 클래스의 메뉴판과 같은 역할을 하는 퍼블릭 메서드이고, 어떤 메서드들은 자잘한 내부 구현에 관여하기 때문에 프라이빗 메서드이다.

#### 4.2.1. 퍼블릭 인터페이스

클래스의 퍼블릭 인터페이스를 구성하는 메서드는 바깥에 보여지는 클래스의 얼굴이다.

퍼블릭 인터페이스 메서드의 특징

- 클래스의 핵심 책임을 드러낸다.
- 다른 객체에 의해 호출될 수 있다.
- 쉽게 변경되지 않는다.
- 다른 객체가 안정적으로 의존할 수 있다.
- 테스트를 통해 꼼꼼하게 문서화되어 있다.

#### 4.2.2. 프라이빗 인터페이스

그 외의 메서드는 프라이빗 인터페이스의 부분이다.

프라이빗 인터페이스 메서드의 특징

- 세부적인 구현을 담당한다.
- 다른 객체에 의해 호출되지 않는다.
- 필요에 따라 언제든 변경할 수 있다.
- 다른 객체가 의존하기에는 위험하다.
- 테스트에서 다루지 않을 수도 있다.

#### 4.2.3. 책임, 의존성, 인터페이스

클래스의 단일 책임 : 클래스는 단일 책임을 위해 구성되어 있다.

- 클래스의 퍼블릭 인터페이스는 클래스의 얼굴과 마찬가지 이기 때문에 클래스의 책임을 표현한 문장과 매칭되어야 한다. (퍼블릭 인터페이스는 클래스의 책임에 대한 설명서)

의존성 관리하기 : 클래스는 자기 자신보다 덜 변하는 클래스에 의존해야 한다.

- 클래스를 public한 부분과 private한 부분으로 구분한다면, 클래스 내부에서도 자신보다 덜 변화하는 것에 의존해야한다.
- 클래스의 public한 부분은 안정적인 부분이다. private한 부분은 변경될 수 있는 부분이다.
- 즉, public함과 private함이 어떤 메서드에 의존하는게 더 유리한지 알려주는 지표가 된다. 하나의 클래스가 다른 클래스의 public한 메서드를 사용한면서 이 메서드가 안정적이기를 기대할 수 있다. 반대로 private한 메서드를 사용한다면 변할 수 있는 것에 의존한다는 의미를 내포하고 있어 위험이 증가한다.

### 4.3. 퍼블릭 인터페이스 찾기

퍼블릭 인터페이스를 찾는것은 쉽지 않다. 예제를 통해 인터페이스에 대한 기본적인 원칙 몇가지를 이해해보자.

#### 4.3.1. (예시) 자전거 여행 회사

로드바이크와 마운틴 바이크 여행을 다루는 회사에서 여행길을 추천한다. 각 여행길은 여행객이 방문할 수 있는 횟수가 제한되어 있으며, 정해진 수의 가이드와 정비사가 필요하다. 여행길은 체력조건에 따라 난이도별로 분류되고, 마운틴 바이크 여행은 기술적인 어려움에 따라 분류된다. 여행객의 체력조건과 자전거 기술의 수준에 따라 여행객이 주어진 여행길을 소화할 수 있는지를 판단한다. 여행객은 자전거를 빌릴수도 있고 자기 자전거를 가지고 와도 된다. 회사에는 가지고 있는 자전거가 많지않아 자전거 점포들과 자전거를 공유하는 시스템을 갖추고 있다.

다음과 같은 요구사항을 생각해 보자. (나중에 이것을 Usecase 라고 부를 것이다.)

- **여행객**은, **여행길을 선택**하기 위해서, **정해진 날짜**에, **자신에게 맞는 난이도**의, **자전거를 빌릴 수 있는**, **여행길 목록**을 보고싶어 한다.

#### 4.3.2. 의도를 구성하기

어플리케이션의 첫 코드를 짜는 것은 어려운 일이다. 무작정 코드를 작성하면 안된다. 어떤 사람은 테스트 코드부터 작성해야 한다고 한다. 고수들은 디자인에 대해 많이 경험해보고 알고 있기 때문에 의도를 가지고 있어, 테스트를 먼저 짜기 수월하다. 하지만 초보들은 아니다.

하지만, 우리도 이미 나름의 의도를 가지고 있다. 먼저 어떤 클래스가 있어야 할지 사업모델을 보면서 생각해보자.

Customer, Trip, Route, Bike, Mechanic 클래스 정도를 떠올렸을 것이다. 이 클래스들은 어플리케이션 속의 도메인 객체, 즉 정보와 행동을 모두 가지고 있는 명사들을 표현하기 때문이다. 도메인 객체를 찾아내기는 쉽지만, 이들이 어플리케이션의 핵심은 아니다. 오히려 함정에 빠지기 쉽다. 도메인 객체에만 집착하면 행동들을 이 객체 속에 넣어 버리기 쉽기 때문이다.

숙련된 전문가들은 이 객체들을 인지하지만, 집중하지는 않는다. 전문가들은 객체들 사이의 메세지에 주목을 한다. 메세지들은 새로운 객체를 찾도록 도와주는 가이드 역할을 해주며, 도메인 객체만큼 중요한 잘 보이지 않는 새로운 객체를 찾도록 도와준다.

우리는 Usecase를 만족시켜 줄 수 있는 객체들과 메세지의 의도를 먼저 구상할 필요가 있다.

#### 4.3.3. 시퀀스 다이어그램 사용하기

객체와 메세지를 탐구할 수 있는 가장 편리한 방법은 시퀀스 다이어그램을 사용하는 것이다. 시퀀스 다이어그램은 통한 모델링 언어(UML)에 정의되어 있으며, UML이 제공하는 많은 다이어그램 중 하나이다.

아래 그림은 위에서 제시한 Usecase를 표현한다.

![image](https://user-images.githubusercontent.com/53181778/85822804-b6fa2880-b7b6-11ea-9a1e-7ddfd669978b.png)

moe라는 고객 객체가 Trip 클래스에게 적절한 여행을 추천해달라는 메세지를 보내고 Trip클래스는 그에 대한 응답을 한다. 여기서 시퀀스 다이어그램의 중요한 점은 객체 사이를 오가는 메세지를 보여주고 있다는 것이다.

이 다이어그램 예시에서 각 개체는 같은 이름의 동일한 박스 두개로 표현된다. 하나는 위에 하나는 아래에 있고 그 둘은 세로의 점선으로 연결되어 있다. 이 다이어그램에는 두 개의 객체가 있는데, 하나는 moe Customer이고 다른 하나는 class Trip이다. 둘 사이의 메세지는 가로선의 화살표로 표현되어 있다. 그리고 메세지를 받은 객체는 메세지를 처리하는 동안 활성화 되고, 활성화는 세로로 긴 직사각형으로 표현되었다.

Usecase에 포함된 명사는 시퀀스 다이어 그램에서 객체로 표현되었고, 행동들은 메세지로 변경된다. suitable_trips메세지에는 3개의 인자를 필요로 한다. (on_date, of_difficulty, need_bike)

하지만, 과연 Trip에게 자전거에 대한 요청도 하는것이 맞을까? 그것이 Trip의 책임일까'? 일반적으로 표현해보면, 수신자가 이 메세지에 반응할 책임을 가지고 있는가?

시퀀스 다이어그램의 가치는 여기서 나온다. 다이어그램은 객체들이 주고받는 메시지를 명시적으로 보여주고, 객체들은 퍼블릭 인터페이스를 통해서만 소통하기 때문에 시퀀스 다이어그램은 인터페이스를 드러내고, 실험해보며 결국은 인터페이스를 정의하기 위한 도구가 된다.

메세지 기반의 디자인은 클래스 기반의 디자인 관점보다 유연한 어플리케이션을 만들어준다". **"이 클래스가 필요하다는 것은 아는데 이 클래스는 무엇을 해야할까?" 대신에 "이 메세지를 전송해야하는데 누구에게 해야할까?" 라는 관점에서 디자인을 하는 것이 메세지 기반의 디자인 관점이다.** 즉, 객체이기에 메세지를 보내는 것이 아니라, 메세지를 보내야하기 때문에 객체인 것이다.(닭이 먼저냐 달걀이 먼저냐..?)

위 다이어그램에서 Customer가 suitable_trips메세지를 보내는 것은 의심할 여지가 없다. 하지만 이 메세지를 받는 것이 Trip이 맞을까? 아마 새로운 대안을 찾아야 할 것이다. 여행에 어울리는 자전거가 있는지 파악하는 것이 Trip의 역할이 아니면 Bicycle 클래스의 책임인지도 모른다. Trip에게는 suitable_trips메세지에 대한 응답을 할 책임이 있고, Bicycle에게는 suitable_bicyle를 처리해야하는 책임이 있다.

정리해보면 다음과 같다.

- 고객은 여행 목록을 얻고자한다.
- suitable_trips 메세지를 구현하고 있는 객체가 있다.
- 적당한 여행지(suitable_trips)를 찾기 위해서는 적당한 자전거(suitable_bicycle)도 골라야한다.
- suitable_bicycle 메세지를 구현하고 있는 또 다른 객체가 있다.

![image](https://user-images.githubusercontent.com/53181778/85826347-6509d080-b7bf-11ea-9789-9e06e64b9824.png)

하지만, 어떤 측면에서는 나아졌지만, 다른 측면에서는 더 나빠졌다. Trip에서 추가적이 책임을 제거했지만, 이 책임을 단지 Customer로 바꾼 것이다. Customer클래스는 여행의 적합성을 평가하는 어플리케이션의 중심 로직을 담게 되어버렸다.

고객은 단지 주문판을 보고 음식을 주문해야하는데, 직접 요리를 하는 지경에 이른것이다.

#### 4.3.4. '어떻게' 해야하는지 알려주는 대신 '무엇을' 달라고 요구하기

**송신자가 원하는 것을 요구하는 메세지**와 **수신자가 어떻게 행동해야하는지 알려주는 메세지**의 차이를 아는 것은 매우 중요하다. 이것이 잘 정의된 퍼블릭 인터페이스를 가진, 재사용이 가능한 클래스를 만들기 위한 핵심이다.

what과 how 사이의 차이점을 설명하기 위해 상세한 예시가 필요하다. custom/trip 다자인 패턴은 조금 후 다시 검토를 하고, '여행, 자전거, 정비사'를 다루는 새 예시를 보자.

usecase : 여행이 시작되기 위해서는 모든 자전거가 잘 정비되어 있는지 확인해야한다.

Trip은 자전거를 어떻게 준비해야 하는지 알고 있을 수도 잇고, 정비사에게 이 작업들을 요청해야 할 수도 있다.

![image](https://user-images.githubusercontent.com/53181778/85827562-7bb12700-b7c1-11ea-8b45-98b00fb50871.png)

- Trip의 퍼블릭 인터페이스는 bicycles 메서드를 포함하고 있다.
- Mechanic의 퍼블릭 인터페이스는 celan_bicycle, pump_tire, lube_chain 그리고 check_brakes 메서드를 포함하고 있다.
- Trip은 celan_bicycle, pump_tire, lube_chain, check_brakes 메서드를 가지고 있는 객체를 필요로 한다.

이 디자인에서 Trip은 Mechanic이 하는 작업들을 모두 알고있다. 만약, 정비사가 준비과정에 수리도구 세트를 장착했는지 확인하는 메서드를 추가한다면, Trip에서도 이 메서드를 호출하도록 수정이 되어야 한다.

아래 그림은 Trip이 Mechanic에게 자전거를 준비하라고 요청하는 또 다른 방법을 보여준다. 자전거를 준비하기 위한 세부적인 구현사항은 Mechanic 내부에서 알고있다.

![image](https://user-images.githubusercontent.com/53181778/85827930-32ada280-b7c2-11ea-9940-b487a1449a84.png)

- Trip의 퍼블릭 인터페이스는 bicycles 메서드를 포함한다.
- Mechanic의 퍼블릭 인터페이스는 prepare_bicycle 메서드를 포함한다.
- Trip에게는 prepare_bicycle메서드를 가지고 있는 객체가 필요하다.

앞단계에서 Trip이 가지고 있던 책임을 Mechanic에게 넘겨주엇다. Trip은 자전거가 준비되어 있기를 바라고 Mechanic이 작업을 제대로 수행한다고 믿는다. 즉, `How`와 관련된 책임이 모두 Mechnic에게 넘어갔기 때문에 나중에 Mechanic을 보완하더라도 Trip은 언제나 원하는 결과를 얻을 수 있다.

자전거를 준비해야한다 = what, 그런데 어떻게 준비하냐(타이어 공기압, 브레이크 체크 등) = how

Trip과 Mechanic 사이의 관계가 how에서 what으로 바뀌면서 인터페이스의 양이 눈에 띄게 줄게 되었다. Mechanic은 여러 메서드를 노출하고 있지만, 위 그림에는 퍼블릭 인터페이스 속에 단 하나의 메서드 밖에 없다. Mechanic은 자신의 퍼블릭 인터페이스가 안정적이고 잘 변하지 않을 것이라고 약속했기 때문에 작은 퍼블릭 인터페이스를 갖는다는 것은 다른 객체가 의존할 수 있는 메서드의 수가 적다는 사실을 뜻한다.

하지만, Trip은 여전히 mechanic에 대해 너무 많이 알고잇다. Trip이 더 조금 알면서도 자신의 역할을 잘 수행할 수 있다면 코드는 보다 유여하고 유지보수하기 쉬워질 것이다.

#### 4.3.5. 맥락 의존성 찾기

Trip이 다른 객체에 대해 알고 있다는 사실이 Trip이 속한 맥락을 구성한다. Trip은 하나의 책임을 가지고 있지만, 특정한 맥락을 필요로 한다. Trip을 사용하려면 테스트를 위해서든 다른 용도에서든 **맥락이 먼저 설정**되어 있어야 한다.

여행을 준비하기 위해서는 언제나 자전거를 준비해야 하며 Trip은 **언제나 mechanic에게 prepare_bicycle메세지를 전송**해야 한다는 맥락을 가지고 있다. 하지만, prepare_bicycle 메서드에 반응하는 mechanic처럼 작동하는 객체가 없다면 Trip을 재사용 할 수 없다는 것이다. 이 것은 객체의 재사용성에 영향을 미치게 된다.

우리는 누구인지 모르는 객체와 협업하는 방법, 즉 의존성을 주입하는 방법을 알고있다. 이제, 새로운 문제는 Trip이 **Mechanic이 무엇을 하는지 모르는 채로** **Mechanic의 올바른 행동을 호출**하도록 만드는 부분이다. **Trip은 자신이 속한 맥락에서 독립적이면서도 mechanic과 협업**하고 싶다.

아래 그림에서 Trip은 Mechanic에게 자신이 원하는 것을 말하면서 자기 자신을 인자로 넘겼고, 바로 이어 Mechanic은 Trip을 호출해서 Trip으로부터 정비하기를 원하는 bicycle의 목록을 얻어 온다.

![image](https://user-images.githubusercontent.com/53181778/85828436-6210df00-b7c3-11ea-9053-14a8a2b0006c.png)

- Trip의 퍼블릭 인터페이스는 bicycles를 포함하고 있다.
- Mechanic의 퍼블릭 인터페이스는 prepare_trip을 포함하고 있고, 아마도 pre_pare_bicycle도 포함하고 있을 것이다.
- Trip은 prepare_trip 메서드에 반응할 수 있는 객체가 필요하다.
- Mechanic은 prepare_trip의 인자로 bicycles에 반응할 수 있는 객체가 필요하다.

이제 정비공이 어떻게 여행을 준비하는지에 대한 지식은 Mechanic 속에 고립되었고 Trip이 속한 맥락은 줄어들었다. Trip과 Mechanic 모두 수정하기도, 테스트하기도, 다시 사용하기도 쉬워졌다. Trip에게는 prepare_trip을 보낼 객체만 있으면 된다.

#### 4.3.6. 다른 객체를 믿기

클래스 사이에 관계는 "내가 원하는 것을 알고있고, 네가 주어진 역할을 제대로 하리라 믿고있다"는 것을 기반으로 객체지향을 설계하는 것이 좋다.

#### 4.3.7. 새로운 객체를 찾아내기 위해 메세지를 사용하기

What과 How의 차이도 알고, 맥락과 믿음이 왜 중요한지도 알고있다. 처음 보았던 Usecase에 대해서 다시 살펴보자.

- **여행객**은, **여행길을 선택**하기 위해서, **정해진 날짜**에, **자신에게 맞는 난이도**의, **자전거를 빌릴 수 있는**, **여행길 목록**을 보고싶어 한다.

4.3.3의 마지막 부분에서, Trip에서 너무 많은 책임을 지고있거, Bicycle로 자전거를 찾아야하는 책임을 옮겼었다. 하지만 Customer는 자신에게 어울리는 여행에 대해 너무 많이 알아야만 했고, 너무 많은 책임을 지게 된다. 이 것은 단일 책임 원칙을 위반하고 있고, Customer에게 너무 많은 맥락이 있다.

Customer가 suiatble_trips 메서드를 전송하는 일은 타당해 보인다. 문제는 송신자가 아닌 수신자에게 있다. 우리는 이 메서드를 구현할 객체를 아직 찾지 못한 것이다.

Customer, Trip, Bicycle이 교차하는 지점에서 어울리는 여행을 찾아 줄 객체가 필요하다. suitable_trips메서드는 이 객체의 퍼블릭 인터페이스의 한 부분을 이룰 것이다. 아래 그림에서 TripFinder라는 새로운 클래스를 추가했다.

![image](https://user-images.githubusercontent.com/53181778/85836167-2e3cb600-b7d1-11ea-9622-18e51d70e1a3.png)

TripFinder는 여행을 여행객과 어울리게 만드는 것이 무엇인지 모두 알고있다. 내부적으로는 어떨지 몰라도 이 클래스는 안정적인 퍼블릭 인터페이스를 제공한다.

suitable_trips 메서드를 ReipFinder로 옮겼기 때문에 다른 객체들도 이 행동에 접근할 수 있게 되었다.이제 이 행동이 Customer로 부터 분리되어 나왔기 때문에 다른 객체도 독립적으로 suitable_trips를 사용할 수 있다.

#### 4.3.8. 메세지 기반 어플리케이션 만들기

우리의 관심을 객체에서 메세지로 옮기면서 퍼블릭 인터페이스를 기반으로 어플리케이션을 디자인하는데 집중할 수 있게 되었다.

### 4.4. 자신의 인터페이스를 드러내는 코드 작성하기

우리의 디자인 능력과 훈련 정도는 인터페이스의 명료함을 통해 드러난다. 인터페이스를 만들 떄 염두해 두어야 하는 기본적인 윈칙들을 알아보자.

#### 4.4.1. 명시적인 인터페이스 만들기

다른 사람이 우리가 작성한 메스드를 실행할 때 우리는 어떤 메서드에 의존해도 괜찮은지 알려줄 의무가 있다. 새로운 클래스를 만들 때마다 우리는 그 클래스의 인터페이스를 선언한다. 퍼블릭 인터페이스의 메서드는 다음과 같아야 한다.

- 엄밀하고 명시적으로 규정되어 있어야 한다.
- 어떻게 보다는 어떤 것에 대해 말해야 한다. (HOW < WHAT)
- 예측할 수 있는 한도에서 바뀌지 않을 이름을 지어야 한다.
- 추가적인 인자를 해시로 받아라.

프라이빗 인터페이스도 의도를 가지고 명시적으로 만드는 것이 좋다. 테스트는 그 자체로 문서의 역할을 하기 때문에 이런 노력을 뒷받침해 줄 수 있다. 프라이빗 메서드의 테스트는 만들지 않거나, 꼭 만들어야 한다면 퍼블릭 메서드 테스트와는 따로 분리하는 것이 좋다. 다른 프로그래머가 테스트를 보고 프라이빗 메서드에 의존하지 않도록 해야한다.

루비에서는 이와 관려해서 public, protected, private 키워드를 제공한다. 이 키워드들을 통해 메**서드가 안정적인지 아닌지 알려줄 수 있다**. 그리고 **메서드들이 얼마나 노출되는지 결정**한다. 메스드의 안정성을 알려주는 일과 다른 객체가 해당 메서드를 어떻게 사용할지를 관리하는 일은 완전히 다른일이다.

**Public, Protected, Private**

>  private 키워드 : 가장 불안정하고 눈에 띄지 않는 종류의 메서드를 나타낸다. 프라이빗 메서드는 수신자가 생략되어 있을 경우에만 호출할 수 있다. 반대로 말하면 수신자가 명시적으로 정해져 있다면 호출할 수 없다.
>
> - Trip클래스 내부에서 private인 fun_factor 메서드가 있다면, 클래스 내부에서 self.fun_factor나 클래스 외부에서 a_trip.fun_factor라고 메세지를 전송할 수 없다. 반면, Trip클래스 또는 Trip클래스의 자식클래스 인스턴스는 fun_factor라고 메서드를 전송할 수 있으며, 수신자는 없지만, self가 생략된 형태로 메서드를 전송할 수 있다.
>
> protected 키워드 : **불안정한 메서드**를 나타낸다. 하지만 그 노출 정도에서 private 키워드와 차이를 보인다. protected 메서드는 **수신자가 self이거나 같은 클래스의 인스턴스 또는 self의 자식 클래스의 인스턴스** 일 경우에 한해서 명시적인 수신자를 지정할 수 있다.
>
> - Trip의 fun_factor 메서드가 protected라면 언제나 self.fun_factor의 형태로 메세지를 전송하는 것이 좋다. 또는 a_trip.fun_factor라는 형태로 전송해도 좋다.

루비는 이 세가지 키워드뿐 아니라 private와 protected가 강제하는 노출 정도의 제약을 피해갈 수 있는 방법도 제공한다. 때문에 이 이슈는 좀 더 복잡해진다. 클래스의 사용자는 그 최초 선언이 어떠했는지와 상관없이 모든 메서드를 public으로 재정의 할 수 있다. 즉, 키워드가 만능은 아니라는 것이다.

키워드들을 사용하는 의미를 정리해보면,

- 오늘의 내가 미래의 프로그래머보다 더 나은 정보를 알고 있다고 믿는다.
- 내가 지금 불안정한 메서드라고 생각한 것을 미래의 프로그래머가 실수로 사용하지 못하게 만들어야 한다고 생각한다.

하지만 미래는 알 수 없다. 숙련된 프로그래머는 키워드를 사용하기보다는, 주석이나 메서드 이름에 차별을 주어 퍼블릭 인터페이스와 프라이빗 인터페이스를 관리한다. (예를 들면, 루비는 프라이빗 메서드에 `_`로 시작하는 이름을 지어준다.)

어떤 방식으로 처리하든 메서드의 안정성에 대한 정보를 전달해 주었다면 우리는 미래에 대한 의무를 다한 것이다.

#### 4.4.2. 다른 사람의 퍼블릭 인터페이스 존중하기

당연하다. 다른 클래스와 협업할 때는 그 클래스의 퍼블릭 인터페이스만 사용하도록 해야한다.

#### 4.4.3. 프라이빗 인터페이스에 의존할 때 주의하기

프라이빗 인터페이스에 의존할 수 밖에 없을 때는 3장에서 설명했던 의존성 격리(?)를 할 필요가 있다.어쩔수 없이 프라이빗으로 사용할 수 밖에 없더라도, 이 메서드를 어플리케이션 이곳저곳에서 사용하지 않도록 만들어야 한다.

#### 4.4.4. 맥락 최소화 시키기

퍼블릭 인터페이스를 구성할 떄는 다른 객체들과의 연결되어 있는 맥락을 최소화 할 수 있는 방향을 염두에 두어야 한다. How와 What을 구분하고, 송신자가 원하는 것을 클래스에 요청할 때 우리가 작성한 클래스의 구현과 작동방식에 대해 몰라도 되는 퍼블릭 메서드를 작성하자.

반대로 퍼블릭 인터페이스가 없거나 퍼블릭 인터페이스가 잘못 정의된 클래스가 시키는 대로 따르지 말자.

### 4.5. 데메테르 원칙

이제 책임(2장), 의존성(3장), 인터페이스(4장)에 대해 배웠고, 데메테르의 원칙에 대해 알아보자.

데메테르의 원칙(LoD)은 객체들의 결합을 낮추면서 코딩을 할 수 있도록 만들어주는 규칙이다. 낮은 결합도는 중요하지만, 디자인의 여러 면중 하나이다. 결합도를 낮추는 것과 상반되는 디자인 이슈가 있을 때 둘 사이에 잘 조율하는 능력도 중요하다. 데메테르 원칙을 어겨도 문제가 되지 않는 경우도 있지만, 어떤 경우는 퍼블릭 인터페이스를 잘 정의하지 못했다는 반증이 되기도한다.

#### 4.5.1. 데메테르 원칙의 정의

데메테르 원칙은 메서드가 메세지를 전송하지 말 것을 요구한다. 메세지를 전달받은 객체가 곧 바로 다른 타입의 객체에 메세지를 전달하는 것을 금지한다. 즉, 점을 하나만 사용하라는 의미이다.

만약 Trip의 depart메서드가 아래와 같은 코드를 포함하고 있다고 생각해보자.

​	customer.bicycle.wheel.tire

​	customer.bicycle.wheel.rotate

​	hash.keys.sort.join(', ')

각 메세지는 점을 여러개 포함하고 있다. 이 연쇄를 고장난 기차에 비유하곤 한다.

#### 4.5.2. 위반의 결과

2창에서 투명성,적절성,사용가능성,모범성 (TRUE)를 제시했다. 위 3개의 메세지는 TRUE의 관점에서 봐도 부적절하다.

적절성 : wheel이 tire나 rotate를 변경한다면 depart도 변경되어야 한다. 불필요한 영향력

투명성 : tire나 rotate를 수정하면 depart가 오작동을 할 수 있다. Trip과 wheel은 멀리 떨어져 있고 서로 연관되어 보이지 않기 때문에 이 오작동은 예상하기 쉽지 않다.

사용성 : wheel과 tire를 가지고 있는 bicycle은 있지만, bicycle을 가지고 있는 customer는 없다면 Trip을 사용할 수 없다. Trip을 사용하려면 이런 맥락을 고려해야 하기에 사용하기 쉽지 않다.

모법성 : 비슷한 패턴의 메세지를 다른 프로그램에서도 계속 생산할 것이기 때문에 전혀 모범적이지 않다.

처음 두 개의 메세지 연쇄는 거의 같은 것이다. 둘 사이의 차이점은 전자가 먼 곳에 있는 어트리뷰트(tire)를 가져오고 후자는 행동(rotate)를 호출한다는 것이다. 어트리뷰트를 반환하는 메세지 연쇄에 데메테르의 원칙을 얼마나 강제할 수 있는가에 의견이 분분하다. 지금과 같은 상황에서는 개체들의 연쇄를 타고 어트리뷰트에 접근하는 것이 효율적일 수 있다. 데메테르의 원칙을 따르는 비용과 미래의 수정 비용을 저울질해 볼 수있다.

메세지 연쇄를 통해 접근한 어트리뷰트의 값을 변경하지 않는다는 전제 아래서 이런 접근은 괜찮다. 만약, depart가 custom.bicycle.wheel.trie의 결과를 변경하려는 의도를 가지고 메세지를 전송한다면 이건 단순히 어트리뷰트를 가져오는 것이 아니다. 이건 Wheel에 속해야 하는 행동을 구현하고 잇는 것이다. 이런경우 두 메세지가 같아진다. 중간에 여러 객체를 끼고 있는 메세지 연쇄를 통해 멀리있는 행동에 접근하고 있는 것이다. 이런 방식의 코딩은 치러야 할 대가가 크며, 데메테르의 원칙을 따라야한다.

세 번째 메세지 연쇄인 `hash.keys.sort.join(', ')`는 문제가 없다. 이 코드는 데메테르의 원칙을 위반하지 않는다. **코드가 몇개의 점을 가지고 있는지가 아니라, 중간에 낀 객체들의 타입을 체크하면서 코드를 평가하자.**

- hash.keys는 Enumerable을 반환함
- hash.keys.sort 역시  Enumerable을 반환함
-  hash.keys.sort.join은 String을 반환함

최종적으로 String의 Enumerable을 반환한다는 점을 생각하면 중간에 낀 모든 객체들은 같은 타입을 반환하고 있다. 데메테르의 원칙을 위반했다고 보기 어렵다. 이 코드에서는 점을 제거하면 오히려 유지보수의 비용은 늘어날 것이다.

데메테르의 원칙은 적용하기에 애매한 경우가 많다. 이 원칙은 완벽한 것이 아니며 단지 우리의 디자인을 돕기 위해 존재한다.

#### 4.5.3. 원칙 위반을 피하기

고장난 기차형태의 코드를 피하기 위한 방법 중 하나는 `위임`을 사용하는 방법이다. 객체지향 프로그래밍에서 메세지를 위임한다는 뜻은 메세지를 다른 객체에 넘긴다는 의미이다. 종종 Wrapper Method를 통해서 메세지 연쇄에 포함되어 있는 지식을 캡슐화 하거나 감춘다.

메세지를 위임하기 위한 방법은 여러가지 있다. 루비는 `delegate.rb`와 `forwardable.rb`를 가지고 있고 루비온레일스는 `delegate`메서드를 제공한다. 이들은 모두 self에게 전송된 메세지를 가로채서 다른 객체에게 쉽게 전달할 수 있게 해준다.

위임은 데메테르의 원칙을 위반했다는 표시를 지워버리기 때문에 데메테르의 원칙을 따르지만, 주의해서 사용해야 한다. 위임의 결과는 원칙을 문자 그대로 따르고 진짜 이유는 무시하고 있을 수 있다. 위임을 통해 코드의 강한 결합을 감추는 것은 단순히 감추는 것일 뿐 이지 결합을 낮추는 것이 아니다.

#### 4.5.4. 데메테르의 원칙 듣기

데메테르의 원칙이 하려는 말은 "위임을 많이 사용"하라는 것이 아니다. 메세지 연쇄는 잘 알고있는 객체의 퍼블릭 인터페이스에 익숙하기 때문에 멀리 있는 행동에 접근하기 위해 만들어 지곤한다.

depart는 어떻게 객체들을 타고가면 원하는 것에 도달할 수 있는지 알고있다. 결국 depart메서드는 객체들의 전반적인 구조와 강하게 결합되어 있다는 것이다.

가장 분명한 문제점은 메세지 연쇄의 한 부분을 변경하게되면 Trip도 변경해야하는 위험이 있다는 것이다. 더 심각한 문제는 이 객체들의 연쇄를 depart메서드에서 알고 있기 때문에, 객체들의 매우 구체적인 구현에 얽혀 있기 때문에 depart를 다른 맬락에서 전혀 사용할 수 없다.

Customer는 언제나 Bicycle을 가져야하고, Bicycle은 rotate할 줄 아는 Wheel을 가지고 있어야 한다. depart메서드가 customer로 부터 **어떤 것**을 원하는지 판단하면서 코드를 디자인 했다면 코드를 아래와 같이 바꿀 수 있을 것이다.

​	customer.ride

메세지 관점에서 보면 당연한 것이다. ride메서드는 세부적인 구현을 Trip으로부터 감추고 맥락과 의존성을 모두 줄여준다. 디자인이 눈에 띄게 좋아진다.

데메테르의 원칙을 위반했기 때문에 만들어지는 고장난 기차는 어딘가에 **퍼블릭 인터페이스가 없는 객체**가 있다고 말해준다. 데메테르의 원칙에 귀 기울인다는 것은 메세지 기반의 관점을 취한다는 것이고, 그렇게 한다면 새로운 메세지를 발견할 수 있게 되고 그 메세지가 퍼블릭 인터페이스가 된다. 더 나아가 이 퍼블릭 인터페이스를 정의할 새로운 발견할 수 있다.

반면, 도메인 객체의 족쇄를 벗어버리지 못하면 (클래스 관점으로 문제를 해결하려고 한다면) 도메인 객체들의 퍼블릭 인터페이스만을 이용해 기다란 메세지 연쇄 코드를 작성하게 될 것이다.

## 5. Reducing Costs with Duck Typing

객체지향 디자인의 목표는 코드의 수정 비용을 줄이는 것이다. 디자인의 핵심은 메세지이며, 잘 정의된 퍼블릭 인터페이스를 구축하는 것이 왜 중요한지 배웠다. 이 둘을 종합한 디자인 테크닉을 이용하여 더 좋은 효과를 낼 수 있다.

그 기술의 이름은 duck typing(오리 타입)이다. 오리 타입은 특정 클래스에 종속되지 않은 퍼블릭 인터페이스이다. 여러 클래스를 가로지르는 이러한 인터페이스는 **클래스에 대한 값비싼 의존**을 **메세지에 대한 부드로운 의존**으로 대치한다. 즉, 어플리케이션을 유연하게 만들어 준다.

오리 타입 객체는 객체의 클래스보다는 행동에 의해 규정된다. (오리 타입이라고 불리는 이유도 여기서 나왔다. 객체가 오리처럼 걷고, 꽥꽥된다면 이 객체는 오리가 맞다.)

### 5.1. 오리타입 이해하기

프로그래밍 언어들은 '타입'이라는 용어를 통해 변수의 내용물이 어떤 종류인지 묘사한다. 절차적 언어는 보통 데이터의 종류를 표시하기 위해 고정된 타입들을 제공한다. 최소한 문자열, 숫자, 배열을 저장하기 위한 타입을 제공한다. 변수의 종류 또는 타입을 알기 때문에 그 내용물들을 어떻게 다루어야 하는지 예측할 수 있다.

루비에서 객체들의 타입을 예상할 수 있는 이유는 객체들의 퍼블릭 인터페이스를 믿기 때문이다. 즉, 한 객체가 다른 객체의 타입을 알고 있다면 대상 객체가 반응할 수 있는 메세지를 알고 있는 것이다.

당연한 말이지만, Mechanic클래스의 인스턴스는 Mechnic의 퍼블릭 인터페이스를 전부 가지고 있다. Mechanic의 인스턴스를 사용하는 객체는 이 인스턴스 자체가 Mechanic인 것처럼 취급할 수 있다. 어떤 인터스턴스가 클래스의 퍼블릭 인터페이스를 표현하고 있다는 것은 인스턴스의 본질적인 특성이다.

그러나, 어떤 객체가 하나의 인터페이스에만 반응할 수 있다고 생각할 필요는 없다. 루비 객체는 서로 다른 여러개의 인터페이스를 구현할 수 있다.

객체의 타입은 객체를 사용하는 사람의 쓰임에 따라 달라질 수 있다. 객체를 사용하는 사람은 객체의 클래스가 무엇인지 신경쓸 필요가 없으며 신경을 써서도 안 된다. 클래스는 객체가 퍼블릭 인터페이스를 갖추기 위한 하나의 수단에 불과하다. 객체가 자신의 클래스를 통해 얻는 퍼블릭 인터페이스는 객체가 포함하는 여러개의 퍼블릭 인터페이스 중 하나일 수 있다.  어플리케이션은 특정 클래스에 종속되지 않은 퍼블릭 인터페이스를 정의할 수 있다. 이런 인터페이스는 여러 클래스들 사이를 관통한다. 객체를 사용하는 사람은 모든 객체가 자신이 구현하고 있는 어떤 인터페이스 또는 모든 인터페이스에 맞춰 행동할거라 믿어도 된다. 중요한 것은 객체가 무엇인가 보다 어떻게 행동하는가 이다.

모든 상황에서 모든 객체가 예상한대로 움직인다고 믿을 수 있다면, 디자인은 무한한 가능성을 가지고 있는 것이다. 하지만, 반대로 난해한 혼란을 가중시킬 수 있다.

이러한 유연성을 현명하게 사용하기 위해서, 클래스를 가로지르는 타입(acroos-class type)을 알아야 한다. 클래스를 가로지르는 타입, 즉 오리 타입은 명시적이고 잘 정리된 계약서와 같은 퍼블릭 인터페이스를 가지고 있어야 한다.

#### 5.1.1. 오리 타입 무시하기

아래 코드에서 Trip의 prepare메서드는 자신이 인자로 받은 mechanic객체에 prepare_bicycles 메세지를 전송한다. 여기서, Mechanic클래스를 참조하는 객체가 없다는 점에 주목하자. 인자의 이름은 mechanic이지만, 사실은 Mechanic의 인스턴스가 아니더라도 인자로 받을 수 있다.

```ruby
class Trip
    attr_reader :bicycles, :customers, :vehicle

    # this 'mechanic' argument could be of any class
    def prepare(mechanic)
        mechanic.prepare_bicycles(bicycles)
    end

    # ...
end

# if you happen to pass an instance of *this* class,
# it works
class Mechanic
    def prepare_bicycles(bicycles)
        bicycles.each {|bicycle| prepare_bicycle(bicycle)}
    end

    def prepare_bicycle(bicycle)
        #...
    end
end
```

아래 그림은 위 코드와 상응하는 다이어 그램이다.

![image](https://user-images.githubusercontent.com/53181778/85971958-907ffb80-ba09-11ea-9ab1-7bbfc90565ce.png)

preapre 메서드 자체는 Mechanic 클래스에 의존하고 있진 않다. 하지만, prepare_bicycles라는 메서드에 반응할 수 잇는 객체를 받아야 한다는 것에 의존하고 있다. 이 의존성은 쉽게 무시될 수 있지만, 의존성은 분명히 존재한다. Trip의 prepare메서드는 여행준비를 담당하는 객체를 인자로 받았다고 확신하고 있다.

#### 5.1.2. 문제를 조합하기

4장에서 보았던 요구사항이 변경되었다고 생각해보자. 여행 준비에 정비공 이외에 여행 보조인과 운전사도 필요해졌다.

TripCoordinator와 Driver클래스를 만들고 각각에게 어울리는 책임을 지워준다. 그리고 Trip의 prepare 메서드가 인자로 넘어온 객체에게 알맞은 행동을 호출하도록 수정한다.

아래 코드는 이런 수정이 반영된 결과이다. 새로 만든 TripCoordinator와 Driver 클래스는 간단하고 괜찮아 보인다. 하지만, Trip의 prepare 메서드는 문제가 있어 보인다. prepare메서드는 세 개의 서로 다른 클래스를 참조하고 있고 각 클래스가 구현하는 메서드의 이름을 정확히 알고 있다. 의존성이 높아졌다. 코드의 수정에 대한 비용이 상승한것이다.

```ruby
#Trip preparation becomes more complicated
class Trip
    attr_reader :bicycles, :customers, :vehicle

    def prepare(preparers)
        preparers.each {|preparer|
            case preparer
            when Mechanic
                preparer.prepare_bicycles(bicycles)
            when TripCoordinator
                preparer.buy_food(customers)
            when Driver
                preparer.gas_up(vehicle)
                preparer.fill_water_tank(vehicle)
            end
            }
    end
end

# when you introduce TripCoordinator and Driver
class TripCoordinator
    def buy_food(customers)
        # ...
    end
end

class Driver
    def gas_up(vehicle)
        #...
    end

    def fill_water_tank(vehicle)
        #...
    end
end
```

이러한 코드는 중요한 메세지를 파악하지 못했을 때 나온다. 클래스 기반 관점이 자연스럽게 반전한 모양새이다.

코드가 이런 형태로 발전하는 과정을 살펴보자.

1. mechanic이라는 인자를 받고, prepare_bicycles이라는 메세지를 보내는 메서드로 생각을 한다.
2. prepare의 인자에 새로운 객체가 들어오게 되고, prepar_bicycles를 이해하지 못한다면, 프로그래머는 해당 객체가 이해할 수 있는 메세지를 찾는다.
3. TripCoordinator와 Driver 클래스의 퍼블릭 인터페이스를 살펴보고 buy_food,  gas_up, fill_water_tank와 같은 메스드를 발견
4. 그에 맞게 prepare 메서드를 수정한다.가장 명확한 방법인 그 메세지를 그대로 전송해버린다.

4번의 과정에서 문제가 발생한다. 인자들은 모두 다른 클래스의 인스턴스이며 다른 메서드를 구현하고 있다. 즉, 인스턴스를 알아야 적절한 메서드로 매칭이 가능하다. 여기서 의존성이 폭발해버린다.

위 코드의 의존성

- prepare메서드는 다른 사람은 알 수 없는 특정한 클래스에 기대고 있다.

- 클래스의 명시적인 이름에 기대고 있다.
- 클래스가 이해하는 메세지의 이름이 무엇인지, 그리고 이 메세지와 함께 전송해야 하는 인자가 무엇인지도 알고 있다.

만약, 새로운 타입의 객체를 더 추가로 받게 된다면, when 절은 계속해서 추가될 것이며 새로운 메세지도 추가될 것이다. 즉, 이런 코딩 스타일이 계속해서 재생산된다.

위 코드를 시컨스 다이어그램으로 표현하면 아래와 같다. 이 시컨스 다이어그램은 딱 보아도 복잡해 보인다. 이 복장성은 경고이다.

![image](https://user-images.githubusercontent.com/53181778/85973709-a217d200-ba0e-11ea-9cbd-3e1e9186f66c.png)

#### 5.1.3. 오리 타입 찾기

위와 같은 의존성을 제거하기 위해서 Trip의 prepare 메서드는 하나의 목적을 갖고 있기 때문에 prepare의 인자 역시 이 목표를 이루기 위해 협업하는 객체라는 사실을 알아야 한다. 그 객체들이 각각 어떤일을 하는지는 중요하지 않다.

인자의 클래스가 무엇을 할줄 아는지에 대해 알고 있는 것이 오히려 방해가 된다. 우리는 **prepare가 무엇을 원하는지에 대해 집중**해야 한다.

prepare의 관점에서 생각하면 문제는 매우 명확해진다. 인자들은 여행 준비에 동참하러 온 것 뿐이다. 인자가 주어진 작업을 제대로 할 줄 안다고 prepare가 믿기만 하면 디자인은 훨씬 간단해 진다.

아래 다이어그램에서 prepare메서드는 인자의 클래스에게 아무것도 기대하지 않는다. 단지, 이 인자가 Preparer(여행을 준비하는 객체)라고 기대할 뿐이다.

![image](https://user-images.githubusercontent.com/53181778/85974495-90372e80-ba10-11ea-8c4e-f9e0bbb53dd9.png)

기존의 클래스로부터 자유로워 졌고, 오리 타입을 만들어 냈다. 다음 문제인 prepare메서드가 Preparer에게 어떤 메세지를 전송할지 생각하는 것이다.

![image](https://user-images.githubusercontent.com/53181778/85975041-fc666200-ba11-11ea-9410-c936a3f83974.png)

위 다이어 그램에서는 새로운 메세지가 추가되었다. Trip의 prepare메서드는 자신의 모든 인자가 Preparer이고 prepare_tirp을 이해할 수 있기를 바란다.

Preparer란 구체적으로 존재하지 않고, 추상적이다. 즉, 실존하고 있지않은 디자인에 의해 만들어진 허구에 불과하다.
prepare_trip을 구현하고 있는 객체가 곧 Preparer이다. 반대로 이해하면, Prepare와 협업하는 객체들이 Preparer의 퍼블릭 인터페이스를 구현하고 있다고 봐야한다. 이 추상화를 이해하면 코드를 수정하는 것은 쉽다. Mechanic, TripCoordinator, Driver는 모두 Preparer처럼 행동해야 한다. 즉, prepare_trip을 구현하고 있어야 한다.

아래 코드는 새로운 디자인을 적용한 코드이다.

```ruby
# Trip preparation becomes easier
class Trip
    attr_reader :bicycles, :customers, :vehicle

    def prepare(preparers)
        preparers.each {|preparer|
            preparer.prepare_trip(self)}
    end
end

# when every preparer is a Duck
# that responds to ‘prepare_trip’
class Mechanic
    def prepare_trip(trip)
        trip.bicycles.each {|bicycle|
            prepare_bicycle(bicycle)}
    end

    # ...
end

class TripCoordinator
    def prepare_trip(trip)
        buy_food(trip.customers)
    end

    # ...
end

class Driver
    def prepare_trip(trip)
        vehicle = trip.vehicle
        gas_up(vehicle)
        fill_water_tank(vehicle)
    end
    # ...
end
```

#### 5.1.4. 오리 타입의 중요성

새로운 코드에는 나름의 대칭성이 있다. 이 대칭은 제대로된 디자인을 보여주는 대칭이다. 오리 타입으로 얻을 수 있는 이점은 이것 외에도 또 있다.

처음 코드에서 prepare 메서드는 구체적인 클래스에 의존했다면 마지막 코드는 오리타입에 의존한다. 첫 코드에서는 구체적이기 때문에 이해하기는 쉽지만, 확장하기에는 위험하다. 마지막 오리 타입 코드는 추상적이지만, 손쉬운 확장성을 제공한다.

오리 타입을 찾았기 떄문에 기존 코드를 수정하지 않고도 어플리케이션에서 새로운 행동을 이끌어낼 수 있다.

오리 타입을 사용하면 코드는 추상적으로 되면서 숨겨진 클래스를 파악하는데 더 많은 노력이 들기도 한다.

Polymorphism

> 객체지향 디자인에서 폴리몰피즘이라는 개념은 자주사용되지만, 단어의 활용법은 그 뜻을 충분히 전달해주지 못한다.
>
> 객체지향 프로그래멩에서 사용하는 폴리몰피즘의 의미는 **같은 메세지에 반응할 수 있는 여려 객체의 능력**을 의미한다. 메세지의 송신자는 수신자의 클래스를 신경 쓸 필요가 없다. 수신자는 주어진 행동에 걸맞는 자신만의 행동을 제공한다. 즉, 하나의 메세지(poly)가 여러개의 형태(morphs)를 갖게 된다.
>
> 폴리몰피즘을 구현하기 위한 방법은 여러가지가 있다. 오리타입도 그중 하나이다. 상속이나 루비의 모듈을 이용하여 행동을 공유하는 방법도 있다.
>
> 폴리모픽 메서드는 암묵적인 합의를 중시한다. 송신자의 관점에서 보면 이들은 상호 대체적이고, 폴리모픽 메서드를 구현하고 있는 모든 객체는 서로가 서로를 대체할 수 있다. 송신자는 이러한 대체에 대해서는 알 필요도 없다.

### 5.2. 오리 타입에 의존하는 코드 작성하기

오리 타입을 사용하기 위해, 클래스를 가로지르는 인터페이스를 사용하면 좋은 지점을 발견하는 능력부터 갖추어야 한다. 오리 타입의 구현 자체는 어렵지 않다. 어려운 부분은 오리타입의 필요성을 인지하고 인터페이스를 추상화하는 부분이다.

#### 5.2.1. 숨겨진 오리파일 인지하기

코드 속에는 미처 파악하지 못한 오리 타입이 숨겨져 있는 경우가 종종 있다. 몇 가지 일반적인 코딩 패턴은 오리 타입이 숨겨져 있다는 사실을 알려준다.

아래와 같은 경우에 오리타입을 적용할 수 있다.

- 클래스의 종류에 따라 스위치되는 case 문
- kind_of? 와 is_a?
- responds_to?

3가지의 경우에 대해서 살펴보자.

1. **클래스에 따라 변경되는 case 문**

   오리 타입이 숨겨져 있다고 알려주는 가장 일반적이고 명확한 패턴이다. 즉, 객체의 클래스 이름에 따라 다르게 작동하는 case 구문이다.

   ```ruby
   class Trip
       attr_reader :bicycles, :customers, :vehicle
       def prepare(preparers)
           preparers.each {|preparer|
               case preparer
               when Mechanic
                   preparer.prepare_bicycles(bicycles)
               when TripCoordinator
                   preparer.buy_food(customers)
               when Driver
                   preparer.gas_up(vehicle)
                   preparer.fill_water_tank(vehicle)
               end
               }
       end
   end
   ```

   이 패턴은 각 객체가 무언가를 공유하고 있다는 사실을 알려준다. prepare가 인자로부터얻고자 하는 것은 무엇인지 스스로에게 물어보면 답을 찾을 수 있다. 이 질문에 대한 답변이 우리가 전송해야 하는 메세지를 알려준다. 그리고 이 메세지가 숨어 있는 오리 타입을 찾아내기 위한 출발점이 된다.

   여기서 prepare 메서드는 자신의 인자가 여행을 준비하기를 바라고 있다. 때문에 오리 타입 prepare의 퍼블릭 인터페이스는 prepare_type을 가져야한다.

2. **kind_of? 와 is_a?**

   객체의 클래스를 확인할 수 있는 방법은 여러가지가 있다. 위의 case 구문은 그중 하나이다. kind_of?와 is_a? 메세지 역시 클래스를 확인해준다. 위의 코드를 아래와 같이 바꿀 수 있다.

   ```ruby
   if preparer.kind_of?(Mechanic)
       preparer.prepare_bicycles(bicycle)
   elsif preparer.kind_of?(TripCoordinator)
       preparer.buy_food(customers)
   elsif preparer.kind_of?(Driver)
       preparer.gas_up(vehicle)
       preparer.fill_water_tank(vehicle)
   end
   ```

3. **responds_to?**

   오리 타입에 익숙하지 않은 프로그래머라면, 클래스 이름에 의존하지 말아야한다고 생각하면서, responds_to?를 사용하려 할 수 있다.

   ```ruby
   if preparer.responds_to?(:prepare_bicycles)
       preparer.prepare_bicycles(bicycle)
   elsif preparer.responds_to?(:buy_food)
       preparer.buy_food(customers)
   elsif preparer.responds_to?(:gas_up)
       preparer.gas_up(vehicle)
       preparer.fill_water_tank(vehicle)
   end
   ```

   의존성이 조금 줄어들기는 했지만, 여전히 클래스에 의존하고 있다. 클래스를 명시적으로 참조하지는 않았지만, 간접적으로 참조하고 있다.

#### 5.2.2. 오리 타입 신뢰하기

협업하는 객체에 대한 믿음을 가진다는 것은 협업 객체에 대해 많이 알 필요가 없다는 것이다.

case문이나, kind_of 등을 사용한다면, 아직 퍼블릭 인터페이스를 발굴해내지 못한 어떤 객체가 있다는 뜻이다. 이 객체가 구체적인 클래스가 아니라 오리타입이라는 사실은 전혀 중요하지 않다. 중요한것은 발굴하지 못한 인터페이스가 있다는 점이지, 인터페이스를 구현하고 있는 클래스가 아니다.

일단 오리 타입을 머릿속에 그려낼 수 있다면, 그 인터페이스를 정의하자. 이 인터페이스를 필요로 하는 곳에 인터페이스를 구현하고 인터페이스를 구현하고 있는 객체들이 제대로 행동하리라 믿어야 한다.

#### 5.2.3. 오리 타입 문서작성

가장 단순한 형태의 오리 타입은 퍼블릭 인터페이스에 대한 합의만으로 존재한다. 여러 클래스가 prepare_trip을 구현하고 있다. 덕분에 클래스를 Preparer처럼 취급할 수 있다.

하지만, 코드의 관점에서 Preparer 오리 타입은 가상의 것에 불과하다. 그렇기 때문에 코드 속에서 오리 타입을 잘 보여주기 위해 문서를 작성하는 것이 좋다. 다해히도, 좋은 테스트는 그 자체로 최고의 문서가 되기도 한다. 이 테스트에 대해서는 9장에서 살펴보자.

#### 5.2.4. 오리타입 사이에서 코드 공유하기

Preparer 오리 타입은 모두 자신의 클래스에 필요한 행동만 구현하고 있다. Mechanic, Driver, TripCoordinator 모두 각자의 prepare_trip을 구현하고 있다. 오리 타입이 공유하고 있는 것은 이 메서드 시그니처 뿐이다. 인터페이스만을 공유하지, 그 세부 구현은 공유하지 않는다.

하지만, 종종 오리타입을 사용하다 보면 오리 타입 클래스끼리는 종종 같은 행동을 공유하는 경우가 존재한다. 코드를 공유하는 오리 타입을 작성하는 방법은 7장에서 다룬다.

#### 5.2.5. 현명하게 오리타입 선택하기

아래 코드는 rails에서 가져온 코드이다. (active_record/relations/finder_methods.rb)

입력 값을 어떻게 처리해야 할지 결정하기 위해 클래스를 확인하고 있다. 지금까지의 내용과는 반대되는 방식이다.

첫 번째 메서드는 인자의 클래스에 기반해서 어떻게 행동해야 할지 결정하고 있다.

수신된 객체의 클래스를 확인하고 이 결과에 따라 어떤 메세지를 전송할지 결정하는 방식이다.

```ruby
# A convenience wrapper for <tt>find(:first, *args)</tt>.
# You can pass in all the same arguments to this
# method as you can to <tt>find(:first)</tt>.
def first(*args)
    if args.any?
        if args.first.kind_of?(Integer) ||
                (loaded? && !args.first.kind_of?(Hash))
            to_a.first(*args)
        else
            apply_finder_options(args.first).first
        end
    else
        find_first
    end
end
```

이 코드와 이전 코드의 차이점은 코드가 확인하고 있는 클래스의 안정성이다. 이 예시에서는 루비의 코어 클래스인 Integer와 Hash에 의존하고 있기 떄문에 수정될 가능성이 매우 낮다. 이 코드에 오리타입이 숨겨져 있을 수 있지만, 이 오리 타입을 찾아 구현한다고 해서 어플리케이션의 유지보수 비용을 줄여주지는 않을 것이다.

여기서 알 수 있듯이 오리타입을 만들지 말지는 프로그래머에게 달려있는 문제이다. 이 코드에서 오리타입을 구현하려면 기본 클래스를 수정해야 하는데, 기본 클래스를 수정하는 방법을 몽키패치라 한다. 몽키패치는 루비의 멋진 기능 중 하나이지만, 어설프게 건드렸다가는 큰 위험이 따른다.

### 5.3. 오리 타입의 무서움을 정복하기

동적 타입과 정적 타입을 다룰 시간이 왔다. 정적언어와 오리 타입간의 관계에 대해서 다루어 보자.

#### 5.3.1. 정적 타입으로 오리 타입 거부하기

타입을 변수 내용물의 카테고리라고 정의해보자. 프로그래밍 언어는 정적 타입이거나 동적 타입언어다. 대부분의 정적 타입 언어는 변수와 메서드 파라미터의 타입을 명시적으로 선언할 것을 요구한다. 동적 타입 언어에서는 이런 선언을 생략할 수 있다. 별도의 선언 없이도 어떤 변수에든 아무 값이나 넣을 수 있고 어떤 메서드에든 아무 인자나 넘길 수 있다.

누군가는 동적 타입을 사용하는데 불편함을 느낀다. 이는 동적 언어를 사용해본 경험이 부족하기 때문이다. 다른 일부는 정적 타입이 보다 안정적이라고 믿기 때문에 불편해한다.

동적 언어를 두렵게 느끼는 프로그래머들은 객체의 클래스를 확인하는 습관이 있다. 이런 과정이 동적 언어의 힘을 반감시키며 오리 타입을 사용할 수 없도록 만든다.

프로그래머가 인자의 클래스를 알고 있어야만 제대로 작동하는 메서드, 이런 메서드는 새로운 클래스가 등장했을 때 타입 에러를 발생시키게 된다. 정적 타입 언어를 밎는 프로그래머들은 이 실패가 타입을 확인해야 하는 이유라고 믿는다. 타입 확인을 추가하면 할수록 코드는 점점 덜 유연해지고 점점 더 클래스에 의존하게 된다. 그렇기 때문에 새로운 의존성과 타입 실패의 악순환에 빠져들게 된다. 이 문제에 대한 해결책은 모든 타입 확인을 지워버리는 것이라는 사실을 잘 믿지 못한다.

오리 타입은 이런 함정에서 빠져나올 수 있는 방법을 제시한다. 오리 타입이 클래스에 대한 의존성을 제거하면 타입 실패 역시 제거가 된다. 오리 타입은 코드가 안정적으로 의존할 수 있는 추상화를 드러내준다.

#### 5.3.2. 정적 타입 vs 동적 타입

동적 타입과 정적 타입을 비교해 보자.

동적 타입과 정적 타입은 모두 약속하는 바가 존재하며 나름의 이점과 단점을 가지고 있다.

**정적 타입 지지자들이 말하는 정적 타입 언어의 장점 :**

- 컴파일 시점에 컴파일러가 타입 에러를 잡아준다.
- 눈에 보이는 타입 정보가 문서의 역할을 한다.
- 컴파일된 코드는 빠르게 동작할 수 있도록 최적화 되어 있다.

이런 이점들은 각각에 상응하는 가정을 받아들일 경우에만 의미가 있다.

- 컴파일러가 타입을 확인하지 않으면 런타임 타입 에러가 발생할 것 이다.
- 프로그래머는 전체 맥락에서 객체의 타입을 추측할 수 없고, 코드를 이해하지 못할 것이다.
- 이러한 최적화를 거치지 않으면 어플리케이션이 너무 느릴 것이다.

**동적 타입 지지자들이 말하는 동적 타입 언어의 장점 :**

- 코드가 해석(interpreted)되면 동적으로 로드(load)될 수 있다. compile/make 과정을 거칠 필요가 없다.
- 소스 코드에 명시적인 타입 정보를 포함할 필요가 없다.
- 메타프로그래밍이 더 쉬워진다.

다음과 같은 가정을 받아들인다면 이런 이점은 더 강화된다.

- compile/make 과정이 없으면 전체 어플리케이션 개발이 보다 빠르게 진행된다.
- 타입을 선언하는 코드가 없으면 프로그래머가 코드를 이해하기 쉽다. 맥락 속에서 객체의 타입을 추측할 수 있다.
- 메타프로그래밍은 프로그래밍 언어의 바람직한 기능이다.

#### 5.3.3. 동적 타입 언어 받아들이기

특정 어플리케이션의 경우, 최적화된 정적 타입 코드가 동적 타입 구현보다 훨씬 나은 결과를 내린다는 사실은 의심할 여지가 없다. 동적 타입 어플리케이션이 충분한 성능을 낼 수 있을 만큼 최적화 되지 않는다면, 정적 타입만이 대안이된다.

타입 선언이 문서의 의미를 갖는다는 주장은 좀 더 주관적이다. 누군가에게는 거추장 스럽고 누군가에게는 혼란을 줄여준다.

메타프로그래밍(코드를 작성하는 코드 짜기)에 대해서는 프로그래머마다 확고한 입장을 가지고 있다. 그리고 개개인의 과거 경험이 메타프로그래밍에 대한 선호를 가른다. 간단한 코드 한 조각으로 커다란 문제를 해결한 경험이 있는 사람이면 평생토록 메타프로그램 지지자가 된다. 반면, 불명확하고 불필요한 메타프로그래밍 코드를 디버깅했던 경험이 있는 사람은 메타프로그램을 싫어할 것이다.

메타프로그래밍을 쉽게 할 수 있다는 점은 동적 타입이 왜 좋은지에 대한 근거가 된다.

남아 있는 두개의 이점은 정적 타입이 컴파일 할 때 타입을 확인한다는 것과 동적 타입은 compile/make 과정을 거치지 않는다는 점이다. 정적 타입 지지자들은 실행시점에 예기치 않은 타입에러를 방지하는 것이 필요할 뿐 아니라, 그 가치는 컴파일러를 제거하면서 얻을 수 있는 프로그래밍 효율을 훨씬 능가한다고 말하고 아래의 내용을 주장한다.

- 컴파일러는 의도치 않은 타입 에러를 확실히 잡아준다.
- 컴파일러가 없다면 타입에러는 분명 발생한다.

하지만, 동적 타입은 "컴파일러는 타입 에러를 방지해 줄 수도 없고, 방지해 주지도 않는다"라고 말한다.

컴파일러는 의도치 않은 타입 에러로 부터 우리를 구해주지 못한다. 변수의 타입 변형을 지원하는 모든 언어는 타입 에러의 위험에 노출되어 있다. 컴파일에서는 타입에러가 발생하지 않아도 런타임에서는 발생할 수 있다는 것이다.

더 나아가, 실제 개발 현장에서 컴파일러가 방지해 줄 수 있는 런타임 타입 에러는 거의 발생하지 않는다.

동적 타입은 컴파일 순간의 타입 확인과 상당한 수준의 개발 효율을 맞바꿀 수 있게 해준다. 오리 타입은 정적 타입 스타일의 코드에 의해서 만들어지게 된다. 오리 타입을 사용하기 위해서는 동적 타입을 받아들여야만 한다.

## 6. Acquiring Behavior Through Inheritance

지금까지는 최소한의 맥락을 가지며, 인터페이스가 분명하고, 재사용 가능한 의존성이 주입된 객체들을 만드는 법에 대해서 알아보았다.

객체지향 언어에서 코드를 공유할 수 있는 방법을 제공하는데, 바로 `상속`이라는 개념이다.

### 6.1. 고전적인 상속 이해하기

기본적인 상속의 개념은 '자동화된 메세지 전달 시스템'이다. 특정 객체가 이해할 수 없는 메세지를 전달 받았을 경우, 상속 시스템을 통해 메세지를 다른 객체에게 전달한다. 명시적으로 메세지를 위임하는 코드를 작성하지 않아도 두 객체 사이의 상속관계를 정의하면 자동으로 메세지를 전달하게 된다.

고전적인 상속 관계는 하위클래스를 만드는 것을 통해 정의된다. 메세지는 하위 클래스에서 상위클래스로 전달되며, 클래스의 위계관계가 공유되는 코드를 정의한다.

고전적인 상속이라는 의미가 낡은 방식의 상속을 의미하는 것이 아니다. 단지, 다른 방식의 상속 시스템과 구분하기 위해 이 책에서 사용하는 개념이다. 예를 들면, 자바스크립트는 프로토 상속을 가지고 있고, 루비는 7장에서 다루게 될 모듈을 통한 상속을 한다.

### 6.2. 상속을 사용하는 곳을 인지하기

상속은 어디에 필요할까? 여행회사에서 로드 바이크를 빌려준다고 생각해보자. 로드 바이크를 정비하기 위한 부품들을 정비공들이 가지고 다닌다. 자전거의 종류에 따라 부품을 추가로 가지고 다닐 수 있다.

#### 6.2.1. 구체적인 클래스에서 시작하기

아래 코드와 같이 Bicycle 클래스가 있으며 모든 로드 자전거는 이 클래스의 인스턴스이다.

자전거의 크기, 핸들바 테이프 색상, 타이어 크기, 체인 종류를 알아야 하며, 타이어와 체인은 꼭 필요한 부품이기 때문에 언제나 여분을 챙겨두어야 한다. 핸들바 테이프도 중요하기 떄문에 꼭 필요한 제품이다.

```ruby
class Bicycle
    attr_reader :size, :tape_color
    def initialize(args)
        @size = args[:size]
        @tape_color = args[:tape_color]
    end
    # every bike has the same defaults for
    # tire and chain size
    def spares
        {   chain: '10-speed',
            tire_size: '23',
            tape_color: tape_color  }
    end

    # Many other methods...
end

bike = Bicycle.new(
    size: 'M',
    tape_color: 'red' )

bike.size # -> 'M'
bike.spares
# -> {:tire_size => "23",
# :chain => "10-speed",
# :tape_color => "red"}
```

Bicycle 인스턴스는 spares, size, tape_color 메세지를 이해할 수 있고, mechanic은 각 Bicycles에게 어떤 예비 부품이 필요한지 spares 메세지를 통해 물어 볼 수 있다. spares 메서드가 코드 안에 기본값을 적어 놓긴 했지만, 이 경우에는 충분히 괜찮다.

여행회사에서 로드 바이크 이외에 마운틴 바이크까지 제공하기로 했다. 로드바이크와 공유되는 특성도 있고 아닌 특성도 존재하게 된다. 로드바이크에는 핸들바 테이프가 필요했다면, 마운틴 바이크는 서스펜션이 필요하다.

#### 6.2.2. 여러 타입 임베딩하기

자전거에 대한 대부분의 행동을 이미 구현해놓은 구체 클래스가 있기 때문에, 클래스에 코드를 조금 추가해서 수정하고 싶은 유혹에 빠질 수 있다.

아래 코드에서는 Bicycle 클래스를 수정해서 spares메서드가 로드와 마운틴 바이크 모드에 적용될 수 있도록 수정한다. 그리고 style, front_shock 그리고 rear_shock 변수와 액세서가 추가되었다.

코드가 이상하다고 느껴져도 걱정말자. 단순히 안티패턴을 보여주기 위한 예시이다. 안티패턴이란 문제가 없어보이지만, 실제로는 문제가 되는 패턴으로 더 좋은 방식으로 작성될 수 있는 패턴이다.

```ruby
class Bicycle
    attr_reader :style, :size, :tape_color,
    :front_shock, :rear_shock

    def initialize(args)
        @style = args[:style]
        @size = args[:size]
        @tape_color = args[:tape_color]
        @front_shock = args[:front_shock]
        @rear_shock = args[:rear_shock]
    end

    # checking "style" starts down a slippery slope
    def spares
        if style == :road
            { chain: '10-speed',
                tire_size: '23', # milimeters
                tape_color: tape_color }
        else
            { chain: '10-speed',
                tire_size: '2.1', # inches
                rear_shock: rear_shock }
        end
    end
end

bike = Bicycle.new(
    style: :mountain,
    size: 'S',
    front_shock: 'Manitou',
    rear_shock: 'Fox')

bike.spares
# -> {:tire_size => "2.1",
# :chain => "10-speed",
# :rear_shock => 'Fox'}
```

이 코드는 style변수가 가지고 있는 값을 확인하고 어떤 예비 부품이 필요한지 결정한다. 이런 방식으로 코드를 구성하면 좋지 않다. 그리고, spares, size, teap_color, front_shock 등의 퍼블릭 인터페이스를 제공하지만, 특정 바이크에만 존재하는 부품의 이름을 따서 만든 메서드는 신뢰 할 수 없다.

이 클래스는 여러 책임을 가지며, 수정요청에 노출되기 쉬운 코드를 가지고 있고, 그 자체로는 재사용이 불가능하다.

if문을 통해 어떤 종류인지 확인하는 작업을 통해 오리타입과 유사함을 알 수 있다. 오리 타입은 if문이 난발된 패턴을 통해 숨겨진 오리 타입을 찾을 수 있었다. 이번 장에서는 숨겨진 하위 클래스를 찾으면 된다.

#### 6.2.3. 숨겨진 타입 찾기

spares메서드의 if문 style이라는 이름의 변수에 따라 선택적으로 작동한다. style은 Bicycle을 서로 다른 두 종류로 구분한다. 이 두 종류는 상당 부분을 공유하지만, 다른 부분도 존재한다. 이러한 유형을 상속을 통해서 해결할 수 있다.

즉, 밀접하게 연관된 타입들이 같은 행동을 공유하지만, 특정한 관점에서는 다른 경우에는 상속을 이용하면 좋다.

#### 6.2.4. 상속 선택하기

모든 객체는 **메세지를 직접 처리**하거나 **다른 객체가 처리할 수 있도록 메세지를 넘긴다**. 상속은 두 객체 사이의 관계를 정의하며, 첫 번째 객체가 이해할 수 없는 메세지를 수신하면 다음 객체에게 자동으로 메세지를 전달하거나 위임한다.

상속은 종종 가계도를 연상시키지만, 사실은 조금 다르다. 자식은 두명의 부모를 가질 수 있고, 이러한 것을 허용하는 언어를 `다중상속`을 지원하는 언어라고 말한다. 그리고 이런 언어들로 디자인을 한다면, 가끔 흥미로운 이슈가 발생한다. 여러 부모를 가진 자식 객체가 자신이 이해할 수 없는 메세지를 받았을 때 어떤 부모에게 메세지를 넘겨야할지 정해야하며, 누구에게 우선권이 있는지 판단하는 문제이다.

그렇기 때문에 여러 객체지향 언어들은 이러한 문제를 피하기 위해 `단일상속`을 지원한다. 자식 클래스는 하나의 상위 클래스만 가질 수 있다는 것이다.

고전적 상속을 통한 메세지 전달은 행동을 공유하는 클래스들 사이에서 이루어지는 작업이다. **오리 타입은 클래스들을 가로지르기 때문에 공통의 행동을 공유하는 고전적 상속을 사용하지 않는다**. 오리 타입은 루비의 `모듈`을 이용해서 코드를 공유한다.(다음장에서 다룬다.)

상속된 객체가 이해할 수 없는 메세지를 받으면 루비는 자동으로 메세지를 상위클래스의 연쇄속으로 전달한다. (superclass chain) 상위 클래스를 따라 올라가면서 이 메세지를 처리할 수 있는 클래스를 찾는다. 아래 그림은 nil?메세지에 반응하는 것을 보여준다.

![image](https://user-images.githubusercontent.com/53181778/86082150-0485d680-bad2-11ea-9dd3-f85afe062375.png)

nil은 NilClass의 인스턴스라는 점을 알고있다면, nil은 다른 객체들 처럼 그저 하나의 객체에 불과하다. 루비는 nil?메서드를 두 군데서 구현하고 있다. 하나는 Nil 클래스 안에 있고, 다른 하나는 Object 클래스 안에서 구현헀다. 만약, NilClass 객체에 nil?메세지를 보낸다면 true를 반환할 것이고, 다른 객체에게 nil?메세지를 보냈다면, nil?메세지를 찾기위해 상위 클래스로 거쳐 올라가게 되고 결국 Object에 있는 nil? 메서드에서 false를 리턴하게 될 것이다.

이해하지 못하는 메세지는 상위클래스로 전달한다는 것은 하위클래스에서 상위클래스의 모든 행동을 가지고 있다는 것을 의미한다.

#### 6.2.5. 상속 관계 그리기

인터페이스를 만들기 위해 UML을 사용했던것 처럼 클래스 사이의 관계도를 도식화하기 위해 UML 클래스 다이어 그램을 사용할 수 있다.

다이어그램의 박스는 클래스를 의미한다. 화살표의 방향은 상위클래스를 향한다.

![image](https://user-images.githubusercontent.com/53181778/86082579-13b95400-bad3-11ea-8ebe-a683d2db04e1.png)

### 6.3. 상속의 오용

상속의 잘못된 사용의 예를 살펴보자. 아래 코드는 MountainBike라는 하위클래스를 만든 코드이다. initialize와 spares를 구현하고 있다. 이 두 메서드는 이미 Bicycle이 이미 구현하고 있기 때문에 Override되고 있다.

```ruby
class MountainBike < Bicycle
    attr_reader :front_shock, :rear_shock

    def initialize(args)
        @front_shock = args[:front_shock]
        @rear_shock = args[:rear_shock]
        super(args)
    end

    def spares
        super.merge(rear_shock: rear_shock)
    end
end
```

메서드 안에 sper를 전송하면 이 메세지를 상위 클래스의 연쇄 속으로 넘겨주게 된다. 즉, initialize 메서드가 super를 전송하면 상위클래스의 initialize 메서드를 실행시킨다.

하지만, 이는 여러가지 문제를 가지고 있다. 아래 예시에서 MountaionBike의 size와 spares를 요청하면 어떻게 되는지 살펴보자.

```ruby
mountain_bike = MountainBike.new(
    size: 'S',
    front_shock: 'Manitou',
    rear_shock: 'Fox')

mountain_bike.size # -> 'S'

mountain_bike.spares
# -> {:tire_size => "23", <- wrong!
# :chain => "10-speed",
# :tape_color => nil, <- not applicable
# :front_shock => 'Manitou',
# :rear_shock => "Fox"}
```

size에 대해서는 S로 잘 알려준다. 하지만, tpae_color가 마치 필요한듯 알려주고, tire_size에 대해서는 잘못된 정보를 알려준다. 그 이유는 Bicycle이 상위클래스의 용도로 설계된 것이 아닌 구체 클래스이기 때문이다. 로드바이크의 특성을 디폴트로 가지고 있기 때문인 것이다.

Bicycle에는 Mountain 자전거에는 필요하지도 않은 속성까지 포함되어 있는 것이다. 즉, 상위클래스가 잘못 되었다.

### 6.4. 추상화 찾기

처음 로드 바이크만 있을 때는 Bicycle이라는 이름이 문제가 되지 않았지만, 마운틴 바이크가 추가되면서 문제가 되었다.

하위클래스는 상위클래스의 특수한 형태(specialization)이다. MountainBike클래스는 Bicycle의 모든 행동을 갖추고 있고, 추가적인 행동을 가지고 있어야 한다. Bicycle과 협업할 수 있는 모든 객체는 MountainBike에 대해 아무것도 모른채 MountainBike와 협업할 수 있어야한다.

상속이 제대로 작동하기 위해서는 두 가지가 언제나 충족되어야 한다.

1. 모델링하는 객체들이 명백하게 `일반 - 특수`의 관계를 가지고 있어야 한다.
2. 올바른 코딩 기술을 사용해야 한다.

현재, Bicycle에 RoadBike라는 특수의 특성이 섞어있다. 이것을 분리해야 한다.

#### 6.4.1. 추상화 상위 클래스 만들기

![image](https://user-images.githubusercontent.com/53181778/86085888-449d8700-badb-11ea-9104-8d89c0553fd9.png)

Bicycle은 공통된 행동만, RoadBike와 MountainBike는 특수한 행동만 추가할 것이다.

이제 Bicycle은 추상클래스가 되었다. 의존성 관리에서 추상성은 모든 구체적인 것으로부터 분리된 것이라고 정의했었다. 새로 만들어진 Bicycle 클래스는 자전거의 모든 것을 정의하고 있지 않고, 공유하는 부분만을 정의한다. 즉, Bicycle은 더 이상 new메세지들 수신하는 대상이 아니라는 것이다. Bicycle는 더이상 하나의 완전한 자전거를 재현하고 있지 않기 때문이다.

어떤 프로그래밍 언어들은 추상 클래스라는 것을 명시적으로 하기 위해 abstrat와 같은 키워드를 제공하여 컴파일러가 잘못된 인스턴스의 생성을 막아주는 경우도 있다.

추상 클래스는 상속하기 위해서 존재한다. 하나의 하위클래스만 갖는 추상화된 클래스를 만드는 것은 사용되지 않는다. 미래의 가능성만으로 상속을 사용하는 것은 좋지 않을 수 있다. 상속을 사용해야하는 시점이 왔을 때 사용하는 것이 현명하다. 하지만 두 종류의 자전거를 다뤄야 하는 상황이더라도 상속을 사용해야 하는 시점이 아닐수 있다. 상속 관계를 만드는 것은 높은 비용이 들기 때문이다.

아직 Bicycle 상속 관계를 만들지 않기로 했다면, 마운틴 바이크와 로드 바이크 클래스는 중복되는 코드를 많이 가지게 될 것이다. 상속 관계를 만들기로 했다면, 나중에 추가될 다른 자전거에 대한 정보가 부족해 추상화를 위한 충분한 정보를 가지고 있지 않을지도 모른다는 위험을 감수하는 것이다.

즉, 상속 관계를 만들지 말지를 결정하는 것은 '세 번째 종류의 자전거가 얼마나 빨리 필요하게 될지'그리고 '중복 코드를 관리하는 비용이 얼마나 큰지'사이에 달려있다.

하지만, 지금은 두 종류의 자전거 뿐이지만 상속관계를 만들 이유는 충분하기 때문에 만들어 보자.

```ruby
class Bicycle
    # This class is now empty.
    # All code has been moved to RoadBike.
end

class RoadBike < Bicycle
    # Now a subclass of Bicycle.
    # Contains all code from the old Bicycle class.
end

class MountainBike < Bicycle
    # Still a subclass of Bicycle (which is now empty).
    # Code has not changed.
end
```

Bicycle 클래스는 비었고, 기존에 있던 코드는 모드 RoadBike클래스로 옮겼다. MouctainBike는 이전에 짰던 코드와 같다. 마운틴 바이크가 의존하던 코드들은 이제 형제 클래스인 로드바이크로 모두 옮겨진 것이고, 마운틴 바이크는 로드바이크로 접근할 수 없다.

이런 재배치가 의미 있는 이유ㅜ는 하위클래스의 코드를 상위클래스로 올리는 것이 상위클래스의 코드를 하위클래스로 내리는 것보다 수월하기 때문이다. 아직은 이해가 잘 안되겠지만, 일련의 과정이다.

![image](https://user-images.githubusercontent.com/53181778/86086763-79aad900-badd-11ea-95a0-6deea4567d23.png)

RoadBike는 필요한 모든 행동을 가지고 있기 떄문에 제대로 작동하지만 MoutainBike는 완전히 고장이 난다. 아래의 코드와 같은 에러가 발생할 것이다.

```ruby
road_bike = RoadBike.new(
    size: 'M',
    tape_color: 'red' )

road_bike.size # => "M"

mountain_bike = MountainBike.new(
    size: 'S',
    front_shock: 'Manitou',
    rear_shock: 'Fox')

mountain_bike.size
# NoMethodError: undefined method 'size'
```

이런 에러가 발생하는 이유는 MountainBike와 Bicycle 모두에서 size와 관련된 메서드를 가지고 있지 않기 때문이다.

#### 6.4.2. 추상적인 행동을 상위로 올리기

size와 spares는 모든 자전거에 적용될 수 있는 메서드이다. 이런 행동들은 Bicycle의 퍼블릭 인터페이스에 속한다. 즉, RoadBike가 아닌 상위 클래스인 Bicycle에 위치해야한다. size가 가장 간단한 메서드이기 떄문에 이것부터 작업한는 것이 가장 자연스럽다.

아래 코드에서 볼 수 있듯, 메서드를 상위클래스로 올리는 작업은 3가지 과정이 필요하다. `1)attr_reader`, `2)initailize 메서드`를 RaodBike에서 Bicycle로 옮겨야하고, RoadBike의 initailize 메서드에서 `3)super`를 전송해야한다.

```ruby
class Bicycle
    attr_reader :size # <- promoted from RoadBike

    def initialize(args={})
        @size = args[:size] # <- promoted from RoadBike
    end
end

class RoadBike < Bicycle
    attr_reader :tape_color

    def initialize(args)
        @tape_color = args[:tape_color]
        super(args) # <- RoadBike now MUST send 'super'
    end
    # ...
end
```

sper를 쓰지 않으면, size가 초기화 되지않음에 유의하자.

이제는 MountainBike도 size 메세지에 반응할 수 있게 되었다.

```ruby
road_bike = RoadBike.new(
    size: 'M',
    tape_color: 'red' )

road_bike.size # -> ""M""

mountain_bike = MountainBike.new(
    size: 'S',
    front_shock: 'Manitou',
    rear_shock: 'Fox')

mountain_bike.size # -> 'S'
```

하지만, 의문이 있다. 다시 Bicycle로 size를 옮길것이라면 왜 Roadbike로 내렸다가 귀찮게 다시 올리는 걸까? 이것이 바로 `핵심 전략`이다.

상속을 구현하는데 어려움은 구체적인 것과 추상적인 것을 구분하지 못하는 것이다. 일단 구체 클래스였던 상위클래스의 모든 내용을 하위클래스로 옮겨 추상적인 부분만 상위클래스로 옮겨야, 상위클래스에 구체적인 요소를 남길 수 있는 실수를 줄여준다.

이런 전략은 실패했더라도 수정하기 쉬운 문제를 발생시킨다.추상화하지 않고 빼먹은 코드가 있더라도 다른 하위클래스가 해당 행동을 필요로 하기 때문에 문제가 바로 눈에 띈다.  만약, 반대방향으로 구체적인것만 하위로 내린다면, 간단한 실수로 인해 많은 비용이 들게 될 수 있다. 구체적인 것이기 남아 있어도, 구체적인 것이기 때문에 새로운 하위클래스에 적용하기 어렵고, 하위 클래스는 상속의 기본 법칙을 위반하게 된다.

#### 6.4.3. 구체적인 것에서 추상적인 것 분리하기

RoadBike와 MountainBike 모두 각자 spares 메서드를 구현하고 있다. RoadBike의 Spares는 원래 있던 구체적인 Bicycle 클래스에서 가져온 그대로 이며 잘 동작한다.

```ruby
class RoadBike < Bicycle
    # ...
    def spares
        { chain: '10-speed',
            tire_size: '23',
            tape_color: tape_color}
    end
end
```

MountainBike의 spares는 하위클래스를 만들려는 첫 번째 시도 후에 남겨진 것이다. (아래 코드) 하지만, 아직 Bicycle클래스에서 spare 메서드를 구현하고 있지 않기 때문에 에러가 발생한다.

```ruby
class MountainBike < Bicycle
    # ...
    def spares
        super.merge({rear_shock: rear_shock})
    end
end

mountain_bike.spares
# NoMethodError: super: no superclass method 'spares'
```

이 문제를 해결하기 위해 spares 메서드를 상위 클래스에 추가해야 한다. 하지만 단순히 코드를 끌어 올리는 것으로 해결되지 않는다. 메서드 내부에 추상적인 것과 구체적인 것이 섞여있기 때문이다. 그러한 부분들을 적절히 분리하자.

모든 자전거가 공유해야 하는 부분을 위로 올리는 것에 집중해보면, chain, tire_size가 있다. 이것들은 size와 같은 어트리뷰트에 해당하기 때문에 accessors와 setter를 통해 접근해야 한다.(하드코딩은 좋지 않다)

아래의 요구사항을 따를 수 있어야 한다.

- Bicycle 체인과 타이어 크기를 가진다.
- 모든 자전거는 체인의 기본값을 공유한다.
- 하위클래스는 자신만의 타이어 크기를 기본값으로 가진다.
- 하위클래스의 구체적인 인스턴스는 기본값을 무시하고 인스턴스 고유의 값을 설정할 수 있다.

아래 코드를 살펴보자.

```ruby
class Bicycle
    attr_reader :size, :chain, :tire_size

    def initialize(args={})
        @size = args[:size]
        @chain = args[:chain]
        @tire_size = args[:tire_size]
    end
    # ... .
end
```

로드바이크와 마운틴바이크는 Bicycle의 attr_Reader 정의를 상속받고 있고 둘 모두 initaize에서 super를 전송해야 한다. 이제 모든 자전거는 size, chain, tire_size가 무엇인지 이해하고 있고 자전거가 해당하는 하위클래스에 맞게 특수한 어트리뷰트도 사용할 수 있다. 즉, 요구사항중 첫 번째 요구사항과 마지막 요구사항이 해결되었다.

이제 두 번째, 세 번째 요구사항인 기본값과 관련된 내용을 살펴보자.

#### 6.4.4. 템플릿 메서드 패턴 사용하기

Bicycle의 initialize 메서드가 기본값을 가져오는 메세지를 전송하도록 할 것이다. 여기서는 두 개의 새로운 메세지 default_chain과 default_tire_size가 각 6,7,번 줄에 나온다.

기본값을 메서드로 감싸는것이 일반적으로는 좋은 습관이지만, 여기서는 등장한 새로운 메세지는 또 다른 의미를 가지고 있다. Bicycle이 메세지를 전송하는 궁극적인 목표는 하위클래스가 이 메서드를 재정의 하는 것을 통해 하위 클래스만의 특수한 행동을 추가할 수 있도록 하기 위함이다.

기본 구조를 상위클래스가 정의하고, 상위클래스에서 메세지를 전송하여 하위 클래스의 특수한 값을 얻는 기술을 `템플릿 메서드 패턴`이라고 부른다.

아래 코드에서 로드바이크와 마운틴 바이크는 default_tire_size를 구현하고 있지만, default_chain을 구현하고 있지는 않다. chain은 클래스와 무관하게 동일한 값을 가지기 때문에 Bicycle 클래스에 사용되었고, tire_size는 클래스마다 다른 크기를 가지기 때문에 각 클래스에 메서드를 사용한 것이다.

```ruby
class Bicycle
    attr_reader :size, :chain, :tire_size

    def initialize(args={})
        @size = args[:size]
        @chain = args[:chain] || default_chain
        @tire_size = args[:tire_size] || default_tire_size
    end

    def default_chain # <- common default
        '10-speed'
    end
end

class RoadBike < Bicycle
    # ...
    def default_tire_size # <- subclass default
        '23'
    end
end

class MountainBike < Bicycle
    # ...
    def default_tire_size # <- subclass default
        '2.1'
    end
end
```

제 Bicycle는 하위클래스에게 구조를 제공한다. 또는 공통의 알고리즘을 제공한다. 그리고 메세지 전송을 통해 하위클래스가 알고리즘에 개입할 수 있게 해준다. 이제 모든 자전거는 동일한 체인을 사용하며 다른 크기의 타이어를 가진다.

```ruby
road_bike = RoadBike.new(
    size: 'M',
    tape_color: 'red' )

road_bike.tire_size # => '23'
road_bike.chain # => "10-speed"

mountain_bike = MountainBike.new(
    size: 'S',
    front_shock: 'Manitou',
    rear_shock: 'Fox')

mountain_bike.tire_size # => '2.1'
road_bike.chain # => "10-speed"
```

하지만 여전히 코드에는 문제점이 남아있다.

#### 6.4.5. 모든 템플릿 메서드 구현하기

Bicycle의 initialize메서드는 default_tire_size 메서드를 전송하지만 스스로는 이 메서드를 구현하고 있지 않다. **이 생략이 나중에 문제가 될 수 있다**.  만약 새로운 자전거로 `리컴벤트`라는 자전거를 추가한다고 가정해 보자. 리컴벤트 자전거는 낮고 긴 자전거로, 누워서 타는 자전거이다.

RecumbentBike 하위클래스를 만들면서 default_tire_size메서드를 구현하지 않았다면 어떻게 될까?

```ruby
class RecumbentBike < Bicycle
    def default_chain
        '9-speed'
    end
end

bent = RecumbentBike.new
# NameError: undefined local variable or method
# 'default_tire_size'
```

위와 같은 에러가 발생할 것이다. 이러한 실수는 처음 디자인한 사람이 아닌 다른 프로그래머가 저지르게 되는 실수이다. cycle을 만든 사람이고 하위클래스가 갖춰야 하는 것을 잘 알고 있다면 문제가 되지 않지만, 그 사실을 모른다면 문제가 될 수 있다.

Bicycle 클래스의 구조는 하위 클래스가 default_tire_size를 구현하도록 만들어져 있다.

문제가 발생할 여지가 있는 것은 문제가 발생하기 전에 해결하는 것이 좋다. 템플릿 메서드 패턴을 사용하는 클래스는 자신이 전송하는 메서드를 직접 구현해 놓아야 한다. 아래와 같이 코드를 작성해 놓더라도, 직접 구현해 놓아야 한다.

```ruby
class Bicycle
    #...
    def default_tire_size
        raise NotImplementedError
    end
end
```

하위클래스가 이 메세지를 구현해야 한다고 명시적으로 말해주는 것은 구 자체로 훌륭한 문서가 된다.

이렇게 코드를 짜면, RecumbentBike 인스턴스를 만들 때 에러를 보여주게 됨으로 코드의 수정이 용이해진다.

```ruby
bent = RecumbentBike.new
# NotImplementedError: NotImplementedError
```

하지만, 더 명확한 정보를 주는 것이 좋다. 아래와 같이 추가적인 정보를 제공해 주도록 하자.

```ruby
class Bicycle
    #...
    def default_tire_size
        raise NotImplementedError,
        "This #{self.class} cannot respond to:"
    end
end
```

가 정보는 문제를 명확하게 드러내준다. 실행결과를 살펴보자.

```ruby
bent = RecumbentBike.new
# NotImplementedError:
# This RecumbentBike cannot respond to:
# 'default_tire_size'
```

이 에러메세지는 문제를 쉽게 해결 가능하도록 해준다. 이런식의 문서화는 반드시 꼭 필요하다.

### 6.5. 상위클래스와 하위클래스 사이의 커플링 관리하기

이제 Bicycle은 자전거의 추상적인 행동을 모두 포함하고 있다.

이제 상위클래스의 spares메서드만 구현하면 된다. 각 방법은 상위클래스와 하위클래스 사이의 결합(coupling)이 모두 다르다. 커플링을 관리하는 것은 중요하며, 강하게 결합된 클래스는 서로 들러붙어 있어 독립적으로 수정할 수 없게 되기도 한다.

spares를 구현하는 두 가지 방법에 대해서 알아보자.

#### 6.5.1. 커플링 이해하기

첫 번째 구현방식은 간단하지만, 클래스 간 강력한 결합을 만들어 낸다.

로드바이크는 아래와 같이  spares를 구현하고 있다.

```ruby
class RoadBike < Bicycle
    # ...
    def spares
        { chain: '10-speed',
            tire_size: '23',
            tape_color: tape_color}
    end
end
```

에 메서드에는 이것저것 다 섞여 있다.

하드코딩된 체인과 타이어 크기의 값을 변수와 메세지로 뽑아냈으며, 이 부분만을 Bicycle로 올려놓앗다. 자전거 체인과 타이어 크기와 관련된 코드는 이제 상위 클래스에 속한다.

마운틴 바이크는 아래와 같이 spares를 구현하고 있다.

```ruby
class MountainBike < Bicycle
    # ...
    def spares
        super.merge({rear_shock: rear_shock})
    end
end
```

이 메서드는 sper를 전송한다. 클래스는 상위 클래스가 spares를 구현하고 있다고 생각한다. 자신의 예비부품을 spuer의 결과값과 합친다. 여기서 super의 반환값을 해시라고 가정하고 있다.

아래와 같이 Bicycle의 spares를 구현하면 큰 문제없이 동작한다.

```ruby
class Bicycle
    #...
    def spares
        { tire_size: tire_size,
            chain: chain}
    end
end
```

이러한 요구사항을 모두 만족하는 코드를 작성하면 아래와 같은 코드가 나온다. 이 코드는 알아보기 쉬운 패턴을 가지고 있다. Bicycle이 전송하는 모든 템플릿 메서드는 Bicycle 내에서 구현되어 있고, 마운틴 바이크와 로드바이크 모두 initialize와 spares메서드에서 super를 전송한다.

```ruby
class Bicycle
    attr_reader :size, :chain, :tire_size

    def initialize(args={})
        @size = args[:size]
        @chain = args[:chain] || default_chain
        @tire_size = args[:tire_size] || default_tire_size
    end

    def spares
        { tire_size: tire_size,
            chain: chain}
    end

    def default_chain
        '10-speed'
    end

    def default_tire_size
        raise NotImplementedError
    end
end

class RoadBike < Bicycle
    attr_reader :tape_color

    def initialize(args)
        @tape_color = args[:tape_color]
        super(args)
    end

    def spares
        super.merge({ tape_color: tape_color})
    end

    def default_tire_size
        '23'
    end
end

class MountainBike < Bicycle
    attr_reader :front_shock, :rear_shock

    def initialize(args)
        @front_shock = args[:front_shock]
        @rear_shock = args[:rear_shock]
        super(args)
    end

    def spares
        super.merge({rear_shock: rear_shock})
    end

    def default_tire_size
        '2.1'
    end
end
```

이 클래스 상속 관계는 잘 동작하지만, 여전히 함정이 숨어있다. 마운틴바이크와 로드바이크 하위 클래스가 비슷한 패턴을 따르고 있다. 이 둘은 모두 자신에 대해아는 것(고육한 부품을 사용한다는 점)이 있으며, 상위 클래스에 대해 아는 것(spares 메서드가 해시를 반환한다는 점, initialize 메서드에 반응한다는 점)도 있다. 즉, 다른 클래스에 대해 알고 있다면 의존성이 만들어 진다. 의존성에 따라 객체가 강하게 결합된다. 이 의존성은 객체가 `super`를 전송하면서 만들어진다.

어떤 프로그래머가 하위 클래스를 만들면서 initialize메서드에서 super를 전송하는 것을 깜빡했다면, 아래와 같은 문제가 발생할 것이다.

```ruby
class RecumbentBike < Bicycle
    attr_reader :flag

    def initialize(args)
        @flag = args[:flag] # forgot to send ‘super’
    end

    def spares
        super.merge({flag: flag})
    end

    def default_chain
        '9-speed'
    end

    def default_tire_size
        '28'
    end
end

bent = RecumbentBike.new(flag: 'tall and orange')
bent.spares
# -> {:tire_size => nil, <- didn't get initialized
# :chain => nil,
# :flag => "tall and orange"}
```

리컴벤트 자전거가 초기화에서 super를 전송하지 않아, 부모클래스에서 제공하는 공통 초기화 과정을 빼먹게 된다. spare메서드에서도 이 문제는 동일하게 발생할 수 있다.

이러한 패턴은 알고리즘에 대한 지식을 하위클래스가 알아야 함을 의미하며, 하위클래스에게 명시적으로 super를 전송하라고 강제한다. 같은 지점에서 super를 전송하는 코드 중복이 발생하고, 미래의 프로그래머가 새로운 하위클래스를 만들면서 실수할 가능성을 높인다.

#### 6.5.2. Hook 메세지를 사용하여 하위클래스 커플링 제거하기

위의 문제는 하위클래스가 알고리즘을 알고 있고 super를 전송하는 방법대신,  **Hook 메세지를 사용**한다면 해결할 수 있다. 훅 메세지는 **정해진 메서드 구현**을 통해 **하위클래스가 정보를 제공**할 수 있도록 만들어준다.  이 방법을 사용하면 하위클래스는 알고리즘에 대해 몰라도 되고, 상위 클래스가 모든 권한을 가져가게 된다.

초기화 과정에서 훅 메세지를 사용하는 예시를 살펴보자. Bicycle의 initialize 메서드는 post_initialize 메서드를 전송한다. 그리고 이 메서드를 직접 구현하고, Bicycle은 아무것도 하지 않는 메서드를 만든다. RoadBike는 post_initailize 메서드를 재정의하는 것을 통해 자신만의 고유한 초기화 과정을 갖출 수 있다.

```ruby
class Bicycle

    def initialize(args={})
        @size = args[:size]
        @chain = args[:chain] || default_chain
        @tire_size = args[:tire_size] || default_tire_size

        post_initialize(args) # Bicycle both sends
    end

    def post_initialize(args) # and implements this
        nil
    end
    # ...
end

class RoadBike < Bicycle

    def post_initialize(args) # RoadBike can
        @tape_color = args[:tape_color] # optionally
    end # override it
    # ...
end
```

로드바이크의 initialize메서드 자체를 제거하여, 로드바이크 클래스에서 초기화 과정에는 관여하지 않게 되었다. 대신 추상적인 알고리즘에 자신만의 특수한 내용을 추가한다. post_initalize를 전송하는 것은 Bicycle의 책임이다.\

RoadBike는 여전히 자기 자신에게 필요한 초기호 ㅏ방식을 알고 있고, 그 역할을 담당하고 잇다. 하지만 초기화가 언제 이루어져야 하는지는 결정하지 않는다.

언제 전송할지를 상위클래스에서 관리한다는 것은 하위클래스를 변경하지 않고도 알고리즘을 수정할 수 있다는 뜻이다.

같은 기술을 spares 메서드에도 적용해보자. spares는 해시를 반환한다는 사실을 하위클래스가 알고 있을 필요 없이 훅을 구현해서 Bicycle에 관리 권한을 주면 클래스 사이의 결합도를 낮출 수 있다.

아래 예시에서는 local_spares를 전송하도록 수정한 것이다. Bicycle은 빈 해시를 반환하는 기본구현을 제공하고 있다. RoadBike는 이 훅을 이용하고 재정의해서 자기에게 필요한 local_spares를 반환한다. 로드 자전거에만 필요한 부품을 추가했다.

```ruby
class Bicycle
    # ...
    def spares
        { tire_size: tire_size,
            chain: chain}.merge(local_spares)
    end

    # hook for subclasses to override
    def local_spares
        {}
    end

end

class RoadBike < Bicycle
    # ...
    def local_spares
        {tape_color: tape_color}
    end

end
```

로드바이크의 local_spares 메서드는 기존의 spares 메서드를 대체하고 있다. 특수 부품 정보를 제공하는 내용은 그대로 남아있지만, 상위 클래스와의 결합은 느슨해졌다. 로드 바이크는 Bicycle이 spares 메서드를 구현한다는 사실을 알 필요가 없다.

이제 전체 코드를 수정해보면 아래와 같다.

```ruby
class Bicycle
    attr_reader :size, :chain, :tire_size

    def initialize(args={})
        @size = args[:size]
        @chain = args[:chain] || default_chain
        @tire_size = args[:tire_size] || default_tire_size
        post_initialize(args)
    end

    def spares
        { tire_size: tire_size,
            chain: chain}.merge(local_spares)
    end

    def default_tire_size
        raise NotImplementedError
    end

    # subclasses may override
    def post_initialize(args)
        nil
    end

    def local_spares
        {}
    end

    def default_chain
        '10-speed'
    end

end

class RoadBike < Bicycle
    attr_reader :tape_color

    def post_initialize(args)
        @tape_color = args[:tape_color]
    end

    def local_spares
        {tape_color: tape_color}
    end

    def default_tire_size
        '23'
    end
end

class MountainBike < Bicycle
    attr_reader :front_shock, :rear_shock

    def post_initialize(args)
        @front_shock = args[:front_shock]
        @rear_shock = args[:rear_shock]
    end

    def local_spares
        {rear_shock: rear_shock}
    end

    def default_tire_size
        '2.1'
    end
end
```

자식 클래스는 구체적인 구현만을 가지고 있기 때문에 훨씬 가독성이 좋다.

새로 추가되는 하위클래스는 템플릿 메서드만 구현하고 있으면 된다. 마지막 예시로 새로운 하위클래스를 추가하는 것이 얼마나 쉬운지 살펴보자.

```ruby
class RecumbentBike < Bicycle
    attr_reader :flag

    def post_initialize(args)
        @flag = args[:flag]
    end

    def local_spares
        {flag: flag}
    end

    def default_chain
        "9-speed"
    end

    def default_tire_size
        '28'
    end
end

bent = RecumbentBike.new(flag: 'tall and orange')
bent.spares
# -> {:tire_size => "28",
# :chain => "9-speed",
# :flag => "tall and orange"}
```

RecumbentBike의 코드는 뚜렷하고, 예측이 가능하며 쉽게 작성되었다.

## 7. Sharing Role Behavior with Modules

만약 리컴벤트 마운틴 바이크가 필요하다면 어떻게 해야할까? 리컴벤트 마운틴 바이크는 리컴벤트 바이크와 마운틴 바이크의 속성을 상속받아야 하는데, 루비에서의 고전적 상속은 하나의 부모만 가질 수 있다.

이번 장에서는 상속의 기술을 이용해서 역할(role)을 공유하는 또 다른 방법인 `모듈`을 이용해 공통의 역할을 정의하는 방법을 학습할 것이다.

### 7.1. 역할 이해하기

객체의 숨겨진 역할을 찾고, 그 행동을 여러 수행자들이 공유할 수 있는 코드를 작성해보자. 이 과정에서 만들어지는 의존성을 최소화 하는 방법도 살펴보자.

#### 7.1.1. 역할 찾기

5장에서살펴본 Preparer오리 타입은 하나의 역할이다. Preparer의 퍼블릭 인터페이스를 구현하고 있는 객체가 이 역할을 수행한다. Mechanic, TripCoordinator,Dirver가 모두 prepare_trip을 구현하고 있기 때문에 다른 객체는 이들이 모두 Preparer라고 생각하고 함께 협업할 수 있다.

Preparer역할이 있다는 사실은 그 맞짝인 Preparable 역할이 존재하다는 것을 의미한다. 5장에서는 Trip클래스가Preparable의 인터페이스를 구현했다. Preparer가 Preparable에게 전송할 법한 모든 메시지를 포함하고 있다. 이 메세지는 bicycles, customers, vehicle이다. Preaprable의 역할을 수행하는 객체는 Trip이기 떄문에 이 역할은 명백하게 드러나지 않는다. 하지만 이런 역할이 있다는 것을 아는것은 중요하다.

Preparer처럼 행동하려면 인터페이스만 공유하면 된다. 즉, 메서드 시그니처를 공유할 뿐 코드를 공유하지는 않는다. 하지만 이보다 더 복잡한 역할을 발견하는 것이 일반적이다. 메세지 시그니처만 공유하는 것이 아니라 특정 행동까지 공유해야하는 경우가 존재한다. 코드는 단 한곳에서 정의되어 있고, 오리타입 처럼 행동하고 주어진 역할을 수행하는 객체를 사용해야 한다.

여러 객체지향 언어들은 메서드의 묶음에 이름을 부여하고 관리할 수 있는 방법을 제공한다. 이 묶음은 클래스로부터 독립적이며, 어느 객체에든지 녹아들 수 있다. 루비에서는 이러한 것을 믹스인(Mix-in)이라하며, 모듈을 사용한다. 메서드는 모듈속에 정의되고 어느 객체든 이 모듈을 불러올 수 있다. 결국 서로 다른 클래스에 속한 객체가 한 덩어리의 코드를 이용해서 같은 역할을 수행할 수 있는 최고의 방법을 제공한다.

객체가 모듈을 include하면 모듈에 정의된 메서드를 위임을 통해 모두 사용할 수 있게 된다. 객체는 다음과 같은 메세지에 반응을 할 수 있다.

- 스스로가 구현하는 메세지
- 상속 관계에서 자기보다 상위에 있는 모든 객체가 구현하고 있는 메세지
- 자기가 인클루드한 모듈이 구현하는 메세지
- 상속 관계에서 자기보다 상위 객체가 인클루드 하고 있는 모든 모듈의 메세지

#### 7.1.2. 책임 관리하기

여행을 관리하는 스케줄을 짜는 것은, 객체들의 스케줄을 관리하는 것이다.

만약, Schedule 클래스가 있다고 가정해보자. 이 클래스는 다음과 같은 3개의 메서드를 가지고 있다.

> scheduled?(target, starting, ending)
>
> add(target, starting, ending)
>
> remove(target, starting, ending)

위 메서드는 모두 3개의 인자를 가지고 있다. target은 확인하려는 대상, starting과 ending은 시작일과 종료일을 의미한다. 하지만 여기에는 여행을 시작하기 전에 필요한 준비시간을 고려하는 것이 빠져 있다.

아래 그림에서 schedulable? 메서드는 필요한 모든 준비시간을 알고 있고 target인자의 클래스를 확인해서 각 객체에 준비시간을 얼마나 할당해야 하는지 결정한다.

![image](https://user-images.githubusercontent.com/53181778/86315025-0d0e1680-bc64-11ea-85f3-844bb8710c21.png)

Schedule은 클래스를 확인해서 준비시간이 얼마나 필요한지 알게 된다. 하지만, Schedule은 너누 많은 것을 알게된다. 이 지식들은 Schedule에 속해야할 정보들이 아니다. 이것은 각각의 클래스들이 알고 있어야 하는 지식이다.

#### 7.1.3. 불필요한 의존성 제거하기

특정 변수의 값을 무엇으로 할지 결정하기 위해 Schedule은 여러 클래스의 이름을 확인하고 있다. 이것은 특정 변수를 메세지로 바꾸어야 한다는 점을 알려준다. 입력 받은 객체에게 전송하는 메세지로 변경해야 한다.

- Schedulable 오리 타입 찾아내기

  아래 그림의 시퀀스 다이어그램은 Schedulable? 메서드가 클래스를 확인하는 부분을 제거하고, 대신 인자로 넘어온 target들에게 lead_days 메세지를 전송하도록 바뀐 모습을 보여준다. 객체 클래스를 확인하는 if문은 그 객체에게 보내는 메세지로 대체되었다.

  ![image](https://user-images.githubusercontent.com/53181778/86315620-9245fb00-bc65-11ea-9ad3-7f0bf9529040.png)

  코드는 좀 더 단순해졌고, 정확한 준비기간을 알고있어야 하는 책임 역시 마지막 객체가 가지게 되었다.

  `the target`이라는 박스는 특정 클래스의 인스턴스가 아님을 주목해야 한다. 스케쥴은 어떤 객체가 대상이 되는지 상관하지 않고, 오로지 메세지를 타겟에게 보내는 것으로 표현하면 된다. 스케쥴은 타겟이 lead_days 메세지를 이해하는 어떤 객체처럼 행동하리라 믿는다. 다시 말해 Schedulable 인듯 행동하리라 생각한다. 여기서 오리 타입을 발견할 수 있다. 오직 인터페이스만을 공유하는 오리타입이다. Schedulable은 lead_days를 필수적으로 구현하고 있어야 하지만 그 외에는 코드를 공유하지 않는다.

- 객체가 자기 자신을 표현하게 하기

  이제 Schedule은 특정 클래스 이름에 의존하지 않을 수 있다. 어플리케이션은 좀 더 유연해졌고 유지보수하기 쉬워졌다. 하지만 연전히 불필요한 의존성이 있고, 이 의존성은 제거되어야 한다.

  문자열을 관리하는 유틸리티 메서드를 구현하고 있는 StringUnits 클래스가 있다고 생각해보자. 주어진 문자열이 비어있는지 확인하고 싶다면 StringUnits에 empty? 메서드를 전송하면 된다. StringUnits.empty?(some_string)

  객체지향 코드를 어느 정도 작성해 본 경험이 있다면 이런 코드는 이상하다는 것을 알 수 잇다. 문자열을 관리하기 위해 별도의 클래스를 사용하는 일은 불필요하기 때문이다 . 문자열은 그 자체로 객체이고 그 자체로 행동을 가조기 있다. 문자열의 행동을 얻기 위해 제 3자를 알고 있어야 한다는 것은 불필요한 의존성을 추가하는 것이다.

  위의 예시는 `객체는 스스로 관리할 수 있어야 한다.`는 사실을 보여준다. 객체A의 용도가 객체B에 대해 무언가를 알기 위한 것일 뿐이라면 문제가 있다. 위의 시퀀스 다이어그램은 이런 원칙을 위반하고 있다. 가장 왼쪽의 시작 객체(instigator)는 target이 여행에 동원될 수 있는지(schdulable한지) 타겟에 바로 물어보지 않고, Schedule이라는 제 3자에게 물어보고 있다. Schedule에게 target이 스케줄을 소화할 수 있는지 묻는 것은 StringUnits에게 문자열이 비어있는지 물어보는 것과 똑같다. 시작객체가 Schedule을 알아야 한다고 강제하는 것이고 Schedule에 의존하게 만든다. 진짜 알고 싶은 것은 target에 대한 것이지만 Schedule에 대해 알고 있어야 한다.

#### 7.1.4. 구체적인 코드 작성하기

현재 Schedulabe 역할은 인터페이스만을 가지고 있다. schedulable? 메서드를 추가하기 위해서는 실제 코드를 작성해야 하고, 이코드를 어디에 작성할지 고민해야 한다.

![image](https://user-images.githubusercontent.com/53181778/86317477-76912380-bc6a-11ea-8e5b-95eaf79de11b.png)

일을 시작하기 가장 좋은 출발점은 이 두 결정을 분리해서 다루는 것이다. 임의의 구체 클래스를 하나(Bicycle) 선택하고 여기에 schedulable?메서드를 구현하자. Bicycle이 사용할 수 있는 코드가 완성되면 모든 코드를 재배치해서 Schedulable이 사용할 수 있도로 리팩토링 하면 된다. 위 그림은 Bicycle에 새로운 코드를 추가한 시퀀스 다이어 그램이다. 이제 Bicycle은 자신이 여행에 참여할 수 있는지, 즉 '스케줄가능성'에 대해 묻는 메세지에 답할 수 있게 되었다.

이 변경 전에는 모든 시작객체(instigating object)가 Schedule 객체를 알고 있어야 했고 그런 의미에서 의존성을 갖고 있었다. 이 변경을 통해 bicycle은 스스로를 표현할 수 있게 되었으며,시작객체는 제 3자의 도움없이도 bucycle와 소통할수 있게 되었다.

이것을 코드로 옮겨보자.

```ruby
class Schedule
    def scheduled?(schedulable, start_date, end_date)
        puts "This #{schedulable.class} " +
            "is not scheduled\n" +
            " between #{start_date} and #{end_date}"
        false
    end
end
```

Bicycle의 schedulable?구현을 보여준다. Bicycle은 자신의 준비시간(lead time)을 알고 있다. 그리고 scheduled?메세지를 Schedule에 전달(delegate)한다.

```ruby
class Bicycle
    attr_reader :schedule, :size, :chain, :tire_size

    # Inject the Schedule and provide a default
    def initialize(args={})
        @schedule = args[:schedule] || Schedule.new
        # ...
    end

    # Return true if this bicycle is available
    # during this (now Bicycle specific) interval.
    def schedulable?(start_date, end_date)
        !scheduled?(start_date - lead_days, end_date)
    end

    # Return the schedule's answer
    def scheduled?(start_date, end_date)
        schedule.scheduled?(self, start_date, end_date)
    end

    # Return the number of lead_days before a bicycle
    # can be scheduled.
    def lead_days
        1
    end

    # ...
end

require 'date'
starting = Date.parse("2015/09/04")
ending = Date.parse("2015/09/10")

b = Bicycle.new
b.schedulable?(starting, ending)
# This Bicycle is not scheduled
# between 2015-09-03 and 2015-09-10
# => true
```

코드를 실행해 보면 Bicycle이 준비기간을 고려해서 시작일을 재조정했다는 것을 할수 있다. ` !scheduled?(start_date - lead_days, end_date)`

이 코드는 Schedule이 누구인지, Bicycle안에서 어떤 일을 하는지를 밖으로 드러내지 않는다. Bicycle과 협업하는 객체는 더 이상 Schedule의 존재도 그 행동도 알 필요가 없다.

#### 7.1.5. 추상화하기

schedulable? 메서드가 '무엇을 해야 하는지' 답해 주었고 우리의 첫 번째 문제를 해결해 주었다. 이제 자전거 이외의 정비공, 자동차 등과 같은 객체도 같은 행동을 가지고 있어야 한다. 이제 다른 클래스의 객체들도 이 코드를 공유할 수 있도록 코드를 재배치해야한다.

```ruby
module Schedulable
    attr_writer :schedule
    def schedule
        @schedule ||= ::Schedule.new
    end
    def schedulable?(start_date, end_date)
        !scheduled?(start_date - lead_days, end_date)
    end

    def scheduled?(start_date, end_date)
        schedule.scheduled?(self, start_date, end_date)
    end

    # includers may override
    def lead_days
        0
    end

end
```

Schedulable모듈을 만들었다. Bicycle 안에 있었을 때와 비교해 보면 두 가지가 변경되었다.

첫째로 schedule메서드가 추가 되었다. 이 메서드는 Schedule의 인스턴스를 반환한다. 원래는 시작객체가 Schedule에 의존하고 있었고, 그 의존성을 Bicycle로 이동했었다. 그리고 위 코드에서는 Schedule에 대한 의존성이 Bicycle에서 Schedulable 모듈로 옮겨져 훨씬 더 고립되었다.

두 번째 변경은 lead_days 메서드에서 찾을 수 있다. Bicycle이 구현했던 lead_days는 자전거에만 적용되는 숫자를 반환했다. 모듈은 보다 일반적인 기본값인 0을 반환한다. 모든 객체에 적용할 수 있는 준비기간의 기본값은 없지만, Schedulable 모듈은 lead_days 메서드를 꼭 구현하고 있어야 한다.

아래의 예시처럼 이 모듈을 원래의 Bicycle 클래스에 인클루드하면 Bicycle이 반응할 수 있는 메서드들의 목록에 모듈의 메서드들이 추가된다. lead_days 메서드는 템플릿 메서드 패턴을 따르는 훅 메서드이다. Bicycle은 이 훅 메서드를 재정의해서 자신만의 특수한 행동을 추가할 수 있다.

```ruby
class Bicycle
    include Schedulable

    def lead_days
        1
    end

    # ...
end

require 'date'
starting = Date.parse("2015/09/04")
ending = Date.parse("2015/09/10")
b = Bicycle.new
b.schedulable?(starting, ending)
# This Bicycle is not scheduled
# between 2015-09-03 and 2015-09-10
# => true
```

메서드들은 모듈로 모두 옮겼고, 모듈을 include하면서 lead_days 메서드를 재정의했다. 객체들은 중복코드를 작성하지 않고도 이 역할을 수행할 수 있게 되었다.

메세지의 패턴은 Bicycle에게 schedulable?을 전송하는 것으로부터 Schedulable에게 schedualble?을 전송하는 것으로 바뀌었다. 아래 시퀀스 다이어그램을 보자.

![image](https://user-images.githubusercontent.com/53181778/86320133-210c4500-bc71-11ea-9ea0-500b5454c38d.png)

이제 다른 클래스들에도 include 시키면 된다.

```ruby
class Vehicle
    include Schedulable

    def lead_days
        3
    end

    # ...
end

class Mechanic
    include Schedulable

    def lead_days
        4
    end

    # ...
end

v = Vehicle.new
v.schedulable?(starting, ending)
# This Vehicle is not scheduled
# between 2015-09-01 and 2015-09-10
# => true

m = Mechanic.new
m.schedulable?(starting, ending)
# This Mechanic is not scheduled
# between 2015-02-29 and 2015-09-10
# => true
```

Schedulable 모듈 속에 있는 코드는 추상된 것들이다.

이번 장은 `고전적 상속`과 `모듈을 통한 코드 공유 사이`의 구분을 설명했다. 상속인 것과 상속처럼 행동하는 것은 분명히 차이가 있다. 모두 자동화된 메세지 전달에 기반하고 있기 때문에 유사하지만, 다른 부분도 존재한다.

#### 7.1.6. 메서드 찾아 올라가기

객체지향 언어들이 전송된 메세지와 맞짝을 이루는 메서드 구현을 어떻게 찾는지 이해하고 있다면, 상속과 모듈을 인클루드 하는 것의 유사점을 이해할 수 있다.

- 단순한 설명

  객체가 메세지를 수신하면 객체지향 언어는 이 객체의 클래스에서 메서드를 찾는다. 만약 메서드가 그 클래스에 없다면, 상위클래스를 찾아본다. 메서드를 찾을 때 까지 상위클래스를 계속해서 올라간다. 세부 과정은 훨씬복잡하지만, 아래 그림정도로 이해하면 충분하다.

  ![image](https://user-images.githubusercontent.com/53181778/86321109-4bf79880-bc73-11ea-9086-02d5da85edd5.png)

  만약 최상위에 위치판 Objcet까지 도달해서도 메서드를 찾지 못한다면, 많은 언어들은 새로운 시도를 하나 더 한다. 루비에서는 처음 메세지를 수신했던 객체에게 `method_missing`이라는 새로운 메세지를 전송한다. 이때 새로운 메세지의 인자로 :spares(원래 메세지)를 넘긴다. 새로운 메서드를 찾아가는 탐색이, 동일한 경로를 따라 처음부터 다시 시작된다. 이번에는 `spares`가 아니라 `method_missing`을 탐색한다.

- 조금 더 정확한 설명

  앞에서는 고전적 상속이 메서드들을 어떻게 탐색해 올라가는지 보여주었다. 이번에는 모듈에서 정의된 메서드를 어떻게 찾는지 보여주고자 한다. 아래 그림은 메서드 탐색 경로에 Schedulable 모듈을 추가한 것이다.

  ![image](https://user-images.githubusercontent.com/53181778/86321972-02a84880-bc75-11ea-9dc2-8cbd45521a07.png)



  모듈은 include한다고 상위 클래스가 바뀌지는 않지만, 마치 상위 클래스가 된것같이 보인다. 이 말은 모듈또한 오버라이드가 가능하다는 것이다.

- 거의 완벽한 설명

  위계관계가 매우 긴 상위클래스의 연쇄를 가지고 있고 각 상위클래스가 여러개의 모듈을 인클루드하고 있는 경우를 충분히 생각해 볼 수 있다. 각 클래스에서 여러개의 모듈을 인클루드한다면, 인클루드된 순서와 반대의 순서로 탐색하게 된다.

  루비의 extend키워드를 사용하면 모듈을 단일 객체에도 추가할수 있다. 때문에 클래스가 모듈을 익스텐드하면 바로 이 클래스를 확장시키는 것 처럼 클래스내부에 메서드가 만들어진다.

  마지막으로, 모든 객체는 자신만의 `싱글톤 클래스`에 즉석 메서드를 추가할 수 있다. 이 즉석 메서드는 메서드를 정의한 바로 그 객체만 사용할 수 있다.

  이 모든 방법들은 메서드 모음을 메서드 탐색 경로의 특정 위치, 애매하지 않고 명확히 정해져 있는 위치에 올려 놓는다. 아래 그림을 보면 메서드 모음이 자리 잡을 수 있는 장소들을 보여준다.

  ![image](https://user-images.githubusercontent.com/53181778/86323811-7730b680-bc78-11ea-8493-9fc9c213d151.png)

  하지만, 위 그림이 전부는 아니다. 보통 최상위에 Object 클래스가 있다고 보아도 무방하다. 하지만 루비가 사용하는 버전에 따라 다른 겨웅도 존재한다.

  이 이슈가 문제가 될 수 있는 코드로 작업하고 있다면, 사용하는 루비 버전의 객체 위계관계를 먼저 살펴보아야 한다.

### 7.2. 상속가능한 코드 만들기

상속 관계와 모듈이 얼마나 유용하고 얼마나 유지보수하기 좋은지는 코드의 질에달려 있다. 여타의 디자인 기술보다도 상속된 행동을 공유하기 위해서는 훨씬 특별한 코딩 기술이 필요하다.

#### 7.2.1. 안티패턴 알아채기

작성하는 코드에 상속을 적용하면 좋을 것 같다고 말해주는 두개의 안티패턴이 있다.

하나는 type이나 category와 같은 이름을 가진 변수가 있고, 이 변수를 가지고 self에 어떤 메세지를 전송할지 결정하는 경우이다. 이런 경우는 상속 관계를 활용할 수 있다.

다른 하나는 객체의 클래스를 확인하고 어떤 메세지를 전소할지 판단하고 있다면 오리 타입을 놓치고 있다는 뜻이다.

오리 타입은 인터페이스를 공유할 뿐 아니라 같은 행동을 공유하고 있을 수도 있다. 이럴 경우에는 공통된 코드를 모듈로 만들고 주어진 역할을 수행하는 클래스나 객체에 모듈을 인클루드 하면도니다.

#### 7.2.2. 추상화된 코드 사용하기

추상화된 상위클래스에 포함된 모든 코드는 이 클래스를 상속받는 모든 하위클래스에도 적용될 수 있어야 한다. 모든 하위클래스가 아니라 몇몇 하위클래스에게만 적용되는 코드가 상위클래스에 포함되어 있으면 안 된다. 이 원칙은 모듈에도 적용될 수 있어야 한다.

하위 클래스에서 상속받은 메서드를 재정의해서 `나는 이런 기능을 하지 않습니다`라고 말한다면, 이것은 좋은 상속이 아니다. 추상화해야 할 내용을 잘 찾지 못하겠다면 그럴 만한 내용이 없다는 것일 수 있다. 그리고 공통으로 사용할 만한 추상화된 코드가 없다면 주어진 다자인 이슈의 해결책은 상속이 아니다.

#### 7.2.3. 약속을 존중하라

리스코프 치환 원칙

> 약속을 존중한다는 것은 리스코프 치환 원칙을 따른다는 것과 같다. SOLID 디자인 원칙의 L도 리스코프 치환원칙을 뜻한다.
>
> q(x)를 자료형 T의 객체 x에 대해 증명할 수 있는 속성이라 하자. 그렇다면 S가 T의 하위형이라면 q(y)는 자료형 S의 객체 y에 대해 증명할 수 있어야 한다.
>
> 타입 시스템이 정상적으로 작동하려면 상위타입은 자신의 하위타입으로 치환될 수 있어야 한다.
>
> 이 원칙을 따르는 어플리케이션에서는 상위클래스가 사용될 수 있는 곳이라면 어디든 하위클래스를 사용해도 괜찮아야 한다. 그리고 모듈을 인클루드 하고있는 객체라면 누구나 모듈이 제공하는 역할을 수행할 수 있어야 한다.

#### 7.2.4. 템플릿 메서드 패턴 사용하기

상속받을 수 있는 코드를 작성하기 위한 가장 핵심적인 기술은 템플릿 메서드 패턴이다. 이 패턴 덕분에 우리는 추상적인 것과 구체적인 것을 구분할 수 있다. 추상적인 코드가 알고리즘을 구현하며, 이 추상화를 상속받은 구체 클래스가 주어진 템플릿 메서드를 재정의하는 것을 통해 자신의 특수한 행동을 추가할 수 있게 된다.

템플릿 메서드는 알고리즘의 변경되는 지점들을 표현하고, 이 템플릿 메서드를 만드는 것을 통해 우리는 어떤 내용이 변하는 것이며 어떤 것이 변하지 않는 내용인지 명시적으로 선택하게 된다.

#### 7.2.5. 미리 클래스 디커플링하기

상속받은 클래스가 super를 전송해야 하는 코드를 작성하지 말자. 대신 훅 메서드를 이용하면 하위클래스가 개입할 수 있는 여지를 제공하면서 동시에 하위클래스에게 추상적인 알고리즘에 대해 알아야 하는 책임을 지우지 않을 수 있다.

하위클래스가 super를 전송해야 하는 코드는 의존성을 만들어 낸다. 가능하면 이런 의존성은 만들지 말자.

훅 메서드는 super를 전송해야 하는 문제를 해결해 준다. 하지만 바로 옆 층위의 객체와의 관계에서만 사용할 수 있다.

#### 7.2.6. 상속 구조를 낮게 만들기

훅 메서드의 한계는 상속 관계의 높이를 낮게 만들어야 하는 많은 이유 중 하나일 뿐이다. 모든 상속 관계는 너비와 높이를 가지고 있는 피라미드 모양으로 상상해 볼 수 있다. 객체의 높이는 최상위 클래스와 자신 사이에 있는 상위클래스의 수로 표현된다. 상속 관계의 모양은 전체적인 높이와 너비를 통해 표현되고 이 모양이 사용 및 유지보수 그리고 확장이 얼마나 손쉬운지 말해준다.

![image](https://user-images.githubusercontent.com/53181778/86331895-acdb9c80-bc84-11ea-925e-fc92ebae0e72.png)

높이가 낮고 너비가 좁은 구조는 이해하기 쉽다. 높이가 낮고 너비가 넓은 구조는 조금 더 복잡하다. 높고 좁은 구조는 보다 이해하기 어렵고 점점 넓어지려하는 경향을 가지고 있으며, 높고 넓은 구조는 이해하기 어려우며, 유지보수 비용도 비싸다.

높은 상속 관계는 메세지의 탐색 경로가 길다는 것을 의미한다. 객체는 자신보다 위에 있는 모든 것에 의존하고 있기 때문에 높은 상속관계는 이미 수많은 의존성을 가지고 있는 셈이다. 즉 수정이 에러로 이어질 확률이 높아진다.

## 8. Combining Objects with Composition

조합은 멀리 떨어져 있는 부분들을 하나의 복합체로 만드는 작업이다. 객체지향 조합을 이용하면 간단하고 독립적인 객체를 보다 크고 복합적인 것으로 통합할 수 있다. 조합에서 조금 더 큰 객체는 자신의 부분들을 가지는 `has-a`관계를 가진다.

### 8.1. 자전거 부품 구성하기

6장의 코드를 이용하여 진행할 것이다.

#### 8.1.1. Bicycle 클래스 업데이팅

Bicycle 클래스는 상속 관계 속의 추상화된 상위 클래스이며, 조합을 이용해서 변경하려 한다. 가장 먼저 현재의 코드를 무시하고 자전거가 어떻게 조합되어야 하는지 생각해야 한다.

Bicycle 클래스는 spares메세지에 반응할 책임이 있다. spares메세지는 예비부품(spare parts)의 목록을 반환한다. 자전거는 부품들으 가지고 있다. 자전거-부품의 관계가 조합의 관계를 취하는 것은 문제가 없다. 자전거의 모든 부품을 가지고 있는 Parts라는 클래스 객체를 만들어 spares 메세지를 이 객체에게 전달해 보자.

Parts는 자전거 부품의 목록을 가지고 있어야 할 책임이 있다. 그리고, 필요한 예비 부품이 무엇이 있는지 알고있어야 한다

Bicycle은 Parts 객체에게 spares 메세지를 전송한다. 모든 Bicycle은 Parts 객체를 필요로하며, 'Bicycle이란 무엇인가?' 라는 질문에 대한 답변 중 하나는 '부품들을 가지고 있다'일 것이다. 아래 그림은 그러한 관계를 보여준다.

![image](https://user-images.githubusercontent.com/53181778/86430892-4a3edb00-bd2e-11ea-8dcf-a833c213ad6d.png)

Bicycle 클래스와 Parts 클래스는 실선으로 이어져 있으며, 실선과 Bicycle가 맞닿은 부분에 검은색 마름모가 있는데, 이 마름모는 조합을 의미한다. Bicycle은 Parts들의 조합이라는 의미이다. 그리고 Parts 쪽에 있는 숫자 1은 Bicycle에 하나의 Parts 객체가 조합되어 있다는 의미이다.

아래과 같이 Bicycle 클래스 코드를 짤 수 있을 것이다.

```ruby
class Bicycle
    attr_reader :size, :parts

    def initialize(args={})
        @size = args[:size]
        @parts = args[:parts]
    end

    def spares
        parts.spares
    end
end
```

Bicycle에게는 세가지 책임이 있다. 자신의 size를 알아야 하고, 자신의 parts들을 가지고 있으며, spares에 응답해야 한다.

#### 8.1.2. Parts의 상속 관계 만들기

Bicycle에서 제거했던 부품의 행동들을 만들어야 한다. 기존 코드를 Parts의 새로운 상속 관계로 살짝 뒤집는 것이다.

```ruby
class Parts
    attr_reader :chain, :tire_size

    def initialize(args={})
        @chain = args[:chain] || default_chain
        @tire_size = args[:tire_size] || default_tire_size
        post_initialize(args)
    end

    def spares
        { tire_size: tire_size,
            chain: chain}.merge(local_spares)
    end

    def default_tire_size
        raise NotImplementedError
    end

    # subclasses may override
    def post_initialize(args)
        nil
    end

    def local_spares
        {}
    end

    def default_chain
        '10-speed'
    end
end

class RoadBikeParts < Parts
    attr_reader :tape_color

    def post_initialize(args)
        @tape_color = args[:tape_color]
    end

    def local_spares
        {tape_color: tape_color}
    end

    def default_tire_size
        '23'
    end
end

class MountainBikeParts < Parts
    attr_reader :front_shock, :rear_shock
    def post_initialize(args)
        @front_shock = args[:front_shock]
        @rear_shock = args[:rear_shock]
    end

    def local_spares
        {rear_shock: rear_shock}
    end

    def default_tire_size
        '2.1'
    end
end
```

이코드는 6장의 Bicycle 상속관계와 거의 똑같다. 다른 점은 클래스들의 이름이 바뀌었다는 것과 size 변수가 없어졌다는 것 뿐이다.

아래 다이어 그램은 이런 변화를 보여주며, 추상 클래스 parts가 추가되었다. Bicycle은 Parts의 조합이다. Parts는 두개의 하위 클래스를 가지고 있다.

![image](https://user-images.githubusercontent.com/53181778/86430907-5165e900-bd2e-11ea-9c89-90f231cdf4fc.png)

이 이팩토링의 이후에도 모든 것은 잘 작동한다. 아래 보이는 바와 같이, 자전거가 RoadBikeParts를 가지고 있든 아니면 MountainBikeParts를 가지고 있든 자전거는 자신의 size와 spares가 무엇인지 제대로 답할 수 있다.

```ruby
road_bike =
    Bicycle.new(
        size: 'L',
        parts: RoadBikeParts.new(tape_color: 'red'))

road_bike.size # -> 'L'
road_bike.spares
# -> {:tire_size=>"23",
# :chain=>"10-speed",
# :tape_color=>"red"}

mountain_bike =
    Bicycle.new(
        size: 'L',
        parts: MountainBikeParts.new(rear_shock: 'Fox'))

mountain_bike.size # -> 'L'

mountain_bike.spares
# -> {:tire_size=>"2.1",
# :chain=>"10-speed",
# :rear_shock=>"Fox"}
```

큰 변화는 없지만, 한 가지 사실은 Bicycle 속에 자전거와 관련된 코드가 사실은 거의 없었다는 점이다. 위의 코드 대부분은 개별 부품을 다루고 있다. Parts 상속 관계가 빨리 리팩터링 해달라고 말하고 있다.

### 8.2. Parts 객체 조합하기

부품 목록은 당연히 개별 부품들의 목록을 가지고 있다. 이제 하나의 부품을 담당하는 클래스를 만들 차례이다. 이제 하나의 부품을 담당하는 클래스를 만들 차례이다. 개별 부품을 관리하는 클래스의 이름은 Part이다. Parts와 혼동하지 않도록 주의하자.

우리는 Parts 객체를 가지고 있으며, 여러개의 개별 Part objects를 가지고 있다.

![image](https://user-images.githubusercontent.com/53181778/86430925-5a56ba80-bd2e-11ea-8984-de2a38818f97.png)

#### 8.2.1. Part 만들기

8.4의 시퀀스 다이어그램은 Bicycle과 Parts, 그리고 Parts와 Part 사이의 소동을 보여주고 있다. Bicycle은 Pants에게 spares를 전송하고, 이어서 pants는 각각의 Part에서 need_spare를 전송한다.

8.5에서 Parts는 Part의 조합이고, '1..*'은 Parts 하나가 1개 또는 여러개의 Part로 이루어져 있다는 것을 의미한다.

Part클래스를 만들면서 Part클래스가 단순해 졌다. Parts클래스는  Part들의 배열을 감싸는 단순한 포장에 불과하다. Part들 중에서 예비부품(spares)을 필요로 하는 것만 골라내 반환하면 된다. 아래 코드는 Bicyle 클래스, 업데이트된 Parts 클래스 그리고 Part 클래스이다.

```ruby
class Bicycle
    attr_reader :size, :parts

    def initialize(args={})
        @size = args[:size]
        @parts = args[:parts]
    end

    def spares
        parts.spares
    end
end

class Parts
    attr_reader :parts

    def initialize(parts)
        @parts = parts
    end

    def spares
        parts.select {|part| part.needs_spare}
    end
end

class Part
    attr_reader :name, :description, :needs_spare

    def initialize(args)
        @name = args[:name]
        @description = args[:description]
        @needs_spare = args.fetch(:needs_spare, true)
    end
end
```

세 개의 클래스를 만들었으니 개별 Part들을 만들 수 있다.

```ruby
chain =
    Part.new(name: 'chain', description: '10-speed')

road_tire =
    Part.new(name: 'tire_size', description: '23')

tape =
    Part.new(name: 'tape_color', description: 'red')

mountain_tire =
	Part.new(name: 'tire_size', description: '2.1')

rear_shock =
    Part.new(name: 'rear_shock', description: 'Fox')

front_shock =
    Part.new(
        name: 'front_shock',
        description: 'Manitou',
        needs_spare: false)
```

각 part들을 묶어 Parts를 만들 수 있다.

```ruby
road_bike_parts =
Parts.new([chain, road_tire, tape])
```

이 과정을 생략하고 아래와 같이 바로 Parts를 구성해도 된다.

```ruby
road_bike =
    Bicycle.new(
        size: 'L',
        parts: Parts.new([chain,
            road_tire,
            tape]))
road_bike.size # -> 'L'
road_bike.spares
# -> [#<Part:0x00000101036770
# @name="chain",
# @description="10-speed",
# @needs_spare=true>,
# #<Part:0x0000010102dc60
# @name="tire_size",
# etc ...

mountain_bike =
    Bicycle.new(
        size: 'L',
        parts: Parts.new([chain,
            mountain_tire,
            front_shock,
            rear_shock]))

mountain_bike.size # -> 'L'

mountain_bike.spares
# -> [#<Part:0x00000101036770
# @name="chain",
# @description="10-speed",
# @needs_spare=true>,
# #<Part:0x0000010101b678
# @name="tire_size",
# etc ...
```

예전의 Bicycle spares 메서드가 해시를 반환했다면, 새로운 메서드는 Part들의 배열을 반환한다는 차이가 있다. 이 객체들은 Part클래스의 한 종류가 아니라 그저 Part처럼 행동하는 것이다. 이 객체들은 name, descriptionm needs_spare 메서드에 꼭 반응해야 한다.

#### 8.2.2. Parts를 보다 배열과 비슷하게 만들기

이 코드는 잘 작동하지만 더 발전시킬 여지가 남아 있다. Bicycle의 parts와 spares메서드를 보면, 둘 다 비슷한 무언가를 반환해야 한다는 것을 볼 수 있다. 하지만, 반환받은 객체들은 같은 방식으로 동작하지 않는다. 이 둘에게 size를 물어보면 아래와 같이 반응한다.

```ruby
1 mountain_bike.spares.size # -> 3
2 mountain_bike.parts.size
3 # -> NoMethodError:
4 # undefined method 'size' for #<Parts:...>
```

1번 줄의 spares는 Part들의 배열을 반환하기 때문에 적상적으로 작동한다. (배열의 길이)

하지만, 2번줄 parts는 Parts의 인스턴스를 반환하고, 이 인스턴스는 size메서드를 모르기 때문에 문제가 된다.

위 문제는 Parts에size 메서드를 추가하면 해결된다.

```ruby
def size
    parts.size
end
```

하지만, 이런 수정은 Parts 클래스를 더 깊은 수렁에 빠뜨린다. 이제는 Parts가 each에 반응하기를 바라고, 더 나아가 sort에 반응하기를 바랄 수 있다. 즉, Array처럼 다루어 지기를 원할 수 있다.

Parts는 Array일지 모르며, 약간의 행동이 추가된 배열이다. 그렇다면, Array를 상속받아 문제를 해결할 수 있다.

```ruby
class Parts < Array
    def spares
        select {|part| part.needs_spare}
    end
end
```

이 코드는 Parts가 특별한 형태의 Array라는 생각을 명확히 보여준다. 완벽한 객체지향 언어라면 이 방법이 정답일 수 있지만, 루비는 그렇기 않기 때문에 약간의 결함을 가지고 있다. 아래 예시를 살펴보자.

Parts는 Array를 상속 받았기 때문에 Array의 모든 행동또한 상속 받는다. 여기에는 `+`와 같은 메서드도 포함되어 있다.  하지만, 아래 코드는 무언가 잘못 되었다. combo_parts는 spares 메서드에 응답하지 못하고 있다.

```ruby
# Parts inherits '+' from Array, so you can
# add two Parts together.
combo_parts =
    (mountain_bike.parts + road_bike.parts)

# '+' definitely combines the Parts
combo_parts.size # -> 7

# but the object that '+' returns
# does not understand 'spares'
combo_parts.spares
# -> NoMethodError: undefined method 'spares'
# for #<Array:...>

mountain_bike.parts.class # -> Parts
road_bike.parts.class # -> Parts
combo_parts.class # -> Array !!!
```

`+`메서드를 통해 Parts의 인스턴스를 합쳤는데, 그 결과로 Array의 인스턴스가 반환됐다. 그리고 Array는 spares를 이해하지 못한다.

Array의 많은 메서드들은 새로운 배열(Array)를 반환한다. 그리고 이런 메서드들은 언제나 Array 클래스의 인스턴스를 반환한다. 하위 클래스의 인스턴스를 반환하지 않는다.

선택은 우리의 몫이다. 완벽한 해결책은 없다. 복잡도와 편리함 사이의 어딘가에는 아래와 같은 해결책도 있다.

Parts 클래스는 size메서드를 @parts에 전달하고, Enumerable 모듈을 인클루드해서 반복과 검색을 가능하게 해주는 메서드를 얻을 수 있다.

```ruby
require 'forwardable'
class Parts
    extend Forwardable
    def_delegators :@parts, :size, :each
    include Enumerable

    def initialize(parts)
        @parts = parts
    end

    def spares
        select {|part| part.needs_spare}
    end
end
```

이 코드는 Pants 인스턴스에게 `+`메서드를 전송하면 NoMethodError 내뱉는다. 하지만, Parts는 size, each 그리고 Enumerable의 모든 메서드를 이해한다. 그리고 Array처럼 취급하면 친절하게 에러를 발생시킨다.

아래 예시에서 spares와 parts에서 모두 size에 반응한다.

```ruby
mountain_bike =
    Bicycle.new(
        size: 'L',
        parts: Parts.new([chain,
            mountain_tire,
            front_shock,
            rear_shock]))

mountain_bike.spares.size # -> 3
mountain_bike.parts.size # -> 4
```

이제 디자인을 발전시켜보자.

### 8.3. Parts 생산하기

위 코드에서 Part는 chain, mountain_tire 등을 들고 있다. 만든지 너무 오래되어서 이 변수들을 벌써잊어버렸을지도 모르겠다. 4~7번줄이 가지고 있는 지식은 무엇이 있을까, 먼저 마운틴 바이크를 만들기 위해서는 네 개의 부품이 필요하다는 것을 알고 있어야 한다.

여긴 상당한 양의 지식이 있고, 이 지식은 언제는 어플리케이션 곳곳으로 스며들 수 있다. 이렇게 지식이 여러 곳에 흩뿌려지는 것은 안 좋은 일이며 동시에 불필요한 일이다.

자전거 부품의 종류는 매우 많지만 부품들의 유의미한 조합은 몇개 되지 않는다. 자전거의 종류를 설명하고 이 설명을 가지고 필요한 부품들을 마법처럼 생산해낼 수 있다면 문제는 훨씬 간단해질 것이다.

첫 번째 칼럼은 부품이름을 표현하고, 두 번째 부품에 대한 설명이 있다. 세번째 컬럼에는 해당 부품이 예비 부품인지 아닌지 알려주는 boolean 값이 들어 있다.

```ruby
road_config =
    [['chain', '10-speed'],
        ['tire_size', '23'],
        ['tape_color', 'red']]

mountain_config =
    [['chain', '10-speed'],
        ['tire_size', '2.1'],
        ['front_shock', 'Manitou', false],
        ['rear_shock', 'Fox']]
```

해시와 다리 이 간단한 이차원 배열은 구조에 대한 정보를 제공하지 않는다. 하지만, 이 구조가 어떤 방식으로 정리되어 있는지 알고 있고, 이 지식을 parts를 생산하는 객체 속에 넣어두면 된다.

#### 8.3.1. PartsFactory(부품 공장)만들기

3장 의존성 관리하기에서 다루었듯이 다른 객체를 생산하는 객체를 팩토리라 부른다. 팩토리는 다른객체를 만드는 객체라고 이해하면 좋다.

아래 코드는PartsFactory 모듈이다. 이 모듈은 위에 나열된 배열 중 하나를 가지고 Parts를 생산한다. 이 과정에서 Part도 만들게 될 것이다. 하지만 이 작업은 프라이빗하게 진행된다. 이 모듈의 책임은 Parts를 만드는 것이다.

PartsFactory의 첫 번째 버전은 세 개의 인자를 받는다.

```ruby
module PartsFactory
    def self.build(config,
        part_class = Part,
        parts_class = Parts)

        parts_class.new(
            config.collect {|part_config|
                part_class.new(
                    name: part_config[0],
                    description: part_config[1],
                    needs_spare: part_config.fetch(2, true))})
    end
end
```

이 팩토리는 config 배열의 구조에 대해 알고 있다.

배열의 첫 번째 칼럼에 이름이, 두 번째에는 설명이, 그리고 마지막에 needs_spare가 들어가 있다는 것을 알고 있다.

config의 구조에 대한 지식을 팩토리 안에 넣어두면 두 가지 결과를 낳는다. 첫 째, config가 매우 간결하게 표현될 수 있다. PartsFactory가 config의 내부 구조를 알고 있기 때문에, 해시가 아니라 배열의 형태로 config를 작성할 수 있다.

둘째, 한번 config를 배열로 관리하기 시작하면, 새로운 Parts를 만들 때는 언제나 팩토리를 사용해야 한다. 새로운 Parts를 다른방식으로 만들려하면 9-11번 줄의 지식을 중복하게 된다.

이제 PartsFactory가 준비되었으니 정의된 설정값 배열을 이용해서 손쉽게 새로운 Parts를 만들 수 있다.

```ruby
road_parts = PartsFactory.build(road_config)
# -> [#<Part:0x00000101825b70
# @name="chain",
# @description="10-speed",
# @needs_spare=true>,
# #<Part:0x00000101825b20
# @name="tire_size",
# etc ...

mountain_parts = PartsFactory.build(mountain_config)
# -> [#<Part:0x0000010181ea28
# @name="chain",
# @description="10-speed",
# @needs_spare=true>,
# #<Part:0x0000010181e9d8
# @name="tire_size",
# etc ...
```

PartsFactory와 새로운 설정값 배열 덕분에 제대로 된 부품을 만들기 위한 모든 지식이 고립되었다. 고거에 이 지식은 어플리케이션 곳곳에 흩뿌려져 있었지만 이제는 하나의 클래스와 두 개의 배열속에 격리되어 있다.

#### 8.3.2. PartsFactory 발전시키기

PartsFactory가 제대로 작동하기 시작했으니, 이제 Part 클래스를 다시 한번 살펴보자. PartsFactory가 모든 Part를 만들고 있기 때문에 불필요한 부분을 제거해주자.

Part클래스 자체를 OpenStruct로 대체할 수 있다. 아래는 기존의 Part 클래스이다.

```ruby
class Part
    attr_reader :name, :description, :needs_spare

    def initialize(args)
        @name = args[:name]
        @description = args[:description]
        @needs_spare = args.fetch(:needs_spare, true)
    end
end
```

루비의 openStruct 클래스는 우리가 이미 살펴본 바 있는 Struct 클래스와 매우 비슷하다. 몇 개의 어트리뷰트를 하나의 객체속에 묶을 수 있는 편리한 방법을 제공한다.

둘 사이의 차이는 Struct가 순서에 민감한 초기화 인자들을 받는 반면, OpenStruct는 해시를 초기화 인자로 받고 이 해시에서 어트리뷰트들을 읽어온다는 점이다.

우리는 Part 클래스를 제거하려 한다. Part 클래스를 제거하면 코드가 좀 더 간단해지며 지금처럼 복잡한 코드를 다시 작성할 필요도 없을 것이다. Part 클래스와이 클래스를 사용하는모든 코드를 삭제하고 OpenStruct를 이용해서 Part의 역할을 수행하는 객체를 만들 수 있다. PartsFactory는 이 객체를 사용하면 된다. 아래 코드는 부품 생산 과정을 팩토리 안에서 직접 처리하도록 수정한 PartsFactory이다.

```ruby
require 'ostruct'
module PartsFactory
    def self.build(config, parts_class = Parts)
        parts_class.new(
            config.collect {|part_config|
                create_part(part_config)})
    end

    def self.create_part(part_config)
        OpenStruct.new(
            name: part_config[0],
            description: part_config[1],
            needs_spare: part_config.fetch(2, true))
    end
end
```

새로운 버전의 PartsFactory는 아주 잘 작동한다. 아래 코드에서 볼 수 있듯이, PartsFactory는 OpenStruct 객체들의 배열을 반환한다.

```ruby
mountain_parts = PartsFactory.build(mountain_config)
# -> <Parts:0x000001009ad8b8 @parts=
# [#<OpenStruct name="chain",
# description="10-speed",
# needs_spare=true>,
# #<OpenStruct name="tire_size",
# description="2.1",
# etc ...
```

### 8.4. 조합된 Bicycle

이어지는 코드는 조합을 사용하고 있는Bicycle의 모습이다. 로드와 마운틴 바이크를 만들기위한 클래스와 모듈, config 배열을 살펴보자.

Bicycle은 Parts를 가지고 있다(has-a)

Parts는 Part의 모음을 가지고 있다.

Parts와 Part가 클래스의 형태여도 좋지만, Parts를 품고있는 객체들은 이들을 역할이라고 이해한다.Parts는 Parts 역할을 수행하는 클래스이고, spares를 구현하고 있다. Part의 역할은 OpenStruct가 수행하며 name, description, need_spare를 구현하고 있다.

아래 콛느는 6장에서의 상속 관계를 통해 작성한 코드를 재구성 한 코드이다.

```ruby
class Bicycle
    attr_reader :size, :parts

    def initialize(args={})
        @size = args[:size]
        @parts = args[:parts]
    end

    def spares
        parts.spares
    end
end

require 'forwardable'
class Parts
    extend Forwardable
    def_delegators :@parts, :size, :each
    include Enumerable

    def initialize(parts)
        @parts = parts
    end

    def spares
        select {|part| part.needs_spare}
    end
end

require 'ostruct'
module PartsFactory
    def self.build(config, parts_class = Parts)
        parts_class.new(
            config.collect {|part_config|
                create_part(part_config)})
    end

    def self.create_part(part_config)
        OpenStruct.new(
            name: part_config[0],
            description: part_config[1],
            needs_spare: part_config.fetch(2, true))
    end
end

road_config =
    [['chain', '10-speed'],
        ['tire_size', '23'],
        ['tape_color', 'red']]

mountain_config =
    [['chain', '10-speed'],
        ['tire_size', '2.1'],
        ['front_shock', 'Manitou', false],
        ['rear_shock', 'Fox']]
```

이 코드는 기존의 Bicycle 상속 관계 코드와 매우 비슷해 보인다. 차이점이라면 해시를 리턴하던 spares 메서드가 Part처럼 동작하는 객체들의 배열을 반환한다는 점이다.

```ruby
road_bike =
    Bicycle.new(
        size: 'L',
        parts: PartsFactory.build(road_config))

road_bike.spares
# -> [#<OpenStruct name="chain", etc ...

mountain_bike =
    Bicycle.new(
        size: 'L',
        parts: PartsFactory.build(mountain_config))

mountain_bike.spares
# -> [#<OpenStruct name="chain", etc ...
```

이 클래스들 덕분에 이제 새로운 종류의 자전거를 만드는 일이 쉬워졌다.

아래 코드를 보자.

```ruby
recumbent_config =
    [['chain', '9-speed'],
        ['tire_size', '28'],
        ['flag', 'tall and orange']]

recumbent_bike =
    Bicycle.new(
        size: 'L',
        parts: PartsFactory.build(recumbent_config))

recumbent_bike.spares
# -> [#<OpenStruct
# name="chain",
# description="9-speed",
# needs_spare=true>,
# #<OpenStruct
# name="tire_size",
# description="28",
# needs_spare=true>,
# #<OpenStruct
# name="flag",
# description="tall and orange",
# needs_spare=true>]
```

자기 자전거의 부품만을 명시함으로 새로운 자전거를 만들 수 있게 되었다.

**Aggregation: A Special Kind of Composition**

>한 객체가 전달 받은 메세지를 단순히 다른 객체에게 전달하는 것을 위임이라 한다. 위임은 의존성을 만들어 낸다. 메세지를 수신한 객체가 이 메세지를 인지하고 또한 어디로 보내야 하는지 알아야 한다.
>
>조합은 종종 위임을 사용하는데 이때 사용하는 위임의 개념에는 몇가지 의미가 더 있다. 조합된 객체는 잘 정의된 인터페이스를 통해 협업할 줄 아는 여러 부분들로 구성되어 있다.
>
>조합은 가지고 있는 관계(has-a relationship)이다. 식사는 애피타이저를 가지고 있고, 대학은 학부를 가지고 있다. 식사, 대학, 자전거는 조합된 객체이다. 애피타이저, 학부, 부품은 역할(role)이다. 조합된 객체는 역할의 인터페이스에 의존적이다.
>
>조합이라는 개념은 미묘하게 다른 두 가지 의미로 사용되기 때문에 조금 난해하다. 우리가 조합이라는 개념을 접하는 대부분의 경우는 `has-a`과려를 의미한다고 생각하면 된다.
>
>하지만 조금 더 정교하게 정의하자면, 포함된 객체가 포함하는 객체로부터 독립적으로 존재하지 못하는 방식으로 서로 가지고 있는 관계를 맺고 있다는 뜻이다. 식사가 에피타이저를 가지고 있을 뿐 아니라, 식사를 끝낸 후에는 에피타이저 역시 사라져버린다는 것 역시 알 수 있다.
>
>개념을 일반적으로 또는 엄밀하게 사용하면서 생겨나는 이 간극을 `집합`이라는 개념이 채워준다.집합이란 포함된 객체가 **독립적으로 존재**할 수 있는 조합을 뜻한다. 댛가은 학부를 가지고, 학부는 교수를 가진다. 하지만, 대학이 폐교되고 학부가 사라져도 교수들은 여전히 남아있다.
>
>대학과 학부의 관계는 엄밀한 의미로 사용한 조합의 관계이고, 학부와 교수의 관계는 집합의 관계이다.

### 8.5. 상속과 조합 중 하나 선택하기

상속은 코드를 배치하는 기술이다. 행동들은 각각의 객체들 속에 분산되어 있고, 이 객체들의 클래스 관계에 따라 정리되어 있다. 클래스 관계가 메세지의 자동화된 전달을 한다.

조합은 객체들 사이의 관계를 클래스의 상속 관계 속에 적어 놓을 필요가 없다. 객체들은 각자 독립적으로 존재하며, 그 대신 관계를 맺고 있는 객체를 알고 있어야 하며 직접 메세지를 전달해야 한다. 조합은 객체들에게 구조적 독립성을 보장해주지만 이는 직접 메세지를 전달해야 하는 대가를 치를 때에만 가능하다.

일반적으로 어떤것을 사용할지는 선택에 대한 문제이지만, 상속이 더 좋은 해결책이라고 확신할 수 없는 경우에는 조합을 사용하는 것이 좋다. 조합은 상속보다 내재적으로 훨씬 적은 의존성을 가지고 잇기 때문에 일반적으로 더 좋은 결과를 낳는다.

하지만, 위험요소가 적지만 그 대가가 클 때는 상속을 성택하는 것이 좋다.

#### 8.5.1. 상속의 결과 받아들이기

상속을 사용해야 할지 말아야 할지 현명하게 결정하기 위해서는 그 비용과 이득에 대해 이해가 필요하다.

- 상속의 이점

  코드의 4가지 목표인, 투명성, 적절성, 사용가능성, 모범서에대해서 2장에서 살펴보았다.

  상속 관계의 위쪽에서 정의된 메서드는 강력한 영향력을 가진다. 왜냐하면 상속 관계의 높이가 지렛대처럼 작동해서 그 자체의 영향력을 높이기 때문이다. 이 메서드를 변경하면 그 여파가 상속 관계를 따라 저 아래에까지 미친다. 때문에 제대로구조화된 상속 관계는 매우 **적절**하다.

  코드에 상속을 적용한 결과를 open-closed로 표현할 수 있다. 상속 관계는 확장에 open 되어 있고, 동시에 수정에는 closed 되어 있다. 기존 상속구조에 새로운 클래스를 추가하려 할 때 기존 코드를전혀 수정하지 않아도 된다. 그렇기 때문에 상속 관계는 **사용가능**하다. 새로운 하위클래스를 만들어 새로운 변형을 받아들이기가 매우 쉽다.

  대로 작성한 상속 관계는 확장도 쉽다. 상속관계는 추상화된 코드를 가지고 있기 떄문에 새로 추가되는 하위 클래스에 약간의 구체적인 변경만 추가하면 된다. 새로운 하위클래스를 만드려는 프로그래머는 기존의 상속관계를 보고 코드를 작성하기 때문에 **모범**이 된다.

  Integer와 Float는 Numeric의 하위 클래스로 구조화 되어 있다. 상위클래스와 하위클래스 사이의 관계는 `is-a`관계이며 매우 자연스럽다. 이 클래스들이 공통의 추상화 코드를 공유하는 것은 가장 최적화된 방법이다.

- 상속의 비용

  상속을 사용하는데 따르는 우려가 두 가지가 있다.

  하나는 상속이 어울리지 않는 문제를 상속을 이용하여 해결하려 할 수 있다.  다른 하나는 상속이 적절한 방법일지라도 다른 프로그래머가 우리가 작성한 코드를 다른 방식으로 사용할 수 있다는점이다. 다른 프로그래머는 우리가 만든 행동이 필요하지만 상속이 강제하는 의존성을 받아들이고 싶지 않을 수 있다.

  상속은 '내가 실수하면 어떤일이 벌어질까?'라는 질문에 신중하게 생각해보아야 한다. 상속은 강력한 의존성을 만들어 내기 때문이다.

  그리고 상속을 사용할 떄 얼마나 많은 사람이 내가 만든 코드를 사용할지 역시 고려해야 한다. 많은 사람이 만지는 코드라면 변경에 대해서 예상하기 어려워 질 수 있다. 때문에, 어플리케이션의 인터페이스에 상속 관례를 추가하는 일은 더더욱 올바른 선택이 아닐 것이다.

  객체를 상속 받아야만 행동을 가져올 수 있는 프레임워크를 만드는 것은 좋지 않다. 누군가의 어플리케이션은 이미 자신의 상속 관계를 가지고 있기 때문에 우리가 만든 프레임워크를 상속받는 것 자체가 불가능 할 수도있다.

#### 8.5.2. 조합의 결과 받아들이기

상속과 조합은 기본적으로 두 가지 지점에서 다르다. 조합된 객체는 클래스의 상속 관계에 의존하지 않는다. 그리고 수신한 메세지를 직접 전달한다. 이러한 차이점으로 이점과 비용또한 달라진다.

- 조합의 이점

  조합을 사용하면 명확한 책임과명료한 인터페이스를 갖는 자긍ㄴ 객체를 여럿 만들게 되는 경향이 있다.

  작은 객체들은 하나의 책임만을 가지고 있고 자신의 행동을 직접 명시한다. 즉, **투명한**객체들이며 수정사항이 발생했을 경우 코드를 이해하기 쉽고 어떤일이 벌어질지 예상하기도 좋다. 또한 상속구조로부터 독립적이기 때문에 위에서 발생한 변화에 영향을 덜 받는다.

  조합된 객체는 자신의 부분들을 인터페이스를 통해 관리하기 때문에 한 부분을 새로 추가하는 것이 보다 쉽다. 조합된 객체의 관점에서 보면 이미 있던 한 부분의 변형된 형태를 추가한다는 것은 충분히 말이 되는, **적절한** 것이며, 자기 내부의 코드는 수정하지 않아도 된다.

  조합에 관여하는 객체들은 본질적으로 그 크기가 작으며, 구조적으로 독립되어 있고 잘정의된 인터페이스를 가지고 있다. 결국 잘 조합된 객체는 새로운 환경에서도 손쉽게 **사용**할 수 있다.

  조합이 이끌어 낼 수 있는 최고의 시나리오를 상상해 보면 어플리케이션이 작고, 추가하거나 제거하기 쉽고,확장하기용이한 객체들로 이루어지는 것이다. 이런 어플리케이션은 변환에 유연하게대응할 수 있다.

- 조합의 비용

  상의 많은 일들이 그렇듯이 조합이 제공하는 이점은 조합의 약점에도 영향을 준다.

  조합된 객체는 여러 부분들과 관계를 맺기 때문에 각 부분을 쉽게 이해할 수 있더라도 이 부분들이 모여 전체가 작동하는 방식은 훨씬 불명확할 수 있다.

  개별 부분들이 투명하더라도 전체는 그렇지 않을 수 있다는 것이다.

  구조로부터의 독립성은 자동화되 메세지 전달을 포기하면서 얻은 것이다. 조합된 객체는 누구에게 어떤 메세지를 전달해야 할지 명확하게 알아야 하며, 메세지전달을 위한 동알한 코드가 여러 객체 속에 분산되어 존재하지만 조합은 이 코드를 한곳에 모아 줄 수 없다.

  즉, 조합을 사용하면 여러 부분으로 이루어진 객체를 훌륭하게 조립할 수 있지만 매우 비슷한 부분들을 정리해야 하는 상황에서는 별 도움을 주지 못한다.

#### 8.5.3. 올바른 관계 선택하기

고전적 상속, 모듈을 통한 역할 공유, 조랍은 각각의 기술이 해결할 수 있는 고유한 문제들에 대해 최고의 해결책을 제공해 준다.

상속과 조합에대한 프로그래머들의 조언들

> - 상속은 특수화이다.
> - 상속은 이미 존재하는 클래스들에 새로운 기능을 추가할 때 가장 잘 어울린다. 기존 크드의 대부분을 계속 사용하면서 상대적으로 적은 양의 새로운 코드를 추가하는 상황에 어울린다.
> - 주어진 행동이 자신의 부분들의 총합 이상일 때 조합을 사용하라

- `is-a`관계에서 상속 사용하기

- `has-a`관계에는 조합 사용하기

- `behave-like-a`관계에는 오리타입을 사용하기(모듈)

  코드 속에 숨어 있는 역할을 알아 볼 수 있는 두 가지 경우

  - 객체가 역할을 수행하고 있지만, 그 역할이 객체의 핵심적인 책임이 아닌경우

  - 코드의 여러 곳에서 특정 역할을 수행하려고 하는 경우

## 9. Designing Cost-Effective Tests

수정하기 쉬운 코드를 작성하는 일은 `객체지향 디자인을 이해하는 것`, `코드를 리팩터링 하는 법`, `수준 높은 테스트를 짜는 것` 을 필요로 한다.

테스트는 수정된 코드가 별 문제없이, 전체적인 작업 비용을 끌어올리지 않고, 여전히 잘 작동하는 것을 보증해준다. 좋은 테스트를 작성해 놓았다면 실제 코드를 수정한다해도 테스트를 다시 작성할 필요가 없다.

잘 디자인된 코드는 수정하고 쉽고, 리팩터링은 하나의 디자인을 다른 디자인으로 변형시키는 방법이며, 테스트는 리팩터링의 두려움에서 우리를 해방시켜준다.

### 9.1. 의도를 가지고 테스트하기

테스트는 버그를 줄여주며, 테스트를 먼저 작성하는 일은 어플리케이션의 디자인을 향상시킨다. 하지만, 테스트의 진정한 목표는 디자인의 목표와 동일하게 비용을 줄이는 것이다. 테스트를 작성하고 관리하고 실행하는데 드는 시간이 버그를 잡고 문서를 작성하는데 드는 시간보다 오래걸린다면 테스트를 작성하는 의미가 없다.

테스트 작성 비용이 너무 높은 문제를 해결하기위한 방법은 테스트를 더 잘 짜도록 수련하는 것이다. 테스트를 통해 좋은 가치를 얻기 위해서는 테스트의의도를 명확히 해야하며, 언제 그리고 어떻게 테스트해야 할지 알아야한다.

#### 9.1.1. 의도 파악

테스트는 많은 이점을 가져다 준다. 이 점을 명확히 이해하고 있다면 테스트를 작성하는 동기를 강하게 느낄 수 있다.

- **버그 찾아내기** : 테스트를 통해 초기에 버그들을 잡아낼 수 있다.
- **문서 제공하기** : 테스트자체가 좋은 문서가 된다.
- **디자인 결정 미루기** : 테스트는 디자인 결정을 안전하게 미루게 해주어 보다 완성도 높은 디자인으로 유도한다.
- **추상화 돕기** : 추상화된 코드는 유연한 디자인 요소지만, 코드 속에 전체의 작동을 명확하게 보여주는 지점이 없다. 코드의 기초가 확장되고 추상화된 코드가 여럿 자라나면, 점점 더 테스트가 필요해 진다. 테스트는 우리가 디자인 결정을 미루고 필요한 만큼 추상화된 코드를 만들 수 있도록 해준다.

- **디자인의 결점 드러내기** : 코드에 너무 많은 맥락이 존재한다면 테스트를 작성하기 어렵다. 객체 하나를 테스트하기 위해 다른 객체를 왕창 끌어와야 하며 이 코드는 의존성이 높아진다. 테스트를 작성하기 힘들다면 다른 객체들이 이 코드를 재사용하기 힘들 것이다. 하지만, 역은 성립하지 않는다. 테스트가 힘들다고해서 어플리케이션의 디자인에 문제가 있다는 뜻은 아니다. 우리의 목표는 최소한의 비용으로 테스트가 제공하는 이점을 최대한 누리는 것이다. 그렇기 때문에 꼭 필요한 것만 테스트하는, 느슨하게 결합된 테스트를 작성해야 한다.

#### 9.1.2. 무엇을 테스트할지 알기

대부분의 프로그래머들은 테스트를 너무 많이 짠다. 테스트에서 더 나은 가치를 얻기 위한 방법 중 하나는 테스트를 덜 짜는 것이다. 이를 위해서는 모든 것은 단 한 번만 테스트하고 제대로 된 곳에서 테스트해야 한다.

테스트에서 중복을 제거하면 어플리케이션의 수정에 맞춰 테스트를 수정해야 하는 비용을 줄일 수 있다. 그리고 테스트를 제대로 된 장소에 작성해 높으면 꼭 필요한 순간에만 테스트를 수정해도 된다. 테스트의 의도는 매우 뚜렷한다.

객체지향 어플리케이션은 여러 블랙박스가 서로 주고받는 메세지들의 연쇄하고 생각해보자. 모든 객체를 블랙박스처럼 취급하기 때문에 하나의 객체는 다른 객체가 무엇을 알고 있는지 잘 모른다. 그리고 자신의 경계 너머에 있는 다른객체와 메세지에 대해 아는데 한계가 존재한다.

잘 디자인된 객체는 명확한 경계가 있다. 각 객체는 아래 그림과 같다.

![image](https://user-images.githubusercontent.com/53181778/86564717-a0678480-bfa1-11ea-8ef6-5405304b292c.png)

바깥에서 안을 볼 수 없고 안에서 밖을 볼 수 없다. 그리고 객체가 인정하는 메세지만 밀폐된 airlock을 통과할 수 있다.

어플리케이션에 적용가능한 디자인 원칙은 테스트에도 동일하게 적용할 수 있다. 모든 테스트는 이미 존재하는 클래스를 사용하는 또 하나의 어플리케이션이고 객체일 뿐이다. 테스트가 기존 클래스들과 결합될수록 테스트와 클래스는 서로얽혀 들어가고 불필요하게 수정해야 하는 상황에 더욱 빈번히 노출된다.

모든 객체에서 가장 안정적인 것은 퍼블릭 인터페이스이다. **즉, 퍼블릭 인터페이스에 정의된 메세지를 테스트하는 것이 좋은 테스트이다.** 객체 내부를 뚫고 들어가는 테스트는 좋지 않다.

테스트는 객체의 경계에 있는 메세지들에 집중해야 한다. 아래 그림에서 Foo에 들어가는 메세지는 Foo의 퍼블릭인터페이스를 규정한다. Foo 는 자신의 인터페이스를 테스트할 책임이 있고 해당 메시지가 반환하는 값을 검증구문을 가지고 테스트한다. 메세지가 반환하는 값을 검증하는 테스트는 상태를 테스트하는 것이다. 일반적으로 이런 테스트는 특정정 메세지가 반환한 값이 기대값과 같은지 검증한다. Foo가 Bar에게 메세지를 내보내는 모습도 보여준다. Foo가 보낸 메세지는 Bar의 관점에서는 들어오는 메세지이며, 이는 Bar의 퍼블릭 인터페이스의 한 부분이며 상태에 대한 모든 테스트는 Bar에 속해야 한다. Foo는 자신의 밖으로 나가는 메세지의 상태를 테스트할 필요도 없고 테스트해서도 안된다. 객체는 오직 자신의 퍼블릭 인터페이스에 해당하는 메세지만을 검증해야 하며 이것이 테스트의 원칙이다. 이 원칙을 따르면 메세지의 반환값을 테스트하는 코드가 위치할 곳은 단 한곳이며 불필요한 중복을 막을 수 있다.

![image](https://user-images.githubusercontent.com/53181778/86566551-d5290b00-bfa4-11ea-94dc-3d1a45d9c98b.png)

밖으로 나가는 메세지가 반환하는 상태값을 테스트할 필요가 없다는 것이 밖으로 나가는 메세지를 테스트할 필요가 없다는 것은 아니다. 밖으로 나가는 메세지의 종류는 두 가지가 있으며, 그 중 한가지에 대해서는 다른 종류의 테스트를 해야한다.

밖으로 나가는 메세지 중에 어떤것은 어플리케이션에 별 영향을 주지 않는다. 때문에 이 메세지에 관심을 가지는 것은 송신자뿐이다. 송신자는 메세지가 반환하는 결과에 관심을 갖는다. 반면, 어플리케이션의 다른 부분들은 **메세지가 보내졌는지**는 관심이 없다. 이런 종류의 밖으로 나가는 메세지를 `쿼리`라고 부른다. 이런 메세지는 송신자 객체가 테스트할 필요는 없다. 쿼리 메세지는 수신자 객체의 퍼블릭 인터페이스를 이루며, **수신자 객체가 상태값에 대하니 필요한 테스트를 모두 구현**하고 있다.

그렇다면 무엇을 테스트해야 할까? **들어오는 메세지**에 대해서는 **메세지가 반환하는 상태**를 테스트한다. **밖으로 나가는 커맨드 메세지**에 대해서는 이 **메세지가 제대로 전송되었는지** 테스트해야 한다 **밖으로 나가는 쿼리 메세지는 테스트할 필요가 없다**.

어플리케이션의 객체들이 퍼블릭 인터페이스만을 충실하게 따르며 소통하고 있다면 테스트는 이 이상의 것을 알 필요가 없다. 최소한의 메세지들만 테스트하면 객체의 내부 행동이 변경되었을 경우에도 테스트의 변경은 필요가 없다. 밖으로 나가는 메세지가 제대로 전송되었는지만 테스트하면 된다. 퍼블릭 인터페이스가 안정적으로 유지만 된다면 테스트를 재작성할 필요가 없는 것이다.

#### 9.1.3. 언제 테스트할지 알기

테스트를 먼저 작성하는 것이 좋지만, 힘들 경우가 있다. 제대로 디자인 되어 있지 않은 어플리케이션의 코드를 작성한 이후에 테스트를 작성하는 것은 어렵다 왜냐하면 테스트는 코드를 재사용하는 것인데 이 어플리케이션에는 재사용할 수 있는 코드가 없기 때문이다.

테스트를 먼저 작성하면 객체를 처음 만드는 순간부터 객체 속에 재사용 가능성을 각인시키게 된다. 하지만 테스트를 먼저 작성하는 것만으로 제대로 디자인된 어플리케이션이 완성되는 것은 아니라는 사실을 명심하자. 테스트를 먼저 작성하면서 얻을 수 있는 코드의 재사용가능성은 좋은 것이지만, 여전히 좋은 디자인의 필수요건을 갖추지 못하고 있을 수 있다.

가끔은 경험이 많은 프로그래머도 문제를 spike해본다. 스파이크란 일단 테스트없이 코드를 작성하면서 이것저것 실험해 보는 것이다. 실험을 통해 해결책이 명확히 떠오르지 않는 문제를 이리 저리 탐구해보는 행동이다. 문제의 핵심이 보이고 디자인이 떠오르면 테스트를 먼저 작성하는 방식으로 돌아간다.

각자의 판단에 따라 다양한 방식을 취할 수 있지만, 이것이 테스트를 생략해도 된다는 의미는 아니다. 테스트도 없는 코드는 그저 테스트할 수 없는 레거시 코드에 불과하다.

#### 9.1.4. 어떻게 테스트할지 알기

가장 대중적인 프레임워크를 사용하는 데는 그 이유가 있다. 가장 대중적인 프레임워크는 풍부한 자원을 보장한다. MiniTest와 RSpec은 다른 철학을 가지지만 모두 훌륭한 프레임워크이다.

어떤 프레임워크를 사용할지 결정해야할 뿐만 아니라, 테스트 주도 개발(TDD)와 행동 주도 개발(BDD) 사이에서도 고민해야 한다. 두 방식은 정반대의 것이 아니며 깔끔하게 한가지만 선택할 수도 없다.  아래 그림과 같이 서로 이어지는 방식이라고 생각하면 좋다. 각자의 기준에 따라 정하면 되는 부분이다.

![image](https://user-images.githubusercontent.com/53181778/86570886-98144700-bfab-11ea-8321-c7dc17cfca17.png)

두 스타일 모두 테스트를 먼저 작성한다. BDD는 밖에서 안으로 들어오는 접근을 취하며 어플리케이션의 가장 밖에 있는 객체들을 먼저 만들고 당장 필요하지만 아직 만들어지지 않은 객체들을 임시로 만들어 점점 안쪽으로 들어온다.

TDD는 안에서 밖으로 나가는 접근을 취한다. 보통 도메인 객체에 대한 테스트로 시작해서, 이렇게 만든 도메인 객체를 재사용하면서 바로 바깥 층위의 테스트 코드를 작성한다.

두 개의 장단점은 다음 절에서 살펴보자.

테스트를 작성할 때에는 어플리케이션의 객체들이 크게 두 카테고리로 구분될 수 있다고 생각하면 좋다. 하나는 지금 테스트하고 있는 객체들이 포함되는 카테고리이다. 이 객체들을 **테스트 중인 객체**라고 부를 것이다. 두 번째 카테고리는 그 외의 모든 객체를 포함한다.

우리는 당연히 첫 번째 카테고리에 속한 객체를 알아야 하고, 두 번째 카테고리에 속한 객체에 대해서는 최대한 무지해야 한다.

일단 테스트 중인 객체에만 초점을 맞추고 테스트하는 관점을 선택해야 한다.

> MiniTest 프레임워크
>
> 이 책에서는 MiniTest를 이용한다.

### 9.2. 들어오는 메세지 테스트하기

들어오는 메세지들은 객체의 퍼블릭 인터페이스이며 객체가 외부 세계에 보여지는 모습을 형성한다. 어플리케이션의 다른 객체들은 이 메세지의 시그니처와 그  반환 결과에 의존하고 있기 때문에 이 메세지들은 테스트해야 한다.

3장의 코드인 Wheel과 Gear 클래스를 이용하여 테스트를 작성해보자.

```ruby
class Wheel
    attr_reader :rim, :tire
    def initialize(rim, tire)
        @rim = rim
        @tire = tire
    end

    def diameter
        rim + (tire * 2)
    end
    # ...
end

class Gear
    attr_reader :chainring, :cog, :rim, :tire
    def initialize(args)
        @chainring = args[:chainring]
        @cog = args[:cog]
        @rim = args[:rim]
        @tire = args[:tire]
    end

    def gear_inches
        ratio * Wheel.new(rim, tire).diameter
    end
    26
    def ratio
        chainring / cog.to_f
    end
    # ...
end
```

Wheel은 들어오는 메세지 diameter에 반응한다. 그리고 Gear는 두 개의 들어오는 메세지인 gear_inches와 ratio에 반응한다.

#### 9.2.1. 사용하지 않는 인터페이스 삭제하기

들어오는 메세지는 이 메세지에 의존하는 딸린 객체들을 가지고 있다. 아래 표를 보면 알 수 있다. 테스트 중인 객체가 들어오는 메세지를 직접 구현하지 않았다면 객체는 이 메세지에 의존하고 있을 수도 있다.

테스트 중인 객체를 가지고 표를 만들때 들어오는 메세지가 딸린 객체를 가지고 있지 않다면 메세지가 실제로 들어오는 메세지인지를 의심해 보아야 한다. 아무도 전송하지 않는 메세지를 만들 필요가 있을까? 사실 이런 메세지는 들어오는 메세지가 전혀 아니다. 미래를 추측하려는 좋지 않은 시도의 결과물일 뿐이다.

들어오는 메세지에 딸린 객체가 없다면 메세지는 테스트할 필요도 없다. 그냥 지워버리자.

![image](https://user-images.githubusercontent.com/53181778/86574932-7fa72b00-bfb1-11ea-9a6c-9700ed024cd6.png)

코드를 지우는 것이 내키지 않더라도 일단은 지우는 것이 좋다. 사용하지 않는 코드를 유지하는 비용은 더욱더 크기 때문이다.

#### 9.2.2. 퍼블릭 인터페이스 검증하기

들어오는 메세지들은 머세지가 반환하는 값이나 상태를 검증하는 방식으로 테스트를 한다. 들어오는 메세지를 테스트하는 첫 번째 단계는 여러 상황에서 언제나 올바른 값을 반환하는지 확인하는 것이다.

아래 코드는 Wheel의 diameter 메서드를 테스트 한다. `assert_in_delta`함수를 이용해 지름이 29가 맞는지 검증한다.

```ruby
class WheelTest < MiniTest::Unit::TestCase

    def test_calculates_diameter
        wheel = Wheel.new(26, 1.5)

        assert_in_delta(29,
            wheel.diameter,
            0.01)
    end
end
```

이 테스트는 매우 단순하다. Wheel은 어떤 숨겨진 의존성도 없기 때문에 이 테스트를 실해애하기 위해 어플리케이션의 다른 객체를 생성해야 하는 번거로움도 없다. Wheel의 디자인 덕분에 어플리케이션의 다른 클래스로부터 독립적으로 테스트할 수 있다.

Gear를 테스트 하는것은 조금 다른 문제를 발생시킨다. Gear는 Wheel보다 몇 개의 인자를 더 필요로 한다.

```ruby
class GearTest < MiniTest::Unit::TestCase

    def test_calculates_gear_inches
        gear = Gear.new(
            chainring: 52,
            og: 11,
            rim: 26,
            tire: 1.5 )

        assert_in_delta(137.1,
            gear.gear_inches,
            0.01)
    end
end
```

gear_inches 테스트는 diameter 테스트와 비슷해보이지만 diameter테스트에는 없던 객체의 얽힘이 있다. gear_inches 메서드는 무조건 새로운 Wheel 객체를 만들어 사용한다. Gear와 Wheel은 코드와 테스트에서 서로 결합되어 있는 것이다.

Gear_inches 메서드는 새로운 객체를 만들고 사용한다. 이러한 사실은 코드의 수정이 테스트의 수정을 야기할 확률이 높아진다는 것을 의미하지만, 단순히 테스트코드만을 보고는 깊이 숨어 있는 결합의 문제를 찾기 어렵다. gear_inches가 올바른 값을 반환하는지 검증하려 하고, 그 결과는 성공적이지만, 위험이 숨어있는 것이다.

만약 Wheel의 인스턴스를 만드는데 많은 비용이 든다면, Gear 테스트 역시 비용을 소비하고 있는 것이다. 테스트 자체는 Wheel에 대해 아무런 관심이 비용을 소비하고 있는 것이다.

Gear에 문제는 없지만 Wheel이 고장났다면 Gear를 테스트하지만 문제는 엉뚱한 곳에서 발생하게 될 것이다. 이는 테스트에 대한 잘못된 정보를 제공해 줄 수있다.

#### 9.2.3. 테스트 중인 객체 고립시키기

Gear를 독립적으로 테스트 할 수 없다는 것은 Gear가 특정한 맥락에 묶여 있고, Gear를 재사용하기 어렵다는 것을 말해준다.  Gear를 Wheel과 분리할 필요가 있다.

3장에서는 Gear에서 Wheel을 만드는 부분을 제거해서 이런 결합을 제거했다. Gear는 diameter를 이해하는 객체를 주입 받는다.

```ruby
class Gear
    attr_reader :chainring, :cog, :wheel
    def initialize(args)
        @chainring = args[:chainring]
        @cog = args[:cog]
        @wheel = args[:wheel]
    end

    def gear_inches
        # The object in the'wheel' variable
        # plays the 'Diameterizable' role.
        ratio * wheel.diameter
    end

    def ratio
        chainring / cog.to_f
    end
    # ...
end
```

코드를 이런식으로 변경하는 것은 발상의 전환이다. Gear는 더 이상 주입된 객체의 클래스에 관심을 갖지 않는다. 그저 객체가 diameter 메서드를 구현한다고 믿는다. diameter메서드는 특정 역할의 퍼블릭 인터페이스를 이루고 있고, 그 역할을 Diameterizable이라고 불러도 무방할 것이다.

이제 Gear와 Wheel 사이의 결합이 깨졌기 때문에 Gear를 만들기 위해서는 매번 Diameterizable의 인스턴스를 주입해주어야 한다.

같아 보이지만, Gear에 Wheel을 주입하는 것과 Diameterizable을 주입하는 것은 차원이 다른 이야기 이다. 입력받는 객체의 클래스에 보다 유연해질 수 있고, 다양한 디자인과 테스트를 시도할 수 있다. 다만, 이 코드에서는 Diameterizable에 해당하는 객체가 Wheel 뿐이다.

Wheel은 Diameterizable의 인터페이스를 제대로 구현하고 있다. 아래 테스트를 수정한 코드를 살펴보자.

```ruby
class GearTest < MiniTest::Unit::TestCase
    def test_calculates_gear_inches
        gear = Gear.new(
            chainring: 52,
            cog: 11,
            wheel: Wheel.new(26, 1.5))

        assert_in_delta(137.1,
            gear.gear_inches,
            0.01)
    end
end
```

Diameterizableㄹ 주입하는 자리에 Wheel을 사용하면서 테스트 코드는 실제 코드를 정확히 반영하게 되었다. 이제 실제 코드에서도 그리고 테스트에서도 Gear가 Wheel을 사용한다는 점이 명확해 졌다. 두 객체 사이의 숨겨진 결합은 공개적으로 드러나게 되었다.

이 테스트는 충분히 빠르지만 이 속도는 우연의 결과에 불과하다. gear_inches테스트가 고립된 것도 아니고, 다른 코드와의 결합도 깨지지 않았다. 그저 이 테스트와 결합된 코드 역시 빠르게 실행될 뿐이다.

또한 Wheel이 Diameterizable의 역할을 수행하고 있다는 것 명확히 드러나지 않는다. 이 역할은 우리의 머리속에만 존재하는 것이다.

역할은 눈에 보이지도 않고 Gear와 Wheel이 결합되어 있지만 이러한 방식으로 테스트하는 것은 한가지 장점이 있다.

#### 9.2.4. 클래스를 사용해서 의존성 주입하기.

테스트 코드가 실제 코드와 동일한 협업 객체를 사용하면 테스트는 실패해야 할 때 언제나 실패해준다는 장점이 있다.

예시를 살펴보자, Diameterizable의 퍼블릭 인터페이스가 변경되었다. 예로, Wheel 클래스의 diameter 메서드가 width라는 이름으로 바뀌었다.

```ruby
class Wheel
    attr_reader :rim, :tire
    def initialize(rim, tire)
        @rim = rim
        @tire = tire
    end

    def width # <—— used to be 'diameter'
        rim + (tire * 2)
    end
    # ...
end
```

Gear에서 해당 메세지를 전송하는 부분을 까먹고 수정하지 않았다면, 여전히 diameter를 전송할 것이다.

```ruby
class Gear
    # ...
    def gear_inches
        ratio * wheel.diameter # <—- obsolete
    end
end
```

Gear 테스트는 Wheel의 인스턴스를 주입하고 있고 이 Wheel은 width를 구현하고 있다. 하지만 diameter 메세지를 전송하기 때문에 이 테스트는 실패한다.

```
Gear
	ERROR 	test_calculates_gear_inches
			undefined method 'diameter'
```

이 실패는 이해하기 쉽다. 협업하는 두 객체가 있는데 수신자의 메세지가 변경되었고 당연히 이러한 메세지를 출력할 것이다. Wheel을 수정했기 때문에 Gear도 수정해야 하고, 이 테스트는 실패해야하는 시점에 정확히 실패를 해주었다.

하지만, 추상화된 코드를 테스트하는 것이 훨씬 나은 결과를 가져다줄 수 있는 경우도 있다. 이 문제를 설명하려면 극단적인 예를 들어야 한다. 몇 백개의 Diameterizable을 가지고 있다면 우리의 의도를 잘 드러내는 테스트를 작성하기 위해 이들 중 어느 것을 사용해야 할까? Diameterizable을 생성하는 비용이 매우 비싸다면 어떻게 해야 할까? 불필요하고 시간을 많이 잡아먹는 코드를 실행하지 않으려면 어떻게 해야 할까?

#### 9.2.5. 역할에 대한 의존성 주입하기

Wheel 클래스와 Diameterizable 역할은 밀접하게 연관되어 있다. 하지만 테스트를 제대로 이해하기 위해서는 둘을 구분하는 것이 필요하다. 아래 그림을 살펴보자.



![image](https://user-images.githubusercontent.com/53181778/86580786-22fc3e00-bfba-11ea-880b-62c8be3dc62e.png)

Diameterizable의 역할은 서로 다른 객체가 diameter를 가질 수 있다는 생각을 추상화한 것이다. 다른 모든 추상화가 그렇듯이, 이 추상적인 역할은 추상화의 근원이 되는 구체적인 내용보다 훨씬 안정적이다. 하지만 위에서 본 상황에서는 그 정반대이다.

위 코드에서 객체가 Diameterizable에 대한 지식에 의존하는 곳이 두 군데 있다. 첫째는 Gear는 자신이 Diameterizable의 인터페이스를 알고 있다고 생각한다. 즉, Gear는 주입된 객체에게 diameter를 전송해도 된다고 생각한다. 둘째, 주입하기 위해 객체를 생성하는 코드는 Wheel이 diameter(인터페이스)를 구현하고 있다고 생각한다. 이제 Diameterizable이 변경되면서 문제가 발생한다.

의존성 주입을 사용하는 궁극적인 이유는 이미 있는 코드를 수정하지 않고도 구체 클래스들을 서로 대체해서 사용하기 위함이다.

안타깝게도 이번 예에서는 주입된 객체의 클래스가 변경된 것이 아니라, 역할의 인터페이스가 수정된 것이다. Wheel을 주입하는 것은 여전히 올바른 접근법이지만, 이 Wheel에게 diameter 메세지를 전송하는것은 문제가 된다.

여러 종류의 Diameterizable를 가지고 있다면, 이 역할의 관념을 명확히 전달하고 싶을 수 있다. 우리가 BDD방식을 따르고 있다면 어플리케이션 속에 이 역할을 수행하는 객체가 아직 없을 수 있다. 테스트를 통과하기 위해 무언가를 만들어야 하는 상황에 처할 수 있다.

- 테스트 더블(Test Doubles)만들기

  다음 예시는 Diameterizable 역할을 수행하는 가짜 객체 또는 테스트 더블을 만드는 방법을 보여준다. Diameterizable의 인터페이스를 예전의 diameter 메서드를 가지고 있는 상태로 되돌리고, Wheel 역시 이 메서드를 제대로 구현하고 있으며 Gear도 diameter메세지를 전송하고 있다 가정하자. DiameterDouble이라는 가짜 클래스를 만들어 테스트를 진행한다.

  ```ruby
  # Create a player of the ‘Diameterizable’ role
  class DiameterDouble
      def diameter
          10
      end
  end

  class GearTest < MiniTest::Unit::TestCase
      def test_calculates_gear_inches
          gear = Gear.new(
              chainring: 52,
              cog: 11,
              wheel: DiameterDouble.new)

          assert_in_delta(47.27,
              gear.gear_inches,
              0.01)
      end
  end
  ```

  이 테스트 더블은 역할을 수행하는 객체의 표준적인 형태로써, 전적으로 테스트만을 위한 것이다 테스트 더블은 만들기가 매우 쉽다. 가장 중심이 되는 기능만 도드라지게 보여주고 테스트 더블이 대신하고 있는 실제 객체의 세세한 특징들은 뒤로 감춘다.

  위 테스트 더블은 diameter를 스텁(stubs)하고 있다. 즉, 이미 정해진 diameter 값을 반환하는 메세지를 가지고 있다.

  대부분의 테스트 프레임워크는 테스트 더블을 만들고 반환값을 스텁하는 기능을 탑재하고 있다. 프레임워크를 이용하는 방법도 유용하지만, 간단한 테스트 더블은 위 예시처럼 루비 객체를 이용하여 직접 사용해도 무방하다.

  DiameterDouble은 mock이 아니다. 많은 사람들이 혼동하지만 mock과는 완전히 다른 것이다. 이 부분에 대해서는 나중에 살펴보자.

  테스트 더블을 주입하면 Gear테스트와 Wheel 클래스 사이의 결합을 끊을 수 있다.  Wheel이 느리게 작동하는 것을 신경쓰지 않아도 된며 테스트 역시 제대로 작동한다.

  ```
  GearTest
   PASS test_calculates_gear_inches
  ```

- 꿈속에서 살기

  이제 다시 우리의 코드가 저 앞에서 언급했던 변경에 직면했다고 가정해 보자. 메서드가 width로 변경되었다면 Wheel에는 이 변경을 적용했지만, Gear는 수정하지 않았다. 다시 어플리케이션에 문제가 발생했다.

  테스트 더블을 사용한 테스트는 성공했지만, Wheel을 주입했던 테스트는 실패할 것이다.

  테스트 더블이 성공했다고는 하지만, 실제 어플리케이션은 제대로 작동하지 않을 것이다. 테스트는 문젝자 없다고 말하지만 실제로는 문제가 있는 것이다. 이러한 점으로 스텁이 테스트를 위태롭게 만든다고 말하는 사람들이 있다.

  어플리케이션은 Diameterizable  역할을 가지고 있다. 처음에는 Wheel하나만 이역할을 수행했지만, DiamterDouble를 만들면서 이 역할을 수행하는 두 번째 객체가 함께 만들어졌다. 역할의 인터페이스가 변경되었다면 역할 수행자들 모두에게 이 변화를 반영해야 한다. 하지만 테스트 코드속에 있는 수행자는 깜빡 잊어버리기 쉽다. 문제는 Wheel에는 새로운 인터페이스가 반영이 됐지만, DiameterDouble에는 반영이 되지 않은 것이다.

- 역할을 문서화하기 위한 테스트 사용

  위의 문제가 발생한 이유는 역할이 눈에 잘 띄지 않기 때문이다. 어플리케이션에서 Diameterizable 가 정의되어 있다. 라고 말할 수 있는 곳이 없다. 역할이 존재하는지를 알아내는 것 자체가 어려운 문제이며 테스트 더블을 깜빡 잊어버린 것은 어쩌면 당연하다.

  역할을 더욱 선명하게 드러내는 방법 중 하나는 Wheel이 주어진 역할을 수행하고 있다고 명시적으로 선언하는 것이다.

  ```ruby
  class WheelTest < MiniTest::Unit::TestCase
      def setup
          @wheel = Wheel.new(26, 1.5)
      end

      def test_implements_the_diameterizable_interface
          assert_respond_to(@wheel, :diameter)
      end

      def test_calculates_diameter
          wheel = Wheel.new(26, 1.5)

          assert_in_delta(29,
              wheel.diameter,
              0.01)
      end
  end
  ```

  test_implements_the_diameterizable_interface를 통해 역할을 테스트 하는 방법을 명시적으로 보여주고 있지만, 충분히 만족스럽지 않다. 이는 사실 불안정한 방법이다.

  첫째, 다른 Diameterizable는 이 테스트를 사용할 수 없다.

  둘째, 여전히 테스트 더블의 실수를 잡아주지 못한다.

  일단은 역할을 위한 테스트가 필요하다는 것만 알고 넘어가고 추후에 이 문제를 어떻게 해결할 수 있는지 알아보자.

  BDD의 밖에서 안으로 접근하는 방법을 취하면 TDD를 사용할 때 보다 실수를 줄일 수 있지만, 둘 다 완벽하지 않다.

### 9.3. 프라이빗 메서드 테스트하기

가끔씩 테스트 중인 객체가 자기 자신에게 메세지를 전송할 때가 있다. self에 전송하는 메세지들은 수신자의 프라이빗 인터페이스에 정의된 메서드를 실행시킨다.

이상적인 어플리케이션에서는 프라이빗 메서드를 신경쓸 필요가 없지만, 현실 세계는 이상적이지 않기 때문에 프라이빗 메서드에도 테스트를 사용하는 경우가 많다.

#### 9.3.1. 테스트에서 프라이빗 메서드 무시하기

프라이빗 메서드를 테스트하지 말아야 할 이유는 여러가지가 있다.

1. 프라이빗 메서드는 객체 안에 숨어 있어 외부에는 노출되지 않고, 문제가 발생했다 하더라도 이미 테스트를 붙여 놓은 퍼블릭 메서드를 통해 호출되었기 때문에 별도의 테스트를 작성할 필요가 없다.
2. 프라이빗 메서드는 불안정하기 때문에 수정의 가능성이 많다. 여기에 테스트를 만드는 것은 수정에 대한 비용을 높인다.
3. 프라이빗 메서드를 테스트하면 다른 프로그래머가 이 메서드를 퍼블릭하게 사용해도 된다고 오해할 수 있다.

#### 9.3.2. 테스트 중인 클래스에서 프라이빗 메서드 제거하기

프라이빗 메서드 테스트를 없애는 가장 간단한 방법은 프라이빗 메서드를 제거하는 것이다.

프라이빗 메서드가 너무 많은 객체가 있다면 잘못된 책임을 가지고 있는 것은 아닌지 따져보아야 한다. 메서드들을 새로운 객체로 옮길수는 없는지도 확인해야 한다. 다시 말해 퍼블릭 메서드로 구성할 수 없는지 검토해 보아야 한다.

#### 9.2.3. 프라이빗 메서드 테스트 선택하기

모든 것이 불확실할 때에는 좀 과격한 방법을 쓸 수 밖에 없다. 충분한 정보를 얻기 까지 프라이빗 메서드 속에숨겨두는 것이다. 현재 생각할 수 있는 최상의 인터페이스 아래에 코드를 잠시 숨겨 놓는 것이다.

이런 경우, 프라이빗 메서드에 대한 테스트는 어플리케이션의 어딘가에 문제가 발생했다는 것을 위해 필요한 것이 아니다. 그것은 퍼블릭 인터페이스가 이미 수행하고 있는 부분이다. 프라이빗 메서드에 대한 테스트는 문제가 발생한 바로 그 부분을 정확히 짚어주는데 의의가 있다. 이는 리팩토링을 편리하게 해준다.

프라이빗 메서드를 테스트할 때 염두에 두어야 하는 기본 원칙은 "절대 테스트 하지마라"이다.

### 9.4. 밖으로 나가는 메세지 테스트하기

객체에서 밖으로 나가는 메세지는 `쿼리 메세지`와 `커맨드 메세지`로 나뉜다. 쿼리 메세지는 전송하는 송신자에게만 중요한 메세지이고, 커맨드 메세지는 어플리케이션의 다른 객체들에게도 영향을 미친다.

#### 9.4.1. 쿼리 메세지 무시하기

쿼리 메세지는 다른 객체에 예상치 못한 영향력을 행사하지 않는다.

```ruby
class Gear
    # ...
    def gear_inches
        ratio * wheel.diameter
    end
end
```

gear_inches를 제외한 어플리케이션의 다른 모든 부분은 diameter가 전송되었다는 사살에 관심이 없다. diameter메서드는 아무런 부작용도 낳지 않는다. 메세지를 실행해도 눈에 보이는 흔적을 남기지 않고, 이 실행에 의존하는 객체도 없다.

자기 자신에게 전달하는 메세지에 대한 테스트가 필요하지 않은 것 처럼 이역시 테스트가 필요 없다. diameter를 전송해서 어떤일이 벌어지든 그것은 Gear 내부의 문제일 뿐이다. diameter가 제대로 작동하는지 테스트하는 것은 Wheel의 담당이지 Gear의 담당이 아니다.

Gear는 gear_inches가 적절한 결과를 반환하는지만 테스트하면 된다.

#### 9.4.2. 커맨드 메세지 검증하기

하지만, 가끔 메세지가 진짜 전송되었는지 확인해야할 필요가 있는 경우가 있다. 어플리케이션의 다른 부분이 메세지에 의존하고 있는 경우가 그렇다. 이런 경우는 메세지에 대해 테스트를 해야할 책임이 있으며, 실제로 전송되었는지 확인해야 한다.

이 문제를 살펴보기 위해 새 예시를 보자.

참가자들이 자전거 경주를 할때, 자전거에는 기어가 달려있다. Gear 클래스는 어플리케이션 전체에게 기어가 바뀌는 순간을 알려줄 책임이 있다. 어플리케이션은 이 정보를 가지고 자전거의 행동을 변경해야 한다.

아래 코드에서 Gear는 observer를 추가해서 이런 기능을 구현하려 한다. get_cog 또는 set_chainring 메서드를 실행하고, changed 메서드를 실행한다. 이 메서드가 observer에게 전송하고, 이떄 현재의 chainring과 cog값도 함께 보낸다.

```ruby
class Gear
    attr_reader :chainring, :cog, :wheel, :observer
    def initialize(args)
        # ...
        @observer = args[:observer]
    end

    # ...

    def set_cog(new_cog)
        @cog = new_cog
        changed
    end

    def set_chainring(new_chainring)
        @chainring = new_chainring
        changed
    end

    def changed
        observer.changed(chainring, cog)
    end
    # ...
end
```

Gear에게 새로운 책임이 주어졌다. cogs나 chaingrings가 변경되면 이 내용을 observer에게 알려주어야 한다. 이 새로운 책임은 기어 인치를 계산해야 하는 것 만큼이나 중요하다. 우리는 changed 메세지가 전송되어써는지를 테스트해야한다.

테스트는 메세지가 전송되었다는 사실을 검증해야할 뿐 아니라, observer의 changed 메서드가 무엇을 반환하는지와는 상관없이 작동해야 한다.

diameter메서드를 테스트하는 것이 Wheel의 책임이듯, changed의 결과를 검증하는 것은 observer의 책임이다. 이런 방식의 테스트는 테스트 코드의 중복을 낳고 유지보수 비용을 높인다.

중북을 피하려면 Gear의 changed가 무엇을 반환하는지 확인하지 않으면서도, Gear가 changed를 obsever에게 전송했다는 사실을 검증해야 한다. 다행히 mock을 사용하는 매우 쉬운 방법이 존재한다. mock은 행동에 대한 테스트이고, mock 객체가 어떤 메세지를 수신하기 원하는지, 즉 mock 객체가 기대하는 바를 테스트한다.

아래 테스트는 Gear가 주어진 책임을 충실히 이행하고 있다는 사실을 검증해 준다. observer가 어떻게 작동하는지에 대한 지식은 필요없으며 제대로 수신했다는 것만 확인한다.

```ruby
class GearTest < MiniTest::Unit::TestCase

    def setup
        @observer = MiniTest::Mock.
            @gear = Gear.new(
                chainring: 52,
                cog: 11,
                observer: @observer)
    end

    def test_notifies_observers_when_cogs_change
        @observer.expect(:changed, true, [52, 27])
        @gear.set_cog(27)
        @observer.verify
    end

    def test_notifies_observers_when_chainrings_change
        @observer.expect(:changed, true, [42, 11])
        @gear.set_chainring(42)
        @observer.verify
    end
end
```

이것이 mock을 사용하는 고전적인 패턴이다.

` @observer = MiniTest::Mock`로  Mock객체를 만들었다.  ` @observer.expect(:changed, true, [52, 27])`은 mock객체가 어떤 메세지를 기대하고 있는지 말해준다. 그 다음줄에서 이 기대를 충족시킬수 있는 행동을 유발하고, 그 다음줄에서 그 기대가 충족했는지 ` @observer.verify`로 확인한다.

만약 gear가 set_chainring을 수신하고 gear 내부에서 어떤일이 발생하는데 그 결과로 observer가 changed 메세지를 제대로 된 의자와 함께 수신하면 테스트는 통과한다.

목 객체가 메세지를 가지고 하는 일은 그저 메세지를 수신했다는 사실을 기억하는 것 뿐이다. 이 점을 주목하자. 테스트 중인 객체가 'observer'가 changed를 수신한 후에 반환하는 결과에 의존하고 있다면 목 객체가 적당한 값을 반환하도록 수정하면 된다.

observer를 목 객체로 대체했고, 목의 changed 메서드는 완벽히 아무것도 하지 않는다. 그럼에도 Gear는 정상동작한다. changed 메서드가 무엇을 하든지 전혀 관심이 없다. Gear의 역할은 여기까지다.

### 9.5 오리 타입 테스트하기

오리 타입을 어떻게 테스트할지, 테스트 더블이 무의미해지지 않도록 만드는 방법, 공유할 수 있는 테스트를 작성하는 법을 알아보자.

#### 9.5.1. 역할 테스트하기

5장에서 다루었던 Mechanic, TripCoordinator, Dirver클래스에 대한 테스트를 짜보자.

```ruby
class Mechanic
    def prepare_bicycle(bicycle)
        #...
    end
end

class TripCoordinator
    def buy_food(customers)
        #...
    end
end

class Driver
    def gas_up(vehicle)
        #...
    end
    def fill_water_tank(vehicle)
        #...
    end
end
```

이들 클래스 각각은 잘 갖춰진 퍼블릭 인터페이스를 가지고 있다. 하지만 Trip이 인터페이스를 가지고 여행 준비를 시작하려고 하자, Trip은 주어진 객체에게 어떤 메세지를 전송할지 결정하기 위해 객체의 클래스를 확인해야만 했다.

```ruby
class Trip
    attr_reader :bicycles, :customers, :vehicle

    def prepare(preparers)
        preparers.each {|preparer|
            case preparer
            when Mechanic
                preparer.prepare_bicycles(bicycles)
            when TripCoordinator
                preparer.buy_food(customers)
            when Driver
                preparer.gas_up(vehicle)
                preparer.fill_water_tank(vehicle)
            end
            }
    end
end
```

위 예시의 case 구분은 prepare를 이미 존재하는 세 개의 구체 클래스와 결합한다. 이는 유지보수 비용이 많이 든다.

안티패턴을 따르면서도 테스트가 없는 코드가 눈앞에 있다면, 테스트를 작성하기 전에 더 좋은 코드로 리팩토링 하는 것이 좋다. 

리팩토링은 첫 단계는 Preparer의 인터페이스를 결정하고, 모든 역할 수행자의 클래스 안에 이 인터페이스를 구현하는 것이다. 퍼블릭 인터페이스가 prepare_trip이라면, 아래 수정을 통해 개선할 수 있다.

```ruby
class Mechanic
    def prepare_trip(trip)
        trip.bicycles.each {|bicycle|
            prepare_bicycle(bicycle)}
    end

    # ...
end

class TripCoordinator
    def prepare_trip(trip)
        buy_food(trip.customers)
    end

    # ...
end

class Driver
    def prepare_trip(trip)
        vehicle = trip.vehicle
        gas_up(vehicle)
        fill_water_tank(vehicle)
    end
    # ...
end
```

이제 Preparer 역할을 수행하는 객체들을 만들었으니 Trip의 prepare 메서드는 훨씬 간단해 진다.

```ruby
class Trip
    attr_reader :bicycles, :customers, :vehicle

    def prepare(preparers)
        preparers.each {|preparer|
            preparer.prepare_trip(self)}
    end
end
```

리팩토링을 마쳤으니, 이제 테스트 코드를 작성해 보자.

위 코드는 Trip과 Preparers 사이의 협업을 포함하고 있다. 이 협업을 prearable이라고 생각하면 된다.

아래 PreparerInterfaceTest 모듈을 각 테스트에 include하여 각 객체의 prepare_trip 메서드가 제대로 반응하는지 검증하며 문서화 해준다.

```ruby
module PreparerInterfaceTest
    def test_implements_the_preparer_interface
        assert_respond_to(@object, :prepare_trip)
    end
end

class MechanicTest < MiniTest::Unit::TestCase
    include PreparerInterfaceTest

    def setup
        @mechanic = @object = Mechanic.new
    end

    # other tests which rely on @mechanic
end


class TripCoordinatorTest < MiniTest::Unit::TestCase
    include PreparerInterfaceTest

    def setup
        @trip_coordinator = @object = TripCoordinator.new
    end
end


class DriverTest < MiniTest::Unit::TestCase
    include PreparerInterfaceTest
    def setup
        @driver = @object = Driver.new
    end
end
```

PreparerInterfaceTest를 모듈 형태로 정의 했기 때문에 테스트를 한 번만 작성하고도 역할 수행 객체들이 테스트 코드를 재사용할 수 있다. 그리고 동시에 문서의 역할을 한다.

각 객체가 prepare_trip을 제대로 구현하고 있는지 검증했으므로, Trip이 메세지를 제대로 전송하고 있는지 확인도 필요하다.

밖으로 나가는 메세지가 제대로 전달되었는지 검증하려면 mock 객체를 만들어 이 객체가 기대하는 바를 정의하면 된다.

```ruby
class TripTest < MiniTest::Unit::TestCase

    def test_requests_trip_preparation
        @preparer = MiniTest::Mock.new
        @trip = Trip.new
        @preparer.expect(:prepare_trip, nil, [@trip])

        @trip.prepare([@preparer])
        @preparer.verify
    end
end
```

```
TripTest
	 PASS test_requests_trip_preparation
```

Preparer 역할데 대한 테스트는 끝났다. 이제 좀 더 어려운 문제, 테스트 더블이 테스트 중인 역할을 수행하도록만드는 문제로 되돌아갈 때이다.

#### 9.5.2. 테스트 더블을 확인하기 위해 역할 테스트 사용하기

앞의 꿈속에서 살기 절에서 본 문제는, 틀린 것을 올바르다고 잘못 알려주는 문제를 가지고 있었다. 이미 사라져버린 메서드를 테스트 더블이 스텁하고 있었기 때문에, 테스트는 실패하지 않고 무조건 성공을 하고 있다.

```ruby
class DiameterDouble
    def diameter # The interface changed to 'width',
        10 # but this double and Gear both
    end # still use 'diameter'.
end

class GearTest < MiniTest::Unit::TestCase
    def test_calculates_gear_inches
        gear = Gear.new(
            chainring: 52,
            cog: 11,
            wheel: DiameterDouble.new)

        assert_in_delta(47.27,
            gear.gear_inches,
            0.01)
    end
end
```

DiameterDouble은 diameter 메서드를 잘 수행하지만, 그렇기 때문에 테스트에 문제가 발생한다. Diameterizable의 인터페이스가 수정되면서 DiameterDouble이 더 이상 유효하지 않게 된 것이다. 하지만 테스트가 문제를 잡아내지 못하기 때문에 Gear가 정상적으로 작동한다는 착각을 하게 된다.

이 문제를 바로잡기 위해 WheelTest를 만들었다. Diameteriazble의 인터페이스를 눈으로 볼 수 있게 만들어서 이 문제를 해결했다. Wheel이 width 인터페이스를 구현하고 있는 Diameterizble의 역할을 수행하고 있다는 사실을 검증한다.

```ruby
class WheelTest < MiniTest::Unit::TestCase
	def setup
        @wheel = Wheel.new(26, 1.5)
    end

    def test_implements_the_diameterizable_interface
        assert_respond_to(@wheel, :width)
    end

    def test_calculates_diameter
        # ...
    end
end
```

이 테스트 속에는 우리의 위태로운 테스트를 수정하기 위해 사용할 수 있는 모든 재료가 들어 있다. 

문제를 해결하기 위한 첫 단계는 Wheel에서 test_implements_the_diameterizable_interface 테스트를 뽑아내서 새로운 모듈 속에 넣는 것이다.

```ruby
module DiameterizableInterfaceTest
    def test_implements_the_diameterizable_interface
        assert_respond_to(@object, :width)
    end
end
```

모듈을 만들었으면 모듈로 옮겨온 행동을 다시 WheelTest에 적용해야 한다. 모듈을 인클루드하고 Wheel을 가지고 @object를 초기화한다.

```ruby
class WheelTest < MiniTest::Unit::TestCase
    include DiameterizableInterfaceTest

    def setup
        @wheel = @object = Wheel.new(26, 1.5)
    end

    def test_calculates_diameter
        # ...
    end
end
```

WheelTest는 자신의 메서드를 모듈로 뽑아내기 전과 똑같이 작동한다. 

```
WheelTest
 PASS test_implements_the_diameterizable_interface
 PASS test_calculates_diameter
```

WheelTest가 여전히 잘 작동하고 있다는 건 참 다행스런 일이다. 하지만 이번 리팩터링은 단순히 코드를 이리저리 옮긴 것 이상의 의미를 가진다. 리패토링의 결과 독립적인 모듈을 얻었고, Diameterizable이 제대로 작동한다는 것을 검증해 줄 수 있다.

아래 코드는 GearTest에 모듈을 적용한 것이다. DiameterDoubleTest를 정의하지만 Gear를 테스하기 위한 것은 아니다. 제대로 된 테스트 더블을 사용하고 있는지 검증하기 위한 것이다.

```ruby
class DiameterDouble
    def diameter
        10
    end
end

# Prove the test double honors the interface this
# test expects.
class DiameterDoubleTest < MiniTest::Unit::TestCase
    include DiameterizableInterfaceTest

    def setup
        @object = DiameterDouble.new
    end
end

class GearTest < MiniTest::Unit::TestCase
    def test_calculates_gear_inches
        gear = Gear.new(
            chainring: 52,
            cog: 11,
            wheel: DiameterDouble.new)

        assert_in_delta(47.27,
            gear.gear_inches,
            0.01)
    end
end
```

이전 상태의 테스트에서는 DiameterDouble과 Gear 모두 잘못된 인터페이스를 사용하고 있었기 때문에 테스트가 통과했었다. 이번에는 테스트 더블이 주어진 역할을 올바르게 수행하고 있는지도 테스트한다. 테스트를 실행하면 드디어 에러가 출력된다.

```
DiameterDoubleTest
	FAIL 	test_implements_the_diameterizable_interface
			Expected #<DiameterDouble:...> (DiameterDouble)
			to respond to #width.
GearTest
	PASS 	test_calculates_gear_inches
```

이제 테스트 더블이 실패하는 것을 확인 할 수있고 아래의 코드를 추가하여 코드를 수정하면 된다.

```ruby
class DiameterDouble
    def width
        10
    end
end
```

테스트 더블을 수정하고 코드를 다시 돌려보면, 테스트는 GearTest에서 실패한다.

```
DiameterDoubleTest
	PASS 	test_implements_the_diameterizable_interface
	
GearTest
	ERROR 	test_calculates_gear_inches
			undefined method 'diameter'
				for #<DiameterDouble:0x0000010090a7f8>
					gear_test.rb:35:in 'gear_inches'
					gear_test.rb:86:in 'test_calculates_gear_inches'
```

diameter라는 메서드가 디파인 되어 있지 않다는 것을 알려준며, gear_inches에서 오류가 발생한다는 것을 알려준다. 이 코드를 수정하면 모든 과정이 끝난다.

```ruby
class Gear

    def gear_inches
        # finally, 'width' instead of 'diameter'
        ratio * wheel.width
    end

    # ...
end
```

마지막 수정을 거치고 나면 어플리케이션도 정상적으로 작동하고 모든 테스트를 성공적으로 통과한다.

```
DiameterDoubleTest
	PASS 	test_implements_the_diameterizable_interface

GearTest
	PASS 	test_calculates_gear_inches
```

