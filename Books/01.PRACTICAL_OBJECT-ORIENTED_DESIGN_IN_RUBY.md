# PRACTICAL OBJECT-ORIENTED DESIGN IN RUBY

>PRACTICAL OBJECT-ORIENTED DESIGN IN RUBY 책을 읽고 내용을 정리합니다.
>
>참고로, 번역본도 있지만 원서를 추천합니다. 오역된 부분이 많고 오타도 많이 보이네요.

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./README.md)

---

<!-- TOC -->

- [1. Object-Oriented Design](#1-object-oriented-design)
	- [1.1 객체 지향 디자인의 원칙과 디자인 패턴](#11-객체-지향-디자인의-원칙과-디자인-패턴)
	- [1.2 객체 지향 언어](#12-객체-지향-언어)
- [2. Designing Classes with a Single Responsibility](#2-designing-classes-with-a-single-responsibility)
	- [2.1. 클래스에 무엇이 포함될지 정하기](#21-클래스에-무엇이-포함될지-정하기)
		- [2.1.1. 클래스에 Method를 그룹핑하기](#211-클래스에-method를-그룹핑하기)
		- [2.1.2. 쉽게 수정가능한 코드를 구성하기](#212-쉽게-수정가능한-코드를-구성하기)
	- [2.2. 하나의 책임을 지는 클래스 만들기](#22-하나의-책임을-지는-클래스-만들기)
		- [2.2.1. 자전거와 기어](#221-자전거와-기어)
		- [2.2.2. 왜 단일 책임이 중요한가?](#222-왜-단일-책임이-중요한가)
		- [2.2.3. 클래스가 단일 책임을 가지는지 판단하기](#223-클래스가-단일-책임을-가지는지-판단하기)
		- [2.2.4. 언제 디자인을 만들지 판단하기](#224-언제-디자인을-만들지-판단하기)
	- [2.3 Writing Code That Embraces Change](#23-writing-code-that-embraces-change)
		- [2.3.1 데이터가 아닌 행동에 의존하기](#231-데이터가-아닌-행동에-의존하기)
		- [2.3.2. 모든 곳에 단일 책임 원칙 강제하기](#232-모든-곳에-단일-책임-원칙-강제하기)
	- [2.4. Finally, the Real Wheel](#24-finally-the-real-wheel)
- [3. Managing Dependencies](#3-managing-dependencies)
	- [3.1. 의존성 이해하기](#31-의존성-이해하기)
		- [3.1.1. 의존성 알아채기](#311-의존성-알아채기)
		- [3.1.2. 객체들 간의 결합(CBO - Coupling Between Objects)](#312-객체들-간의-결합cbo---coupling-between-objects)
		- [3.1.3. 다른 의존성들](#313-다른-의존성들)
	- [3.2. 약하게 결합된 코드 작성하기](#32-약하게-결합된-코드-작성하기)
		- [3.2.1. 의존성 주입하기](#321-의존성-주입하기)
		- [3.2.2. 의존성 격리시키기](#322-의존성-격리시키기)
		- [3.2.3. 인자 순서에 대한 의존성 제거하기](#323-인자-순서에-대한-의존성-제거하기)
		- [3.3.2. 의존성 방향을 선택하기](#332-의존성-방향을-선택하기)
- [4. Creating Flexible Interfaces](#4-creating-flexible-interfaces)
	- [4.1. 인터페이스 이해하기](#41-인터페이스-이해하기)
	- [4.2 인터페이스 정의하기](#42-인터페이스-정의하기)
		- [4.2.1. 퍼블릭 인터페이스](#421-퍼블릭-인터페이스)
		- [4.2.2. 프라이빗 인터페이스](#422-프라이빗-인터페이스)
		- [4.2.3. 책임, 의존성, 인터페이스](#423-책임-의존성-인터페이스)
	- [4.3. 퍼블릭 인터페이스 찾기](#43-퍼블릭-인터페이스-찾기)
		- [4.3.1. (예시) 자전거 여행 회사](#431-예시-자전거-여행-회사)
		- [4.3.2. 의도를 구성하기](#432-의도를-구성하기)
		- [4.3.3. 시퀀스 다이어그램 사용하기](#433-시퀀스-다이어그램-사용하기)
		- [4.3.4. '어떻게' 해야하는지 알려주는 대신 '무엇을' 달라고 요구하기](#434-어떻게-해야하는지-알려주는-대신-무엇을-달라고-요구하기)
		- [4.3.5. 맥락 의존성 찾기](#435-맥락-의존성-찾기)
		- [4.3.6. 다른 객체를 믿기](#436-다른-객체를-믿기)
		- [4.3.7. 새로운 객체를 찾아내기 위해 메세지를 사용하기](#437-새로운-객체를-찾아내기-위해-메세지를-사용하기)
		- [4.3.8. 메세지 기반 어플리케이션 만들기](#438-메세지-기반-어플리케이션-만들기)
	- [4.4 자신의 인터페이스를 드러내는 코드 작성하기](#44-자신의-인터페이스를-드러내는-코드-작성하기)
		- [4.4.1. 명시적인 인터페이스 만들기](#441-명시적인-인터페이스-만들기)
		- [4.4.2. 다른 사람의 퍼블릭 인터페이스 존중하기](#442-다른-사람의-퍼블릭-인터페이스-존중하기)
		- [4.4.3. 프라이빗 인터페이스에 의존할 때 주의하기](#443-프라이빗-인터페이스에-의존할-때-주의하기)
		- [4.4.4. 맥락 최소화 시키기](#444-맥락-최소화-시키기)
	- [4.5. 데메테르 원칙](#45-데메테르-원칙)
		- [4.5.1. 데메테르 원칙의 정의](#451-데메테르-원칙의-정의)
		- [4.5.2. 위반의 결과](#452-위반의-결과)
		- [4.5.3. 원칙 위반을 피하기](#453-원칙-위반을-피하기)
		- [4.5.4. 데메테르의 원칙 듣기](#454-데메테르의-원칙-듣기)
- [5. Reducing Costs with Duck Typing](#5-reducing-costs-with-duck-typing)
	- [5.1. 오리타입 이해하기](#51-오리타입-이해하기)
		- [5.1.1. 오리 타입 무시하기](#511-오리-타입-무시하기)
		- [5.1.2. 문제를 조합하기](#512-문제를-조합하기)
		- [5.1.3. 오리 타입 찾기](#513-오리-타입-찾기)
		- [5.1.4. 오리 타입의 중요성](#514-오리-타입의-중요성)
	- [5.2. 오리 타입에 의존하는 코드 작성하기](#52-오리-타입에-의존하는-코드-작성하기)
		- [5.2.1. 숨겨진 오리파일 인지하기](#521-숨겨진-오리파일-인지하기)
		- [5.2.2. 오리 타입 신뢰하기](#522-오리-타입-신뢰하기)
		- [5.2.3. 오리 타입 문서작성](#523-오리-타입-문서작성)
		- [5.2.4. 오리타입 사이에서 코드 공유하기](#524-오리타입-사이에서-코드-공유하기)
		- [5.2.5. 현명하게 오리타입 선택하기](#525-현명하게-오리타입-선택하기)
	- [5.3. 오리 타입의 무서움을 정복하기](#53-오리-타입의-무서움을-정복하기)
		- [5.3.1. 정적 타입으로 오리 타입 거부하기](#531-정적-타입으로-오리-타입-거부하기)
		- [5.3.2. 정적 타입 vs 동적 타입](#532-정적-타입-vs-동적-타입)
		- [5.3.3. 동적 타입 언어 받아들이기](#533-동적-타입-언어-받아들이기)
- [6. Acquiring Behavior Through Inheritance](#6-acquiring-behavior-through-inheritance)
	- [6.1. 고전적인 상속 이해하기](#61-고전적인-상속-이해하기)
	- [6.2. 상속을 사용하는 곳을 인지하기](#62-상속을-사용하는-곳을-인지하기)
		- [6.2.1. 구체적인 클래스에서 시작하기](#621-구체적인-클래스에서-시작하기)
		- [6.2.2. 여러 타입 임베딩하기](#622-여러-타입-임베딩하기)
		- [6.2.3. 숨겨진 타입 찾기](#623-숨겨진-타입-찾기)
		- [6.2.4. 상속 선택하기](#624-상속-선택하기)
		- [6.2.5. 상속 관계 그리기](#625-상속-관계-그리기)
	- [6.3. 상속의 오용](#63-상속의-오용)
	- [6.4. 추상화 찾기](#64-추상화-찾기)
		- [6.4.1. 추상화 상위 클래스 만들기](#641-추상화-상위-클래스-만들기)
		- [6.4.2. 추상적인 행동을 상위로 올리기](#642-추상적인-행동을-상위로-올리기)
		- [6.4.3. 구체적인 것에서 추상적인 것 분리하기](#643-구체적인-것에서-추상적인-것-분리하기)
		- [6.4.4. 템플릿 메서드 패턴 사용하기](#644-템플릿-메서드-패턴-사용하기)
		- [6.4.5. 모든 템플릿 메서드 구현하기](#645-모든-템플릿-메서드-구현하기)
	- [6.5. 상위클래스와 하위클래스 사이의 커플링 관리하기](#65-상위클래스와-하위클래스-사이의-커플링-관리하기)
		- [6.5.1. 커플링 이해하기](#651-커플링-이해하기)
		- [6.5.2. Hook 메세지를 사용하여 하위클래스 커플링 제거하기](#652-hook-메세지를-사용하여-하위클래스-커플링-제거하기)
- [7 .](#7-)

<!-- /TOC -->

## 1. Object-Oriented Design

세상은 절차적이다. 시간의 흐름대로 사건이 흘러간다. 또한, 세계는 객체지향적이다. 객체들의 행동은 자연스럽게 섞이기 때문에 예상치 못한 행동들의 조합이 나타날 수 있다.

절차적 프로그램은 예상치 못한 행동들의 조합을 프로그래밍하기 어려운 경우가 많다. 이를 해결하기 위해 객체지향 설계가 등장해다. 객체지향 디자인은 이미 정해진 절차들을 묶음으로 생각하지 않고, 객체가 서로 주고받는 메세지들의 연속으로 파악해야 한다. 그렇게 때문에 프로그래머는 객체들의 연관성을 잘 정의해준다면 모든 사건의 조합을 만들어낼 필요가 없다.

객체지향 설계에 실패하는 것은 관점이 제대로 확립되지 않아서이다. 객체지향적 관점을 확실히 가지게 되면 실패할 수 없다.

객체지향 어플리케이션은 상호작용하는 여러 객체로 구성되어 있고 상호작용하는 방석은 서로 메세지를 주고받는 것이다. 여기서 송신하고 수신하는 객체가 두 객체 사이의 의존성을 만들어 내고, 이러한 의존성으로 인해 객체를 수정하는 것이 어려워진다.

객체 지향 설계는 의존성 관리에 관한 것이다. 객체들이 변화를 용인할 수 있도록 의존성을 잘 관리하는 것이 객체 지향 디자인이다. 제대로된 설계가 되지 않으면 객체들이 서로에 대해 너무 많이 알기 떄문에 관리되지 않는 의존성은 큰 혼란을 초래한다.

모든 어플리케이션은 코드의 집합이고, 코드를 어떻게 배열하는 것이 바로 설계이다. 설계를 할 때 고려해야 할 것이 두가지가 있다. 먼저 현재의 기능을 충실히 구현할 수 있어야한다는 것이다. 두번째는 나중에 변경될 수 있는 것을 고려해서 코드를 작성해야 한다는 것이다.

디자인은 나중에 디자인할 수 있는 여지를 남겨 놓기 위한 것이고, 그 최종 목표는 변화의 비용을 최소화하는 것이다.

### 1.1 객체 지향 디자인의 원칙과 디자인 패턴

`SOLID`는 마이클 플레즈가 만들고 로버트 마틴이 대중화한 객체 지향 설계의 5가지 원리이다.

1. Sngle Responsibility - 단일 책임
2. Open-Closed - 개방-폐쇄
3. Liskov Substitution - 리스코프 치환
4. Interface Segregation - 인터페이스 분리
5. Dependency Inversion - 의존성 역전

다른 디자인 원칙으로는 앤디 헌트와 데이브 토머스의 `DRY`(Don't Retape Yourself)와 노스이스트 대학교의 데메터 프로젝트의 `Law of Demeter`(LoD)가 있다. 이러한 설계 원칙들을 이 책을 통해서 다룬다.

또한, 객체지향 디자인의 원칙 외에도 디자인 패턴을 이해하는 것이 중요하다. <GoF의 디자인 패턴>은 패턴이란 객체지향 소프트웨어 디자인에서 명확한 문제를 처리하는 간단하고도 우아한 해결책이라고 말한다. 디자인 패턴은 **동일한 문제를 같은 방식으로 해결할 수 있는 방법**에 이름을 부여한 것을 말한다. 디자인 패턴은 프로그래머들이 서로 소통하고 협업할 수 있는 방법을 제공해 주었다.

디자인은 **반복적인 피드백**과 함께하는 **점진적인 발견**의 과정이다. 그리고 디자인은 지속적인 자기조절 능력을 갖추고, 자연스럽게 발전하는 것이 가장 좋다. 때문에 반복과 점진적인 발전을 중시하는 애자일 소프트웨어 개발은 잘 디자인된 애플리케이션을 만드는 데 매우 적합하다. 좋은 애플리케이션을 위해서는 **초기에 큰 디자인을 구상하지 않고 계속해서 디자인을 변경해주는 게 좋다**.

### 1.2 객체 지향 언어

 일반적인 절차지향적인 언어와 다르게 루비와 같은 객체지향 언어는 데이터와 행동(함수)를 완전히 분리하지 않고 하나의 객체에 결합하여 넣는다. 즉, 객체는 행동과 데이터를 포함하고, 객체만이 제어할 수 있는 데이터를 포함한다. 객체는 서로 메세지를 보내면서 서로의 행동을 불러 일으킨다.

루비는 문자열 데이터 타입 대신 문자열 객체를 가지고 있다. 문자열로 작동하는 연산은 언어의 문법대신에 문자열 객체에 내장되어 있다. 각각의 문자열 객체는 고유한 개인 데이터 문자열을 포함한다는 점에서 다르지만, 모든 문자열 객체는 동일한 동작을 한다는 점에서 유사하다고 볼 수 있다.

문자열 객체가 자체적으로 알맞은 행동을 제공해 주기때문에 문자열 데이터의 타입에 대해서 특별히 신경쓸 필요가 없다. 프로그래머는 객체가 메세지를 보내는 일반적인 방법만 알면 된다.

루비와 같은 클래스 기반의 객체 지향 언어는 유사한 객체의 구성에 대한 청사진을 제공하는 클래스를 정의 할 수 있다. 클래스는 메서드와 프로퍼티를 정의한다. 메서드는 메세지에 응답하여 호출된다. 동일한 메서드 이름은 다른 오브젝트에서도 정의될 수 있다. 전송된 메세지에 대한 올바른 오브젝트의 메서드를 찾고 호출하는 것은 루비의 역할이다.

클래스는 단순한 데이터 이상의 유형을 정의한다. 물체의 유형을 알면 물체가 어떻게 행동할지 예상할 수 있다. 절차지향 언어에서 변수는 단일 데이터 타입을 가진다. 이 데이터 타입에 대한 지식은 어떤 연산이 유효한지에 대한 예상하게 한다. 루비에서는 하나의 객체는 많은 타입을 가질 수 있다. 객체의 타입을 아는 것은 객체가 응답하는 메세지의 대한 예상을 할수 있게 한다.

루비에는 미리 정의된 클래스가 많이 있다. 가장 즉시 알아차릴수 있는 클래스는, 절차지향에서 쓰이는 데이터 타입과 중복되는 것들이다. 예를들면 스트링 클래스나, 정수를 표현하기 위한 Fixnum클래스 등이 있다. 보통은 모든 데이터 타입을 위한 미리정의된 클래스가 있다.

하지만, 객체지향 언어는 그 자체로 객체를 이용하여 만들어지고 이 점이 흥미로운 부분이다. 스트링 클래스 (새로운 문자열 객체를 위한 청사진)은 그 자체로 객체이다. 즉, String 클래스 또한 Class 클래스의 인스턴스이다. 모든 스트링 객체가 데이터가 구체화된 String 클래스의 객체라면, 모든 클래스 객체(String Fixnum ..)는 구체화된 데이터를 가지는 Class클래스의 인스턴스인 것이다. String 클래스가 새로운 문자열들은 만든다면, Class 클래스는 새로운 클래스들을 만든다.

## 2. Designing Classes with a Single Responsibility

객체지향 시스템에서 기초가 되는 것은 메세지이지만, 가장 뚜렷하게 확인할 수 있는 구조는 class이다. 메시지가 디자인의 핵심이지만, 클래스가 더 뚜렷하기 때문에 이번 장에서는 클래스에 속하는 것을 정하는 방법에 대해서 집중할 것이다.

만들려는 클래수가 무엇이고, 얼마나 많으며 어떠한 행동을 포함하고 있고 다른 클래스와의 관계는 어떠한지 정하는지에 대한 질문이 있을 수 있다. 이에 대한 정답은 클래스는 단순해야 한다는 것이다.

어플레케이션을 모델링하고, 클래스를 사용해서 지금 당장 있어야 하면서 나중에 수정하기 쉽게 하는 것이 목표이다. 현재 코드가 동작하게 하는 문제는 쉽지만, 수정하기 쉽게 만드는 것은 다른 문제이다.

### 2.1. 클래스에 무엇이 포함될지 정하기

#### 2.1.1. 클래스에 Method를 그룹핑하기

루비와 같은 객체지향 언어에서 메소드들은 클래스안에 정의되어 있다. 한번 생성된 클래스는 어플리케이션에 영원히 영향을 미칠것이다. 하지만, 메소드들을 알맞게 그룹핑하는것이 중요할지라도 프로젝트의 초반에 그것을 정하는 것이란 어려운 일이다. 또한, 성공적으로 그룹핑 했다고 하더라도 어플리케이션이 변하게 되다면 또 수정해야할 일이 발생할 수 있다. 디자인이란 완벽을 추구하는 행동이 보다는 영구적 변화에 대한 예술이다.

#### 2.1.2. 쉽게 수정가능한 코드를 구성하기

수정하기 쉽다는 것은 명확하지 않기 때문에 그 의미를 정의할 필요가 있다.

> 수정하기 쉬운것의 정의

1. Changes have no unexpected side effects
2. Small changes in requirements require correspondingly small changes in code
3.  Existing code is easy to reuse
4. The easiest way to make a change is to add code that in itself is easy to change

> 수정하기 쉬운것의 기준 (TRUE)

1. **Transparent** The consequences of change should be obvious in the code that is changing and in distant code that relies upon it
2. **Reasonable** The cost of any change should be proportional to the benefits the change achieves
3. **Usable** Existing code should be usable in new and unexpected contexts
4. **Exemplary** The code itself should encourage those who change it to perpetuate these qualities

TURE를 만족하는 코드를 짜는 것의 첫 번째 단계는 각 클래스는 **단 하나의 잘 정의된 책임**을 가지는 것이다.

### 2.2. 하나의 책임을 지는 클래스 만들기

클래스는 최대한 작으면서도 유용해야한다. 즉, 클래스는 단일 책임을 가져야 한다.

#### 2.2.1. 자전거와 기어

자전거를 탈 때는 작은 기어(페달이 가벼워지고 느려짐), 큰 기어(페달이 무겁고 빨라짐) 중에 선택할 수 잇다. 기어는 발이 페달을 돌리는 힘으로 바퀴를 돌린다. 구체적으로는 페달이 회전할 때마다 바퀴가 얼마나 회전하는지를 기어에서 제어한다.

![image](https://user-images.githubusercontent.com/53181778/85508105-65bf2d00-b62e-11ea-9079-42ae9ca02fea.png)

크고 작은 기어를 비율로 표현할 수 있다.

```ruby
chainring = 52 # number of teeth
cog = 11
ratio = chainring / cog.to_f
puts ratio # -> 4.72727272727273

chainring = 30
cog = 27
ratio = chainring / cog.to_f
puts ratio # -> 1.11111111111111
```

위 코드를 기어 클래스로 만들어보자. 기어는 chainring, cog, ratio를 가지고 data와 behavior를 가지게 된다.

```ruby
class Gear
	attr_reader :chainring, :cog

	def initialize(chainring, cog)
	@chainring = chainring
	@cog = cog
	end

	def ratio
    	chainring / cog.to_f
	end
end

puts Gear.new(52, 11).ratio # -> 4.72727272727273
puts Gear.new(30, 27).ratio # -> 1.11111111111111
```

Gear클래스는 Object클래스의 서브 클래스로 많은 메소드들을 상속 받는다. 그렇게 때문에 응답할 수 있는 메세지의 집합(behavior의 집합)이 꽤 큰편이다. 상속은 어플리케이션 설계에 중요하지만, Gear클래스와 같이 간단한 경우는 매우 기본적인 상속에 해당하기 때문에 상속된 메소드가 없다고 생각해도 된다. (상속의 복잡한 형태는 6장에서 다룰 것이다. )

만약, 두대의 자전거를 가지고 있고 서로 같은 기어를 가지고 있지만, 다른 사이즈의 바퀴를 가지는 경우라면 바퀴의 영향도 고려해야 할 것이다. 보통 기어 인치를 이용하여 바퀴와 기어가 다른 자전거들을 비교한다.

`gear inches = wheel diameter * gear ratio` where `wheel diameter = rim diameter + twice tire diameter`

```ruby
class Gear
  attr_reader :chainring, :cog, :rim, :tire
  def initialize(chainring, cog, rim, tire)
    @chainring = chainring
    @cog = cog
    @rim = rim
    @tire = tire
  end

  def ratio
    chainring / cog.to_f
  end

  def gear_inches
    # tire goes around rim twice for diameter
    ratio * (rim + (tire * 2))
  end
end

puts Gear.new(52, 11, 26, 1.5).gear_inches
# -> 137.090909090909
ㄴ
puts Gear.new(52, 11, 24, 1.25).gear_inches
# -> 125.272727272727
```

하지만, 만약 기존에 사용하던 코드에서 `puts Gear.new(52, 11).ratio`와 같이 사용했다면, initialize의 파라미터 수와 맞지 않기 때문에 에러가 난다. gear_inches 기능을 추가하면서 생긴 버그이다. 아직까진 프로그램이 작기 때문에 큰 문제는 되지 않는다.

하지만, 이게 최선일까? 앞으로 더 많은 클래스가 생겨날 것이고 어플리케이션은 더 커질것이다. 더 효율적으로 확장시키기 위해 코드는 더 바꾸기 쉬워야 한다.

#### 2.2.2. 왜 단일 책임이 중요한가?

수정이 쉬운 어플리케이션은 재사용하기 쉬운 클래스들로 이루어져 있다. 재사용 가능한 클래스는 얽힘이 거의 없는 잘 정의된 행동의 접속 가능한 유닛(쉽게 가져다 쓸수 있는 유닛)이다.

하나 보다 많은 책임이 있는 클래스는 재사용하기 어렵다. 여러 책임을 가지는 클래스는 얼기설기 얽혀있는 것과 같다. 만약, 클래스의 전체가 아니라 일부분을 재사용하고 싶다면, 필요한 부분들만 얻는 것은 불가능하다. 이제 두 가지 옵션이 있고 두개다 매력적인 옵션은 아니다.

책임들이 너무 결합되어 필요한 행동들만 사용할 수 없다면, 필요한 코드를 복제하여 사용할 수 있다. 하지만 코드를 복제하는 것은 추가적인 유지보수를 유도하고 버그를 증가시키기 때문에 좋은 방법이 아니다. 만약 필요한 행동들에만 접근할 수 있는 구조화된 클래스가 있다면, 클래스 전체를 재사용 할 수 있을 것이다. 하지만, 이것은 단지 하나의 문제를 다른 문제로 대치하는 것에 불과하다. 재사용하는 클래스는 원래의 목적이 혼동되고, 뒤얽힌 몇몇 책임을 포함하게 되기 때문에, 여러 이유로 바뀌어야 한다. 여러 일을 하는 클래스에 의존하게 되면 어플리케이션이 잘못될 가능성이 높아진다.

#### 2.2.3. 클래스가 단일 책임을 가지는지 판단하기

클래스가 하나의 책임만을 가지는지 판단하는 방법에는 무엇이 있을까?

클래스가 인격이 있는 것처럼 질문을 하는 방법이 있다. 모든 메소드들을 질문으로 바꾸면, 질문을 하는 것이 말이 된다. 예를 들어, Gea에게 `당신의 기어비는 무엇인가요?` 라고 물어볼 수 있다. 하지만, 기어클래스에 `당신의 기어인치는 몇인가요?` 또는 `당신의 타이어 사이즈는 얼마나 되나요?` 와 같은 질문은 이상하다. 하지만 기어 클래스에게 `당신의 타이어는 무엇인가요?` 라고 물어보는 것은 충분히 가능한 일이다. 기어 클래스에서, 타이어는 ratio나 gear_inches와는 다른 종류의 것이다. 다른 모든 객체의 관점으로부터, 기어가 응답할수 있는 것은 또 다른 메세지일 뿐이다. 만약 기어가 메세지에 응답할 수 있다면 무언가가 메세지를 보낼것이고, 기어가 바뀐다면 송신자는 놀랄수도 있다(?).

클래스가 실제로 무엇을 하고있는지 이해하는 또 다른 방법은, 클래스의 책임을 한 문장으로 묘사해 보는 것이다. 클래스는 최대한 작으면서 유용한 것만 해야한다. 그렇기 때문에 간단하게 묘사할 수 있어야 한다. 만약 가장 단순한 표현에 `그리고, 또는`이라는 단어가 들어간다면 여러개의 책임을 가지고 있다고 볼 수 있다.

객체지향 설계는 `cohesion(화합, 결합, 응집력)` 의 단어를 사용하여 단일 책임의 개념을 설명한다. 하나의 클랙스 안에 있는 모든 것들이 클래스의 핵심 목적에 연관되어 있을 때, 이 클래스는 강하게 cohesion(결합)되어 1개의 책임을 가진다고 할 수 있다.

단일 책임 원칙(Single Responsibility Principle (SRP) )은 Wirfs-Brock & Brian Wilkerson의 Responsibility-Driven Design (RDD)에 뿌리를 두고 있다. RDD는 `하나의 클래스는 클래스의 목적을 수행하는 책임들로 구성되어 있다.`고 말한다. SRP는 하나의 클래스가 하나의 매우 좁은 일(목적)을 하거나 사소한 이유로 바뀌는 것을 요구하지 않는다. 대신에 SRP는 응집력있게 클래스가 하는 모든것은 클래스의 목적과 매우 높게 연관이 있어야 하는 것을 요구한다.

기어 클래스의 책임을 표현하자면 “앞, 뒤 톱니바퀴 사이의 기어비를 계산한다”. 만약 그렇다면 위에서 만든 Gear 클래스는 너무나 많은 일을 하고있다. 만약 “자전거에 기어가 미치는 영향을 계산한다”로 표현한다면 더 어울릴 것이다. 그렇다면 gear_inches 는 Gear 에 속하는 것이 맞지만, 타이어의 크기가 Gear에 속하는 것은 애매하다.

#### 2.2.4. 언제 디자인을 만들지 판단하기

클래스에 뭔가 문제가 있다고 느껴지는 순간이 자주 있다. Gear클래스에 왜 바퀴가 있지? 사실은 Bicycle 클래스이지 않을까 하는 고민이 있을 수 있다.

하지만, 우리는 미래에 어떤일이 생길지 모르고 우리에게 그에 대한 ㅈ어보가 없다. 준비가 안된 상태에서 서둘러서 디자인을 결정해야 한다고 느끼는 것은 좋지 않다. 다만, Gear클래스를 보면서 문제를 느꼈다면, `지금 이 문제를 수정하지 않는 다면 나중에 어떤 대가를 치르게 될까?`라고 스스로에게 질문해보자. 어쩌면 더 많은 정보를 얻을때 까지 아무것도 하지 않고 기다려 보는 것이 효율적인 접근일 수도 있다.

Gear클래스의 코드는 투명하고 적잘하지만 훌륭한 디자인은 아니다.아무런 `의존성`도 없기 때문에 코드를 수정한다고 해서 특별한 문제는 발생하지 않을 뿐이다. 만약 다른 객체와 의존성이 생긴다면 Gear 클래스는 투명함과 적절함을 잃게 될 것이다. 이 떄가 코드를 다시 구성해야할 때 이다. 그리고 이 의존성이 좋은 디자인을 결정하는 정보를 제공해준다.

지금 코드를 수정하는 비용이나 나중에 수정하는 비용이나 필요한 비용이 동일하다면 결정을 나중으로 미루는 것이 좋다. **디자인 결정은 꼭 필요한 순간에, 그 순간이 제공하는 정보들을 가지고 해야한다.**

하지만 Gear클래스는 지금당장 수정해야할지, 변경해야할지 의견이 분분할 것이다. 현재 클래스의 구조는 미래의 개발자에게 지금의 디자인 의도를 전달하는 메세지 이다. 미래의 개발자는 현재의 디자인 패턴을 참조할 것이다. 결론적으로, Gear클래스는 디자인 의도를 잘못 전달하고 있다. 사용성이 좋지도 않고, 좋은 코드도 아니다. 여러가지 책임을 가지고 있기 때문에 재사용하면 안되는 코드이다.

### 2.3 Writing Code That Embraces Change

나중에 수정에 필요한 경우에라도 쉽게 수정될 수 있도록 코드를 배치하는 일은 가능하다. 즉, 수정하기 쉬운 방식으로 코드를 하는 것이다.

#### 2.3.1  데이터가 아닌 행동에 의존하기

행동은 메서드에 담겨있고 메세지를 보내는 행위를 통해 실행된다. 하나의 책임을 가지는 클래스를 만들때, 행동의 모든 작은 조각들은 한 장소에 속하게 된다. Don't Repeat Yorself(DRY)라는 문장은 이러한 아이디어를 의미한다. 행동을 바꾸는 것은 코드의 어떤 한 부분만을 바꾸면 되기 때문에, DRY 코드는 변화를 견뎌낼 수 있다.

객체는 행동과 함께 데이터를 가진다. 데이터는 객체의 인스턴스 변수에 속해 있고, 간단한 문자열이나 복잡한 해시일 수 있다. 데이터는 두가지 방법 중 하나로 접근할 수 있다. 인스턴스 변수를 직접 참조하거나, accessor 메서드안에 인스턴스 변수를 감싸는 방법이 있다.

- 인스턴스 변수 숨기기

  아래의 ratio 메서드 처럼, 직접 인스턴스 변수를 참조하는 대신에 인스턴스 변수를 accessor 메서드에 감싸서 접근하라.

  ```ruby
  class Gear
      def initialize(chainring, cog)
          @chainring = chainring
          @cog = cog
      end
      def ratio
          @chainring / @cog.to_f # <-- road to ruin
      end
  end
  ```

  클래스에서 변수들을 정의하고 있을지라고, 메서드로 변수를 감싸서 숨겨라. 루비는 `attr_reader`를 제공하여 캡슐화된 메서드를 쉽게 만들수 있다.

  ```ruby
  class Gear
      attr_reader :chainring, :cog # <-------
      def initialize(chainring, cog)
          @chainring = chainring
          @cog = cog
      end

      def ratio
          chainring / cog.to_f # <-------
      end
  end
  ```

  `attr_reader`는 변수를 감쌀 수 있는 간단한 wrapper 메서드를 생들어 준다.

  > cog를 위한 가상의 wrapper 메서드

  ```ruby
  # default implementation via attr_reader
  def cog
  	@cog
  end
  ```

  cog메서드만이 cog가 무엇을 의미하는지 이해할 수 있는 유일한 방법이다.  cog는 메세지 전송의 결과가 되었다. 이 메서드 구현함으로 cog는 `모든 곳에서 참조되는 데이터`에서 `한 번만 정의된 행동`으로 바뀌었다.

  `@cog` 인스턴스 변수가 10번 참조되고 갑자기 @cog의 내용을 바꿔야 한다면, 코드의 여러 부분을 수정해야 한다. 하지만 @cog가 래퍼 메서드로 감싸져 있었다면 cog 메서드를 직접 구현해서 cog가 어떤 의미인지 다시 정의할 수 있다. 우리가 직접 작성한 새로운 메서드는 아래의 첫 번째 예시처럼 간단할 수도 있고 두 번째 예시처럼 더 복잡할 수도 있다.

  #1

  ```ruby
  # a simple reimplementation of cog
  def cog
      @cog * unanticipated_adjustment_factor
  end
  ```

  #2

  ```ruby
  # a simple reimplementation of cog
  def cog
     	@cog * (foo? ? bar_adjustment : baz_adjustment)
  end
  ```

  데이터를 마치 '메시지를 이해하는 객체' 처럼 취급하는 것은 두 가지 이슈를 품고 있다.

  첫 번째 이슈는 `가시성`이다. `@cog`변수를 public 메서드로 감쌀 경우 다른 객체에 `@cog`변수에 접근할 수 있음을 의미한다. 반대로, private 메서드로 감쌀경우 외부에서는 접근할 수 없다. 이 두 선택지에 대해서는 4장에서 다룬다.

  두 번째 이슈는 조금더 더 추상적이다. 모든 변수를 메서드로 감싸고, 어떤 변수든지 마치 객체인것 처럼 다룰 수 있기 때문에 데이터와 보통의 객체를 구분하는 것이 무의미해진다. 가끔 어플리케이션의 일부분을 행동이 없는 데이터라 생각하는 것이  편리할 수 있지만, 대부분의 경우 데이터를 일반적인 객체로 받아들이는 것이 더 좋다.

  데이터를 감춤으로 예상치 못한 변화로부터 코드를 보호할 수 있다. 개발자도 데이터의 모든 행동을 다 알 수 없다. 변수를 데이터 처럼 생각할 지라도, 변수는 메시지를 보내는 것으로 접한하는 것이 좋다.

- 데이터 구조 숨기기

  인스턴스 변수에 애착을 가지는 것은 안좋지만, 복잡한 데이터 구조를 가지는 것은 더욱 더 좋지 않다. 아래의 ObscuringReferences 클래스를 보자.

  ```ruby
  class ObscuringReferences
      attr_reader :data
      def initialize(data)
          @data = data
      end

      def diameters
          # 0 is rim, 1 is tire
          data.collect {|cell|
              cell[0] + (cell[1] * 2)}
      end
      # ... many other methods that index into the array
  end
  ```

  이 클래스는 2차원 배열의 rims와 tires로 초기화 된다.

  ```ruby
  # rim and tire sizes (now in millimeters!) in a 2d array
  @data = [[622, 20], [622, 23], [559, 30], [559, 40]]
  ```

  ObscuringReferences 는 @data에 초기화 아규먼트를 저장하고, @data를 메서드에 감싸기 위해 attr_reader를 사용했다. diamwters메서드는 data에게 변수의 내용물에 접근하는 메세지를 보낸다. 이렇게 클래스 내부에서도 인스턴스 변수를 숨기고 있다.

  하지만, @data는 복잡한 데이터 구조를 가지고 있다. 단순히 인스턴스 변수를 숨기는 것만으로는 충분하지 ㅇ낳다. data 메서드는 단순히 배열을 반환할 뿐이다. 배열을 가지고 어떤 작업을 하려면, data메서드를 전송하는 객체의 정보를 잘 알고 있어야한다.

  diameters 메서드는 지름을 계산하는 것 뿐만아니라, rims와 tires를 배열의 어디서 찾아야 하는지 알고 있다. 배열의 [0]에 rims가 [1]에는 tires가 있다는 것을 알고 있다.

  이것은 배열의 구조에 의존적이다. 만약 데이터 구조가 바뀐다면 코드는 반드시 바뀌어야 한다. 배열에 데이터를 가지고 있을 때, 어플리케이션 곳곳에서 배열의 구조를 참조하는 코드를 작성해야 한다. 이런 참조는 위험하다. 변수의 캡슐화를 무시하고 배열 구조에 대한 지식을 코드 이곳저곳에 흩뿌려 놓는다. 전혀 DRY하지 않다. rims가 [0]에 있다는 것이 중복되어서는 안된다. 한 장소에서 이러한 것들을 관리해야한다.

  간단한 예시로 이것이 얼마나 나쁜지 충분히 확인할 수 있다. data가 여러 해시들로 이루어진 배열을 반환하고 이 배열을 코드의 여러 곳에서 사용한다고 상상해 보자. data의 구조를 변경한다면 코드 곳곳에 영향을 미칠 것이다. 그리고 각각의 변화는 버그를 만들수 있다.

  루비는 구조에서 의미를 손쉽게 분리할 수 있게 해준다. 메서드로 인스턴스 변수를 손쉽게 감쌀 수 있는 것처럼 루비의 `Struct 클래스`를 이용하면 데이터 구조를 감쌀 수 있다. 앞의 클래스와 동일한 외부 인터페이스를 가지고 있지만, 내부 인터페이스는 전혀 다르게 구현하였다.

  ```ruby
  class RevealingReferences
      attr_reader :wheels
      def initialize(data)
          @wheels = wheelify(data)
      end
      def diameters
          wheels.collect {|wheel|
              wheel.rim + (wheel.tire * 2)}
      end
      # ... now everyone can send rim/tire to wheel

      Wheel = Struct.new(:rim, :tire)
      def wheelify(data)
          data.collect {|cell|
              Wheel.new(cell[0], cell[1])}
      end
  end
  ```

  변경된 클래스의 diameters 메서드는 배열의 내부 구조에 대한 지식이 전혀 없다. diameters가 알고있는 전부는 wheels 메세지가 enumerable를 리턴한다는 것과 각각의 enumerable에 속해 있는 모든 객체가 rim과 tire메서드에 응답할 수 있다는 것이다. 기존에는 cell[1]에 대한 참조였지만, wheel.tire로 메세지를 보내는 방식으로 바뀌었다.

  입력받은 배열의 구조에 대한 모든 지식은 `wheelify` 메서드 속에 격리되었고 이 메서드는 `배열들의 배열`을 `Struct들의 배열`로 변환 시켰다.루비 공식문서에는 `Struct`는 `명시적으로 클래스를 만들지 않고도 accesor 메서드를 이용해 여러 어트리뷰트들을 묶어내는 편리한 방법`이라고 정의한다. 즉, rim과 tire 메서드에 반응하는 작고 가벼운 객체를 만들어 준 것이다.

  `wheelify` 메서드는 입력받은 배열의 구조에 대한 코드로만 이루어져 있다. 만약 입력값이 변한다면 바로 이 지점만 더 작성해야했지만, 이는 반복적으로 복잡한 배열의 구조를 참조해야 하는 비용에 비하면 아주 작은 번거로움에 지나지 않는다.

  이런 스타일의 코드는 외부 데이터 구조의 변화로 부터 코드를 보호해준다. 보다 가독성이 좋고 의미가 잘 드러나는 코드를 작성할 수 있다. 데이터 구조를 들여다 보던 작업을, 객체에 대한 메세지 전송 작업으로 대체한다. wheelify메서드는 구조에 대한 지저분한 정보를 한쪽에 몰아 놓고 코드를 DRY하게 만든다. 클래스가 변화를 쉽게 받아들일 수 있도록 만들다.

#### 2.3.2. 모든 곳에 단일 책임 원칙 강제하기

단일 책임 클래스를 만드는 것은 디자인에 중요한 영향을 주지만, 단일 책임의 아이디어는 코드의 많은 부분들에 유용한게 적용할 수도있다.

- 메서드에서 여분의 책임을 뽑아내기

  클래스와 같이 메서드도 하나의 책임을 가져야 한다. 메서드가 하나의 책임만을 지닐 때 메서드는 수정하기 쉽고 재사용하기도 쉽다. 클래스에 단일 책임을 적용하는 것과 매우 유사하다. 메서드의 하는일을 물어보고, 하나의 문장으로 메서드의 책임을 묘사해보자.

  ```ruby
  def diameters
    wheels.collect {|wheel|
      wheel.rim + (wheel.tire * 2)}
  end
  ```

  이 메서드는 명확하게 두개의 책임을 가지고 있다. wheels 배열을 순회하는 것과, 각 바퀴의 지름을 계산하는 것이다.

  단순화 하기 위해 하나의 책임만을 가지는 두 개의 메서드로 분리할 수 있다. 반지름을 계산하는 부분을 독립적인 메서드로 뽑아내보자. 메세지 전송이라는 추가적인 비용이 발생하지만, 현재는 성능보다 수정할 수 있는 코드를 작성하는 것에 집중하자.

  ```ruby
  first - iterate over the array
  def diameters
    wheels.collect {|wheel| diameter(wheel)}
  end

  # second - calculate diameter of ONE wheel
  def diameter(wheel)
    wheel.rim + (wheel.tire * 2))
  end
  ```

  바퀴 단 한 개의 지름을 계산해야할 일이 있는가? 코드를 다시 살펴보면, 이미 그러고 있다는 것을 알 수 있다. 이 리팩토링은 과도한 디자인을 적용한 것이 아니다. 단순히 사용중인 코드를 재구성했을 뿐이다. 단수형 diameter메서드가 다른 곳에서 불릴 수 있다는 사실은 좋은 부수효과를 얻은 것이다.

  개별 객체에 행해지는 액션과 객체들을 반복 순회하는 것을 분리하는 것은 쉽게 알아 챌 수 있는 다중 책임의 경우이다. 보통의 경우 이렇게 쉽게 보이지 않는다.

  Gear 클래스의 gear_inches메서드를 회상해보자.

  ```ruby
  def gear_inches
    # tire goes around rim twice for diameter
    ratio * (rim + (tire * 2))
  end
  ```

  gear_inches는 Gear클래스의 책임인가? 그럴듯해 보이지만, 아니다. 그 이유는 gear_inches는 단일 책임이 아닌 여러개의 책임을 지니고 있기 때문이다.

  gear_inches에 숨겨져있는 바퀴으 지름을 구하는 부분때문이다. 그 부분을 분리해보자.

  ```ruby
  def gear_inches
    ratio * diameter
  end

  def diameter
    rim + (tire * 2)
  end
  ```

  이제 gear_inches메서드는 메시지를 전송해서 바퀴의 지름을 알아낸다. 이번 리팩토링이 지름을 계산하는 방법을 변경하지 않았다는 사실에 유의하자. 단지 지름을 계산하는 행동을 분리 했을 뿐이다.

  최종적인 결과물을 모르는데도 이러한 리패토링이 필요한 것일까?의 대답은 '그렇다'이다. 리팩토링이 필요한 이유는 디자인이 명확하기 떄문이 아니라 오히려 디자인이 불명확하기 때문이다.

  이 간단한 리팩토링은 문제를 명확하게 드러내준다. Gear클래스에서 gear_inches를 계산할 필요는 있지만, 바퀴의 지름을 계산해서는 안된다.

  하나의 리팩토링의 영햔은 제한적이지만, 이런 코딩스타일이 누적되면 그 영향은 매우 거대해진다. 여러 메서드가 각각의 하나의 책임을 질 때 다음과 같은 이득이 있다.

  - **Expose previously hidden qualities**

    리팩토링을 통해 클래스의 모든 메서드가 단일 책임을 가지면 클래스 자체가 명확해진다. 당장 메서드들을 다른 클래스로 옮기고 재정리 하지 않아도 메서드 하나하나가 하나의 목적을 가지면 클래스가 하는일이 더욱 명확해진다.

  - **Avoid the need for comments**

    주석은 실행이 되는 코드가 아니기 떄문에 시간이 지나면 바스러지는 종이문서같다.  메서드 속에 있는 코드 한 조각에 주석을 달아야 한다면 그 코드를 별도의 메서드로 뽑아내자. 뽑아낸 메서드의 이름이 주석과 동일한 역할을 할 수 있다.

  - **Encourage reuse**

    작은 메서들은 우리의 애플리케이션에 도움을 주는 코딩 습관을 장려한다. 다른 프로그래머들도 코드를 다시쓰기보다는 메서드를 재활용 할 것이다. 결국, 그들은 작고 재사용이 가능한 메서드들을 만들게 될 것이다.

  - **Are easy to move to another class**

    디자인에 필요한 정보를 얻고 코드를 수정하기로 결정했을 때, 작은 메서스들은 이동하기 쉽다 리팩토링하는 수고를 많이 들이지 않고도 클래스의 행동을 재배치할 수 있다.

- 클래스의 추가적인 책임들을 격리 시켜 놓기

  모든 메서드들이 하나의 책임만 지게 되면 클래스의 역할의 범위 역시 분명해진다. Gear클래스에 바퀴의 것으로 보이는 행동이 있다. Wheel클래스를 애플리케이션에 추가해야 하는가?

  현재 Wheel클래스를 만드는 데 큰 무리가 없다면 만드는 방법도 괜찮아 보인다. 하지만 일단은 만들지 않기로 마음을 먹었다고 가정해보자. 어떤 디자인 이수가 있어 클래스를 만들고 싶지 않을 수도있고 지금 코드가 발전해가는 방향에 확신이 없어서 새로운 클래스를 만들었을 때 이 클래스를 다른 프로그래머가 사용하는 것이 꺼려질 수 있다.

  Gear가 하나의 책임만 지려면, Wheel 의 것으로 보이는 행동을 분리해야 할 것 같다. Gear클래스에 그대로 두거나 제거하거나, 두 가지의 양자택일의 문제에 따라 디자인을 결정하는 것은 근시안적이다.

  우리게에는 하나의 선택지가 더 있다. 최대한 특정 디자인에 종속되지 않으면서, Gear가 하나의 책임만을 지도록 하는 것이다.왜냐하면 수정하기 쉬운 코드를 작성하려면 진짜 어쩔수 없는 순간이 올 때까지 최대한 결정을 미루는 것이 좋기 때문이다. 진짜 필요하기 전에 내린 모든 결정은 단지 추측에 불과하다.

  루비는 바퀴 지름을 계산하는 책임을 Gear 클래스로부터 제거하면서도 새로운 클래스에 이 책임을 부여하지 않을 수 있는 방법을 제공한다. 다음 코드는 기존의 **Wheel Struct**에 **블록**을 이용해서 **지름을 계산**하는 메서드를 추가한다.

  ```ruby
  class Gear
    attr_reader :chainring, :cog, :wheel
    def initialize(chainring, cog, rim, tire)
      @chainring = chainring
      @cog = cog
      @wheel = Wheel.new(rim, tire)
    end

    def ratio
      chainring / cog.to_f
    end

    def gear_inches
      ratio * wheel.diameter
    end

    Wheel = Struct.new(:rim, :tire) do
      def diameter
        rim + (tire * 2)
      end
    end
  end
  ```

  이제 자신의 diameter를 계산할 수 있는 Wheel을 가지게 되었다. Gear에 이 Wheel을 주입하는 것은 물론 우리의 장기적인 디자인 목표에 전혀 부합하지 않는다. 차라리 코드 구성을 위한 실험에 가깝다. 이제 Gear클래스는 꺠끗해졌고, Wheel에 대한 판단을 미룰수 있게 되었다.

  Gear안에 Wheel을 끼워두는 것은 Wheel이 언제나 Gear와 함께 사용된다는 것을 의미한다. (하지만 현실에서는 그렇지 않다.)

### 2.4. Finally, the Real Wheel

Gear 클래스의 디자인과 씨름하는 동안 때가 다가와다. 결국, 자전거 바퀴 둘레를 계산하는 기능도 필요해졌다. 자전거에는 속도를 계산해주는 장치가 있고 그 기능을 이용하기 위해서는 자전거의 바퀴 사이즈를 알아야한다.

바퀴의 둘레는 지름 * 원주율이다. 지름을 계산할 수 있는 Wheel을 Gear안에 넣어 두었기에 둘레를 계산하는 메서드를 추가하는 것은 쉽다. 더 중요한 점은 Gear클래스와 독립된 Wheel클래스가 명시적으로 필요해졌다는 점이다.

이미 Gear클래스에서 Wheel의 행동을 구분해 놓았기 때문에 이 수정은 전혀 어렵지 않게 진행될 수 있다. Wheel Struct를 Wheel클래스로 변경하면 된다

```ruby
class Gear
  attr_reader :chainring, :cog, :wheel
  def initialize(chainring, cog, wheel=nil)
    @chainring = chainring
    @cog = cog
    @wheel = wheel
  end
  def ratio
    chainring / cog.to_f
  end

  def gear_inches
    ratio * wheel.diameter
  end
end

class Wheel
  attr_reader :rim, :tire

  def initialize(rim, tire)
    @rim = rim
    @tire = tire
  end

  def diameter
    rim + (tire * 2)
  end

  def circumference
    diameter * Math::PI
  end
end

@wheel = Wheel.new(26, 1.5)
puts @wheel.circumference
# -> 91.106186954104

puts Gear.new(52, 11, @wheel).gear_inches
# -> 137.090909090909

puts Gear.new(52, 11).ratio
# -> 4.72727272727273
```

이제 Gear와 Wheel 모두 1개의 책임만 지게되어다. 코드가 완벽하다고는 할 수 없지만, 높은 수준에 도달했다고는 할 수 있다.

## 3. Managing Dependencies

현실을 모델링하는 방법 떄무에 객체지향 프로그래밍 언어는 효율적이며 효과적이라고 말한다. 객체는 현실세계의 문제의 특성을 반영하고, 두개의 객체 사이의 상호작용은 해결법을 제공한다. 이런 상호작용은 필수적이다. 하나의 객체가 모든 것을 알고 있을 수는 없기때문에 객체끼리의 소통은 필수이다.

객체들의 상호작용을 멀리서 바라보면 하나의 패턴이 존재한다. 각 메세지는 하나의 객체에서 시작되며 특정한 행동을 유발하기 위해 존재한다. 이 모든 행동은 객체 사이에 퍼져있고, 어떤 원하는 행동을 위해 객체는 그 행동을 개인적으로 알고있거나, 상속을 받거나 그 행동을 아는 객체를 알아야한다.

2장에서는 행동을 미리 알고있는 경우에 집중을 했다면, 3장에서는 행동을 알고있는 다른 클래스를 아는 것에대해서 다룰 것이다. (상속에 대해서는 6장)

잘 디자인된 객체는 하나의 책임만을 가지고 있기 때문에 객체끼리 서로 상호작용을 할 수 밖에 없다. 서로 협업하기 위해 객체는 서로에 대한 지식을 가져야 하고 이 지식이 의존성을 만들어 낸다. 의존성을 제대로 관리하지 못한다면 어플리케이션은 엉망이 될 것이다.

### 3.1. 의존성 이해하기

만약 하나의 객체를 수정했을 때 다른 객체를 수정해햐 한다면, 후자에 해당하는 객체들은 전자에 해당하는 객체에 의존적이라고 할 수 있다.

아래에는 2장에서 다루었던 Gear클래스가 조금 변형되었다. Gear_inches메서드에서 rim과 tire를 이용하여 새로운 Wheel 인스턴스를 생성한다.

```ruby
class Gear
  attr_reader :chainring, :cog, :rim, :tire
  def initialize(chainring, cog, rim, tire)
    @chainring = chainring
    @cog = cog
    @rim = rim
    @tire = tire
  end

  def gear_inches
    ratio * Wheel.new(rim, tire).diameter
  end

  def ratio
    chainring / cog.to_f
  end
  # ...
end

class Wheel
  attr_reader :rim, :tire
  def initialize(rim, tire)
    @rim = rim
    @tire = tire
  end

  def diameter
    rim + (tire * 2)
  end
  # ...
end

Gear.new(52, 11, 26, 1.5).gear_inches
```

코드를 보고 Wheel 이 변경되었을 때 Gear도  변경되어야 하는 상황이 어떤 경우가 있을지 생각해보자. 이 코드는 생각보다 복잡함을 가지고 있다. Gear는 Wheel에 대해 적어도 4개의 의존성을 가지고 있다. Gear는 이런 의존성 없이도 잘 작동할 수 있고 이런 의존성이 있다는 것 자체가 Gear클래스를 수정하기 어렵고 연약하게 만들고 있다.

#### 3.1.1. 의존성 알아채기

객체는 다음과 같은 내용을 알고있을 때 의존성을 가진다.

- **다른 클래스의 이름** : Gear는 Wheel이라는 클래스가 존재한다고 예상한다.
- **자기 자신을 제외한 다른 객체에게 전송할 메세지 이름** : Gear는 Wheel의 인스턴스가 diameter라는 메서드를 이해할 수 있다는 것을 예상한다.
- **메세지가 필요로하는 아규먼트** : Gear는 Wheel.new가 rim과 tire를 필요로 한다는 것을 안다.
- **아규먼트들의 순서** : Gear는 Wheel.new의 첫 아규먼트로 rim을 두번째 아규먼트로 tire를 사용한다는 것은 안다.

위에서 나열한 의존성들은 Wheel을 변경했을 때 어쩔수 없이 Gear도 수정해야 하는 상황을 만든다. 의존성이 생기는 것은 어쩔수 없지만, 나열된 의존성의 대부분은 불필요한 것이다. 우리의 과제는 각 클래스가 자신이 해야하는 일을 하기 위한 **최소한의 지식만을 알고 그 외에는 아무것도 모르도록 의존성을 관리** 하는 것이다.

#### 3.1.2. 객체들 간의 결합(CBO - Coupling Between Objects)

이러한 의존성들은 Gear를 Wheel에 결합시킨다. 즉, 결합이 의존성을 만들어 낸다. Gear가 Wheel을 더 많이 알 수록 더욱 견고하게 결합한다. 두 객체가 견고하게 결합될수록 하나인것 처럼 행동한다.

Wheel을 바꾸면 Gear를 바꾸는게 필수적이라는 것을 안다. Gear를 재사용하고 싶다면, Wheel또한 따라오게 된다. Gear를 테스트하려면 Wheel도 테스트 해야한다.

![image](https://user-images.githubusercontent.com/53181778/85681361-2c59f080-b706-11ea-882d-45bfd3607101.png)

Gear는 A,B,C,D,Wheel에 의존하고 있으로 Gear는 다섯개의 객체와 결합하고 있다. Gear를 다른 곳에서 사용하려고 하기 전, 또는 Gear가 의존하고 있는 클래스를 수정하기 전까지 무엇이 문제인지 파악하기 어렵다. Gear는 전혀 독립적이지 않다. 의존성은 다른 객체가 한 객체 내부에 깊이 관여하고 있는 부분이다. 의존성이 높은 객체들은 마치 하나인듯 행동하며 이들은 발맞추어 움직인다.(톱니바퀴와 같다고 생각하면 될듯)

둘 이상의 객체가 강력하게 결합되어 있다면 이들 중 하나만 재사용하는 것은 불가능하다. 하나를 바꾸려면 다른 것도 바꾸어야 한다. 미처 확인하지 못한 제대로 관리하지 않은 의존성들이 남아 있다면 어플리케이션 자체가 엉망진창이 될 것이다.

#### 3.1.3. 다른 의존성들

위에서 살펴본 4가지 의존성을 컴토하고 이들로 인해 생겨나는 문제를 해결하기 위한 기술을 다루기 전에 다른 장에서 다루게 될 몇몇 일반적인 의존성 이슈를 다루고 넘어가겠다.

먼저 하나의 객체가 다른 객체에 대해 알고있고, 이 다른 객체가 또 다른 무언가를 알고 있는 또 다른 객체에 대해 알고 있는 경우( 0 - 0 - 0 - 0 이런식으로 체인처럼 연결된 경우) 멀리 있는 객체이 행동을 실행시키려 할 때 가장 심각한 피해를 야기하게 된다. 이 의존성은 기본적으로 **자기 자신을 제외한 다른 객체에게 전송할 메세지의 이름을 아는 의존성**이다. 단지 확장된 형태일 뿐이며, 메세지 연쇄(메세지 체이닝)은 원래 있던 두 객체 사이의 의존성뿐 아니라, 중간에 거쳐간 모든 객체와 메세지들 사이에도 의존성을 만들어 낸다. 만약에 중간의 하나의 어떤 객체가 변하게 되면 이 변화는 첫 번쨰 객체에 까지 영향을 미치기 때문에 첫 번째 객체에 수정을 강제할 가능성이 무척 높다. 이런 경우를 Law of Demeter가 위반되었다고 말한다. 자세한 내용은 4장에서 다루도록 하겠다.

의존성의 또 다른 영역은 테스트가 코드에 대해 가지는 의존성이다. 코드보다 테스트를 먼저 작성하는 사람들이 있다. 테스트가 디자인을 이끌어 낸다. 하지만 테스트는 코드를 참조하고 그런 의미에서 코드에 의존적이다. 테스트를 처음 접하는 프로그래머들은 종종 코드와 지나치게 결합된 테스트를 작성하는 경향이 있다. 이 강한 결합은 결국 엄청난 좌절감을 낳곤한다. 코드의 핵심적인 내용은 전혀 바뀌지 않았는 데도 불구하고 리팩토링 때마다 테스트가 깨져나간다. 테스트를 유지하는 비용이 테스트를 통해 얻는 가치보다 더 높아지기 시작한다. 테스트-코드 사이의 지나친 결합은 코드-코드 사이의 지나친 결합과 동일한 결과를 낳는다. 이 결합은 코드의 수정이 뒤이어 테스트의 수정을 강제하는 의존성이다. 테스트 디자인에 대해서는 9장에서 다루도록 하겠다.

### 3.2. 약하게 결합된 코드 작성하기

의존성은 클래스 그리고 클래스가 건드리는 것을 붙여버리는 본드와 같다. 약간의 본드는 필요하지만 너무 많은 본드는 좋지않다. 의존성을 줄이는 작업은 곧 불필요한 본드가 무엇인지 알고 제거하는 과정이다.

#### 3.2.1. 의존성 주입하기

클래스의 이름을 통해 다른 클래스를 참조하는 방식은 상당히 끈끈한 spot을 만든다. 지금까지 작성했던 Gear클래스에서 gear_inches 메서드는 Wheel 클래스를 명시적으로 참조하고 있다.

```ruby
class Gear
  attr_reader :chainring, :cog, :rim, :tire
  def initialize(chainring, cog, rim, tire)
    @chainring = chainring
    @cog = cog
    @rim = rim
    @tire = tire
  end

  def gear_inches
    ratio * Wheel.new(rim, tire).diameter
  end
  # ...
end

Gear.new(52, 11, 26, 1.5).gear_inches
```

Wheel클래스의 이름을 직접 참조할 때 가장 눈에 띄는 부분은 Wheel 클래스의 이름을 변경하면 gear_inches의 메서드도 함꼐 변해야 한다는 점이다. 사실 Wheel클래스의 이름을 변경하는 것은 큰 문제를 만들어내지 않는다. 진짜 문제는 잘 드러나지 않고 더 큰 문제를 야기하는 곳에 숨겨져있다.

Gear가 Wheel을 참조하는 부분을 저 쪽에 있는 gear_inches 메서드 속에 하드코딩해 놓았을 때 Gear는 Wheel 인스턴스의 기어의 인치만을 계산하겠다고 명시적으로 보여주고 있는 것이다. Gear는 다른 종류의 객체와 협업하기를 거부하고 있다.

자전거 디스크나 실린더 같은 객체를 다루게 되었을 경우, 실린더와 디스크 객체를 사용하는 기어의 기어인치를 알아야한다. 하지만 우리는 기어 인치를 계산할 수 없다.디스크와 실린더는 지름을 가지고 있지만, Gear는 Wheel에 찰싹 붙어 있기 때문에 기어인치를 계산할 수 없다.

위 코드는 고정된 타입에 불필요하게 들러 붙어 있는 클래스에 얼마나 문제가 많은지 보여준다. 중요한 것은 '객체의 클래스가 무엇인지'가 아니라, '우리가 전송하는 메세지가 무엇인지'이다. 즉, 기어에게는 diameter메서드에 반응 할 수 있는 객체가 필요한 것이다. Gear는 대상이 되는 객체의 클래스가 무엇인지는 관심도 없고 알 필요도 ㅇ벗다. Gear_inches를 계산하기 위해 Gear가 Wheel의 존재를 알 필요는 없다. 더욱더 Wheel이 초기화되기 위해 rim과 tire가 필요하다는 것을 알 필요가 없다. Gear에게는 diameter를 알고 있는 객체만 있으면 된다.

Gear의 쓸모 없는 의존성으로 재사용성이 떨어지고 수정해야할 일이 많이 생긴다. 아래 코드는 Gear 클래스를 diameter에 반응할 수 있는 객체만 가지고도 초기화 할 수 있다.

```ruby
class Gear
  attr_reader :chainring, :cog, :wheel
  def initialize(chainring, cog, wheel)
    @chainring = chainring
    @cog = cog
    @wheel = wheel
  end

  def gear_inches
    ratio * wheel.diameter
  end
  # ...
end

# Gear expects a ‘Duck’ that knows ‘diameter’
Gear.new(52, 11, Wheel.new(26, 1.5)).gear_inches
```

Gear는 @wheel 변수를 사용하여 wheel 메서드로 변수에 접근한다. 하지만 Gear가 알고있는 것은 자기 자신이 diameter메서드에 반응할 줄 아는 객체를 가지고 있다는 것 뿐이다.(Wheel의 인스턴스인지는 관심 없음)

아주 작은 변화처럼 보이지만, Wheel의 인스턴스를 Gear 클래스 밖에서 생성하기 때문에 Gear와 Wheel 사이의 결합이 없어졌다. 이제 Gears는 diameter를 구현하고 있는 어떤 객체와도 협업할 수 있게 되었다.

이 기술을 **의존성 주입**(dependency injection)이라고 부른다. 엄청 대단한 기술로 알려져 있지만 사실 이렇게 단순하다. Gear는 Wheel클래스, Wheel을 초기화할 때 넘겨줘야 하는 인자와 인자의 순서에 대해 명시적으로 의존하고 있었지만 의존성 중비을 통해 이 모든 의존성이 diameter 메서드에 대한 단 하나의 의존성으로 줄어 들었다. 아는 것을 줄임으로 더 똑똑한 코드를 만든 것이다.

종속성 주입을 사용하여 코드를 형상화하는 것은 클래스의 이름을 알고 있는 책임과 해당 클래스에 보낼 메시지의 이름을 아는 책임이 서로 다른 객체에 속할 수 있다는 것을 인식하는 능력으로 부터 나온다. Gear가 어딘가로 diameter메세지를 전송해야 한다고해서 Gear가 Wheel에 대해서 알필요 가 없는 것처럼 말이다.

그렇다면 실제 Wheel 클래스에 대해 알아야 할 책임은 누구에게 있을까? 이 부분에 대해서는 나중에 다루도록 하겠다. 일단은 Gear가 그것을 몰라도 된다는 것이 중요하다.

#### 3.2.2. 의존성 격리시키기

불필요한 의존성을 모두 제거하면 가장 좋겠지만 현실적으로 어려운 문제이다.  이미 작동 중인 어플리케이션을 가지고 작업할 때 실제로 수정할 수 있는 부분은 매우 제한적이다. 완벽함을 추구할 수 없다면 우리의 목표는 전반적인 상태를 발전시키는 것에 만족해야 한다.

그렇기 때문에 불필요한 의존성을 제거할 수 없는 경우라면 의존성을 클래스 안에서 격리시켜 놓아야 한다. 불필요한 의존성이 어디에 있는지 쉽게 찾고 줄일 수 있도록 의존성을 고립시키는 방법을 알아보자.

- 인스턴스 생성을 격리시키기

  만약 제약조건이 너무 낳아서 Gear에 Wheel을 주입할 수 없다면 새로운 Wheel 인스턴스를 만드는 과정을 Gear클래스 내부에 격리시켜 놓을 필요가 있다. 이는 의존성을 명시적으로 노출하는 작업인 동시에 Wheel이 Gear클래스 내부에 스며드는 것을 막는다.

  두 개의 예시를 통해 접근법을 살펴보자.

  첫 예시는 새로운 Wheel 인스턴스를 생성하는 과정을 Gear의 gear_inches 메서드에서 initialize 메서드 속으로 옮겼다. gear_inches 메서드는 조금더 깔끔해졌고, wheel에 대한 의존성을 더욱 뚜렷하게 드러낼 수 있게 되었다.이런 접근은 Gear가 새로운 인스턴스를 만들때마다 무조건 새로운 Wheel 인스턴스를 생성한다는 사실에 주의해야한다.

  ```ruby
  class Gear
    attr_reader :chainring, :cog, :rim, :tire
    def initialize(chainring, cog, rim, tire)
      @chainring = chainring
      @cog = cog
      @wheel = Wheel.new(rim, tire)
    end

    def gear_inches
      ratio * wheel.diameter
    end
    # ...
  ```

  다른 방법은 명시적으로 정의된 wheel 메서드를 통해 새로운 Wheel 인스턴스를 만드는 방법이다. 이는 루비의 `||=` 연산자를 이용해서 객체가 필요한 순간에 왔을 때, Wheel인스턴스를 만든다. 이런 경우 gear_inches 가 Wheel 메서드를 호출하기 전까지 Wheel의 인스턴스가 만들어 지지않는다.

  ```ruby
  class Gear
    attr_reader :chainring, :cog, :rim, :tire
    def initialize(chainring, cog, rim, tire)
      @chainring = chainring
      @cog = cog
      @rim = rim
      @tire = tire
    end

    def gear_inches
      ratio * wheel.diameter
    end

    def wheel
      @wheel ||= Wheel.new(rim, tire)
    end
    # ...
  ```

  위 두 예시에서도 Gear는 너무 많은 거을 알고 이다. 여전히 rim과 tire를 초기화 인자로 전달해줄 수 있어야 하고 Gear내부에서 Wheel인스턴스를 생성해야한다. 또한, Wheel과 너무 밀접하게 연관되어서 Wheel을 제외한 인스턴스를 가지고는 gear_inch를 구할 수 없다.

  그럼에도 어느정도의 발전은 있다. Gear_inches가 가지고 있던 몇몇 의존성을 줄였으며 Gear가 Wheel에 의존하고 있다는 사실을 뚜렷하게 보여줄 수 있다. 의존성을 오히려 잘 보이게 함으로 재사용의 장벽을 낮추고 리팩토링을 더 쉽게 할 수 있게 만들어 주었다.

  외부 클래스 이름에 대한 으존성을 이렇게 관리하게 되면 의존성을 고려하면서 설계를 하기 때문에 클래스는 자연스럽게 덜 결합된 형태를 띈다.

- 취약한 외부 메세지 격리시키키

  **외부 클래스 이름을 참조**하는 지점을 격리시켰으니, **외부로 전송되는 메세지에 대한 의존성**에 대해 살펴보자. 즉, 나 자신이 아닌 외부의 어떤 객체에 보내는 메세지를 살펴보자. 예를 들어, gear_inches는 ratio와 wheel 메세지를 자기 자신에게 보내고 있지만 diameter 메세지는 wheel에게 보내고 있다.

  ```ruby
  def gear_inches
    ratio * wheel.diameter
  end
  ```

  간다한 코드이기에 별 문제가 없어 보이지만, 더 복잡한 코드로 변경시켜야할 경우 문제가 될 수 있다. 아래 예시를 보자

  ```ruby
  def gear_inches
    #... a few lines of scary math
    foo = some_intermediate_result * wheel.diameter
    #... more lines of scary math
  end
  ```

  Wheel.diameter는 엄청난 수학공식들 사이에 숨겨져있다. 되면 gear_inches가 wheel 메서드에 반응한다는 사실에 의존하고 이 wheel이 diameter메서드에 반응한다는 사실에도 의존한다. Gear_inches메서드 속에 외부에 대한 의존성을 심어 놓는 것은 불필요한 일이고 코드를 취약하게 만든다.

  외부 의존성을 걷어내고 의존성을 클래스 내부의 메서드 속에 캡슐화시켜 놓으면 gear_inches 메서드를 수정해야 하는 상황도 줄일 수 있다.

  ```ruby
  def gear_inches
    #... a few lines of scary math
    foo = some_intermediate_result * diameter
    #... more lines of scary math
  end

  def diameter
    wheel.diameter
  end
  ```

  만약 이전에 diameter를 Gear클래스 내부의 이곳저곳에서 사용해야 했다면 아마 DRY를 유지하기 위해 처음부터 diameter 메서드를 만들었을 것이다. 여기서 차이점은 타이밍이다.

  원래 코드에서 gear_inches는 wheel이 diameter를 가지고 있다는 사실을 알고 있었다. 이 지식은 gear_inches를 외부의 객체에 그리고 이 외부 객체의 메서드들에 결합시켜 버리는 위험한 의존성이다 수정 이후 gear_inches는 조금 더 추상화 되었다. Gear는 wheel.diameter를 별도의 메서드에 분리하여 gear_inches가 자기자신에게 전송하는 메세지에 의존할 수 있게 했다.

  Wheel에서 diameter 메서드의 이름을 바꾸더라도 Gear에 미치는 영향은 diameter메서드(Wrapping method)에 한정될 것 이다. 클래스가 그 내부에서 변하기 쉬운 메세지를 참조하고 있을 때 이 기술을 유용하게 사용할 수 있다.

  이런 문제를 제거하는 또 다른 방법은 의존성이 시작되는 지점으로 돌아가서 의존성의 방향을 반대로 돌려버리는 것이다. 이렇게 함으로 문제 자체를 회피하는 방법이 있다. 이 방법에 대해 설명하기 전에 먼저 짚고가야할 코딩 스킬이 하나있다.

#### 3.2.3. 인자 순서에 대한 의존성 제거하기

필요한 인자를 전달할 때, 보내는 입장에서 인자에 대한 지식을 아는 것을 피할 수 없다. 이 의존성은 피할 수 없는 것이다. 하지만, 인자를 전달하는 것은 종종 감지하기 어려운 두 번째 의존성을 발생시킨다. 많은 메서드 시그니처는 인자를 필요로할 뿐만 아니라, 특정한 순서를 지키길 기대한다.

아래 예시에서 Gear의 initialize 메서드는 세개의 인자를 넘겨받는다. 파라미터가 기본값을 제공하지 않기 때문에 모든 인자를 넘겨주어야 하고, 반드시 순서대로 전달해야 한다.

```ruby
class Gear
  attr_reader :chainring, :cog, :wheel
  def initialize(chainring, cog, wheel)
    @chainring = chainring
    @cog = cog
    @wheel = wheel
  end
  ...
  end

Gear.new(
  52,
  11,
  Wheel.new(26, 1.5)).gear_inches
```

new 메서드를 전송하는 송신자는 Gear의 초기화 메서드에서 정의된 인자의 순서에 의존적이다. 불행하게 인자를 손봐야 하는일은 자주 발생한다. 하지만 인자를 손보는 일은 해당 메서드에 의존적인 객체들을 수정해야 하는 것을 의미한다. 더욱 곤란한 것은 우리가 인자들을 변경하지 않으려 할 수도 있다는 점이다. 디자인 관점에서는 인자를 변경해야 겠지만 모든 의존성을 또 다시 변경하고 싶지 않기 때문이다.

- 초기화 인자로 해시 사용하기

  고정된 인자에 대한 의존을 피하는 가장 간단한 방법으로 해시를 사용할 수 있다. 순서가 고정된 인자대신 옵션을 해시로 만들어서 넘기는 것이 좋다.

  다음은 예시이다.

  ```ruby
  class Gear
    attr_reader :chainring, :cog, :wheel
    def initialize(args)
      @chainring = args[:chainring]
      @cog = args[:cog]
      @wheel = args[:wheel]
    end
    ...
    end

  Gear.new(
    :chainring => 52,
    :cog => 11,
    :wheel => Wheel.new(26, 1.5)).gear_inches
  ```

  이 방법의 가장 뚜렷한 장점은 인자의 순서성을 제거했다는 것이다. 코드가 장황해지긴 했지만, 그 효과에 비하면 별거 아닌 문제점이다.

  인자의 순서의 의존성을 없애는 대신에 해시 키에대한 의존성이 생겼다. 키에 대한 의존성은 기존의 의존성 보다 훨씬 안정적인 의존성이기 때문에 문제가 되지 않는다. 또한, 인자들에 대한 문서의 역할도 해주게 된다.

  하지만, 별거 아닌 기능을 만드는데 해시를 쓴다면 조금 부담스러울 수도 있다. 그리고 고정된 인자에 더해 추가적으로 해시를 이용하여 사용하기도한다.

- 기본값을 정의하기

  인자에 기본값을 추가하는 방법은 여러가지가 있다. boolean이 아닌 간단한 기본값은 루비의 `||`메서드를 이용해 추가할 수 있다.

  ```ruby
  # specifying defaults using ||
  def initialize(args)
    @chainring = args[:chainring] || 40
    @cog = args[:cog] || 18
    @wheel = args[:wheel]
  end
  ```

  일반 적인 방법이지만, 주의해야할 점이 있다. ||를 사용하는 것은 hash에 등록되지 않은 키에 대한 요청을 하게되면 nil을 반환하는 특성에 의존하고 있다. 해시 인자가 :boolean_thing이라는 키를 가지고 있고 이 키의 기본값을 true로 설정하고 싶은 경우가 있을 수 있다. 이런 경우에도 ||를 사용하면 :boolean_thing의 키의 값을 false나 nil로 설정할 수 없게 된다.

  예를 들어 아래의 경우는 :boolean_thing키가 정의되지 않을 경우 뿐만 아니라, nil이나 false의 값을 가지고 있을 경우에도 @bool의 값을 true로 만든다.

  ```ruby
  @bool = args[:boolean_thing] || true
  ```

  ||의 특성 때문에 불린 값을 인자로 받고 싶거나 false와 nil을 구부해야 하는 경우에 fetch메서드를 사용하는 것이 좋다. fetch메서드는 우리가 사용하는 키가 해시에 정의되어 있기를  기대하며 키가 없는 경우에 별도의 처리방식을 제공한다. fetch는 우리가 찾는 키가 없을 때 자동으로 **nil을 반환하지 않는다는 장점**이 있다.

  아래 예시에서 fetch를 사용한 기본값을 정의하였다. 이렇게 하면 키가 존재하고 값이 false나 nil일 경우에 그대로 사용할 수 있다.

  ```ruby
  # specifying defaults using fetch
  def initialize(args)
    @chainring = args.fetch(:chainring, 40)
    @cog = args.fetch(:cog, 18)
    @wheel = args[:wheel]
  end
  ```

  initialize메서드 속에 기본값을 설정하는 코드를 완전히 제거하고 별도의 Warpping method에서 기본값을 설정하는 방법도 있다. 아래 코드의 default 메서드는 초기화 과정에서 args 인수에 **merge** 될 기본 해시를 정의하고 있다. 이렇게 사용하면 fetch와 동일한 효과를 얻을 수 있다. 즉, args 해시에 키값이 없는 경우에만 기본 해시의 값이 사용된다.

  ```ruby
  # specifying defaults by merging a defaults hash
  def initialize(args)
    args = defaults.merge(args)
    @chainring = args[:chainring]
    # ...
  end

  def defaults
    {:chainring => 40, :cog => 18}
  end
  ```

  별도의 메서드를 사용하는 방법은 앞의 경우에도 잘 적용할 수 있지만 기본값이 훨씬 복잡한 경우에 특히 좋다. 기본 값이 단순한 스트링이나 숫자가 아닌고 어떠한 연산의 결과라면 defaults내부에서 구현하면 된다.

- 멀티파라미터 초기화를 격리시키기

  메서드를 수정하지 못하는 경우도 존재한다. 예를 들면 외부 프레임워크의 경우이다. 만약 기어를 외부 프레임 워크의 한 부분으로 생각한다면, initialize 메서드는 순서가 고정된 인자들을 필요로 할 것이다.  하지만 Gear이느턴스를 생성하는 지점을 하나의 메서드로 감싸서 코드를 DRY하게 만들 수 있다. 우리가 만드는 어플리케이션은 우리가 작성한 코드에 의존해야 한다.

  이 의존성을 해결하기 위해 GearWapper 모듈을 만들어 보자. 모듈을 이용함으로 외부 인터페이스에 대한 모든 지식을 한 곳에 집중시킬 수 있을 뿐만 아니라 어플리케이션이 사용할 수 있는 조금 더 좋은 인터페이스를 제공하게 된다.

  ```ruby
  # When Gear is part of an external interface
  module SomeFramework
    class Gear
      attr_reader :chainring, :cog, :wheel
      def initialize(chainring, cog, wheel)
        @chainring = chainring
        @cog = cog
        @wheel = wheel
      end
      # ...
    end
  end

  # wrap the interface to protect yourself from changes
  module GearWrapper
    def self.gear(args)
      SomeFramework::Gear.new(args[:chainring],
        args[:cog],
        args[:wheel])
    end
  end

  GearWrapper.gear(
    :chainring => 52,
    :cog => 11,
    :wheel => Wheel.new(26, 1.5)).gear_inches
  ```

  SomeFramework라는 외부 프레임워크에 Gear라는 클래스는 고정된 인자를 가지고 있다.  GearWrapper는 옵션 해시를 이용하여 새로운 Gear인스턴스를 생성한다.

  두 가지 기억해야할 점이 있다. GearWrapper는 클래스가 아닌 모듈이라는 점이다. 모듈을 이용함으로 우리는 GearWrapper 이느턴스를 만들지 않고도 gear메시지를 전송하는 명시적이고 독립적인 객체를 얻었다. 아마 클래스에 특정 모듈을 include하는 것과  혼동 될 수 있겠지만, GearWrapper는 특정 클래스를 인클루드 하기 위한 것이 아니라, gear메세지에 인스턴스 생성없이 직접 반응하기 위한 것이다.

  또 다른 점은 오로지 클래스의 인스턴스를 생성하기 위해서만 GearWrapper가 존재한다는 점이다. 객체지향에서 이런 객체를 `팩토리(Factory)`라고 부른다. 팩토리는 다른 객체를 만들기 위해 존재하는 객체이다.

  지금까지 고정된 인자들을 옵션 해시로 대체하는 기술에 대해 학습했다. 외부에 대한 의존성이 코드 속으로 스며들게 내버려 두지 말자. 애플리케이션이 직접 통제할 수 있는 래퍼 메서드를 만들어 어플리케이션을 보호하자.

  ### 3.3. 의존성 방향 관리하기

  모든 의존성은 방향이 있다. 의존성의 방향을 반대로 돌려 의존성을 관리하는 방법이 있다는 것을 앞에서 살짝 언급하여였다. 그에 대해서 조금더 심도있게 다루어보자.

  #### 3.3.1. 의존성 뒤짚기

  지금까지 사용했던 모든 예시에서 Gear는 Wheel이나 diameter에 의존했다. 하지만 이 의존성을 반대로 설정할 수도 있다. Wheel이 Gear나 ratio에 의존할 수 도 있었다. 아래 코드는 이런 뒤바뀐 의존성의 한 예를 보여준다.

  ```ruby
  class Gear
    attr_reader :chainring, :cog
    def initialize(chainring, cog)
      @chainring = chainring
      @cog = cog
    end

    def gear_inches(diameter)
      ratio * diameter
    end

    def ratio
      chainring / cog.to_f
    end
    # ...
  end

  class Wheel
    attr_reader :rim, :tire, :gear
    def initialize(rim, tire, chainring, cog)
      @rim = rim
      @tire = tire
      @gear = Gear.new(chainring, cog)
    end

    def diameter
      rim + (tire * 2)
    end

    def gear_inches
      gear.gear_inches(diameter)
    end
    # ...
  end

  Wheel.new(26, 1.5, 52, 11).gear_inches
  ```

  Wheel이 Gear인스턴스에 의존하는 것을 확인 할 수 있다. 의존성의 방향이 바뀌어도 별 문제가 없어보인다 방향성이 바뀌었다고 결과가 달라지지도 않았다. 방향성은 코드가 수정될 일이 없다면 크게 중요한 문제는 아니다.

  하지만, 방향성을 설정하는 것은 추후에 있을 변화에 대해 지대한 영향을 미친다.

#### 3.3.2. 의존성 방향을 선택하기

클래스가 사람이라고 해보자. 크래스에게 어떻게 행동해야하는지 조언해야 한다면, 스스로 보다 더 조금 변하는 것들에 의존하라고 말할 수 있다. 이 간단한 문장은 코드에 대한 단순한 사실 세가지를 기반으로 조금더 다듬을 수 있다.

- 어떤 클래스는 다른 클래스에 비해 요구사항이 자주 바뀐다.
- 콘크리트 클래스는 추상 클래스보다 수정해야 하는 경우가 빈번히 발생한다.
- 의존성이 높은 클래스를 변경하는 것은 코드의 여러 곳에 영향을 미친다.

이 세가지는 종종 겹치기도 하고 독립적이기도 하며, 그 의미가 뚜렷하다.

- 변경 가능성 이해하기

  어떤 클래스가 다른 클래스보다 변결될 가능성이 높다는 인식은, 우리가 작성한 코드 이외에도 우리가 작성하지는 않았지만 사용하는 코드에도 적용된다. 루비의 베이스 클래스나 또는 다른 프레임워크 코드도 변경이 될 가능성이 있다.

  우리가 작성하는 코드보다 루비의 베이스 클래스가 잘 바뀌지 않는다는 것은 정말 다행이다. 루비의 베이스 클래스는 사실 크게 변할 일이 없기 때문에 많이 고려하지 않아도된다.

  하지만 다른 프레임워크는 다른 상황이다. 프레임워크의 코드는 안정적이긴 하지만 그렇지 않은 경우도 존재한다.

  변경 가능성을 아는 방법은 어플리케이션에서 사용하는 모든 클래스를 다른 클래스와 비교하여 얼마나 변경되지 않았는지를 기준으로 순위를 매겨볼 수 있다. 이 순위는 의존성의 방향을 결정하는데 핵심적이다.

- 구체적인것과 추상적인것 인식하기

  두 번째는 코드의 구체성과 추상성을 이해하는데서 출발한다. 여기서 추상이라는 개념은 "모든 구체적인 것으로부터 분리된"이라는 뜻으로  사용된다. 그리고 이 개념은 코드에 대한 루비의 기본적인 태도, 특정한 기술적 제약이나 스타일에 반대하는 입장에 잘 어울린디.

  Gear가 Wheel, Wheel.new 등에 의존적일 때 Gear는 매우 구체적인 코드에 의존하고 있는 것이다. 반대로, Wheel을 Gear에 주입하는 방식의 코드는 Gear는 훨씬 추상적인 것에 의존하는 것이다.

  > 만약 정적 타입 언어에서 이와 같은 기능을 구현하려면 어떻게 해야할까? 정적 언어는 마치 타입에 대한 단위 테스트 처럼 작동하는 컴파일러를 가지고 있기 때문에 Gear에 우리가 내키는 대로 아무 객체나 주입할 수 없다. 인터페이스를 먼저 작성하고 diameter를 인터페이스의 일부로 정의하고 이 인터페이스를 Wheel 클래스에 포함시키고 gear에게 우리가 지금 주입하는 클래스가 이런 인터페이스의 한 종류라고 알려줘야 할 것이다.
  >
  > 루비 사용자들은 이런 반복잡업을 하지 않아도 된다. 하지만 변경 사항을 명시적으로 표시하도록 강제하는 언어가 지니는 이점도 있다. 이런 언어들은 우리가 추상적인 인터페이스를 만들고 있다는 사실을 명시적으로 드러내준다. 실수로 또는 의도치 않게 추상화된 코드를 만드는 것은 불가능하다. 정적 언어에서는 언제나 명확인 의도를 가지고 인터페이스를 정의한다.
  >
  > 루비의 경우, Gear에 Wheel을 주입하고 Gear가 diameter라는 메서드에 반응하는 오리타입에 의존하도록 했을 때 우리는 별 생각없이 인터페이스를 정의한 것이다. 어떤 종류의 것들은 지름을 가지고 있다는 생각을 추상화한 것이 이 인터페이스 이다. 이 추상화는 구체 클래스들로부터 추출되었고, 구체적인것들로 부터 분리되었다.

  추상화의 훌륭한 점은 일반적이고 안정적인 성질을 지닌다는 점이다. 추상화된 인터페이스는 인터페이스가 기반하고 있던 구체 클래스보다 변경될 일이 훨씬 적다. 앞으로 이어질 내용에서 클래스라는 표현은 일반적인 클래스 뿐만아니라 이런 인터페이스 역시 지칭한다. 이런 인터페이스도 의존성을 가지고 있기 때문에 디자인을 할 떄 고려를 해야한다.

- 의존성높은 클래스 피하기

  마지막은 의존성이 높은 클래스를 만들면 그 대가를 반드시 치뤄야한다는 것이다. 의존성이 높은 클래스를 수정할 떄 감내해야 하는 부정적인 효과는 매우 자명하다. 의존성이 높은 클래스가 갖는 효과에 대해서는 좀더 설명이 필요하다. 작은 수정으로 전체를 수정해야 한다면 아무도 수정하고 싶지 않을 것이다. 즉, 평생 어플리케이션에서 이 문제를 안고 가야한다.

- 문제가 되는 의존성 찾아내기

  지금까지 검토했던 내용을 어플리케이션의 모든 코드 속에서 종합적으로 검토해보자. 언제 변화에 봉착하게 될지, 어느 정도로 추상화되어 있는지, 의존성이 몇 군데 있는지를 검토한다.

  중요한 디자인 결정을 내려야 하는 순간은 **수정을 해야 할수도 있는 가능성이** **여러 의존성**과 만나는 지점에서 발생한다. 이 둘의 조합은 어플리케이션의 도움이 될수도 치명적일 수도있다.

  ![image](https://user-images.githubusercontent.com/53181778/85717426-79e75500-b728-11ea-9df8-1893d5e54937.png)

그림의 가로축은 **요구사항의 변경이 발생할 가능성**, 세로축은 **클래스에 의존하고 있는 객체의 수**를 반영한다. 어플리케이션의 모든 클래스를 각각 A,B,C,D 영역과 매칭 시킬 수 있을 것이다.

변경이 발생할 가능성이 낮지만 이 클래스에 의존하고 있는 객체가 많은 클래스는 A영역에 속한다. 이 영역에는 추상클래스나 인터페이스가 속한다. 충분히 잘 디자인된 어플리케이션에서는 의존성이 추상화 된것 근처에 몰려있을 수 밖에 없다. 추상화 된것은 변경가능성이 낮기 떄문이다.

하지만, 클래스가 A영역에 속하기 때문에 추상화된 것이 아니라는 것은 확실히 해야한다. (추상화되고 잘 설계된 경우에 A에 속하는 것임, A에 속한다고 추상화 됐다고는 할 수없다.) A영역에 있는 클래스가 추상화가 되지 않았다면, 추상화 될 필요가 있다.

B영역을 보기전에 C영역을 보자 C영역은 A영역과 정반대다. C영역은 변경될 가능성은 높지만 클래스에 딸린 객체가 적은 클래스들로 채워져있다. 이곳의 클래스들은 보다 구체적인 경향이 있어 변경될 가능성이 높지만, 의존적인 클래스가 적기 때문에 큰 문제가 되지 않는다.

B역영의 클래스들은 디자인의 관점에서 보면 가장 중요성이 낮다. 어떤 변화에 대해 가장 적은 영향을 받는 클래스들이기 때문이다.

A, B, C 영역에 있는 클래스들은 큰 문제가 없다. 문제는 D영역이다. D영역은 위험영역이라는 이름이 어울린다. D영역의 클래스들은 어플리케이션의 건강상태를 드러내는 지표이다.

`자기 자신보다 덜 변하는 것들에 의존하라`라는 것이 좋은 디자인의 핵심이다.

## 4. Creating Flexible Interfaces

객체지향 어플리케이션을 클래스들을 합치는 것이라고 생각하기 쉽다. 클래스는 눈에 잘 보이기 때문에 클래스의 책임이나 의존송을 중심으로 디자인에 대해 논하는 경우가 많다.

클래스 레벨에서 다루어야 하는 디자인 이슈들도 있지만, 클래스 이상의 것들이 존재한다. 어플리케이션은 클래스로 구성되어 있지만, **메세지**를 통해서 정의된다. 디자인은 객체 사이를 가로지르는 메세지에 관심을 가지고 해야한다. 객체가 무엇을 알고(객체의 책임), 누구를 알고(객체의 의존성)있는지 뿐만 아니라, 객체끼리 서로 소통하는 방법을 알아야 한다.

객체 사이의 소통은 인터페이스를 통해 이루어진다.

### 4.1. 인터페이스 이해하기

![image](https://user-images.githubusercontent.com/53181778/85817884-32091200-b7aa-11ea-9aa6-82fce40fa665.png)

그림과 같은 두 종류의 어플리케이션이 있다고 생각해 보자. 왼쪽의 어플리케이션은 특정한 패턴이 존재하지 않아 보인다. 모든 객체가 다른 모든 객체와 연결되어 있다. 반면에 오른쪽 어플리케이셔의 메세지들은 정확하게 드러나는 패턴을 보여준다.

왼쪽 어플리케이션은 객체를 재사용하기가 어렵다. 자기 자신을 너무 많이 드러내고 주변 객체에 대해 너무 많이 알고있다. 독립적으로 존재하는 객체는 없고, 하나를 재사용하기 위해서는 전체를 사용해야 하고 하나를 수정하려면 전체를 수정해야 한다.

오른쪽 어플리케이션은 조립 가능한 구성으로 되어있다. 부품처럼 작동하는 객체로 이루어져 있으며, 자신을 최소한으로 드러내며 다른 객체에 대해서도 최소로 알고 있다.

오해하기 쉬우나, 왼쪽 어플리케이션은 의존성 주입이나 단일 책임 원칙과는 무관하다. 즉, 의존성 주입과 단일 책임 원칙만으로는 문제를 해결할 수 없다. 이 문제의 핵심은 클래스가 무엇을 하는지에 있는 것이 아니라, 무엇을 드러내는지에 있다.

오른쪽 어플리케이션의 메세지 패턴은 나름의 제약사향을 보여준다. 객체가 어떤 메세지를 주고 받을지에 대한 일종의 합의가 되어있다. 즉, 각 객체는 다른 객체가 사용할 수 있는 메서드의 묶음을 잘 정해놓았다.

밖으로 노출된 메서드가 클래스의 **퍼블릭 인터페이스**를 구성한다. 여기서 말하는 인터페이스는 클래스 안에 있는 인터페이스를 지칭한다. 클래스는 메서드를 구현하고 그중 일부는 클래스의 외부의 객체가 사용하기 위한 것이고, 그것이 클래스의 퍼블릭 인터페이스를 구성한다.

하나의 클래스로부터 독립되어 있고, 여러 클래스사이를 돌아다니는 또 다른 종류의 인터페이스도 있다. 이런 의미의 인터페이스는 `메시지의 묶음`을 의미한다. 메세지들 자체가 인터페이스를 정의하는 것이다. 각 클래스는 이런 인터페이스가 요구하는 메서드들을 구현한다. 이는 마치 인터페이스가 가상의 클래스를 저의하고 있는 것과 같다. 인터페이스가 요구하는 메서드를 구현하고 있다면 어떤 클래스든 `인터페이스 같은 것` 처럼 동작한다.

### 4.2 인터페이스 정의하기

식당을 예로들면, 손님은 메뉴판보고 주문을 하고 손님의 주문내역은 홀과 주방을 이어주는 작은 창을 지나 주방으로 전달된다. 손님은 주문을 하면 그만이지만, 부엌은 각 주문마다 다른 프로세스로 요리를 제공해준다. 여기서 메뉴판을 퍼블릭 인터페이스로 볼 수 있다. 주방은 많은 일이 벌어지고 수많은 메세지가 오고 가지만, 손님들에게는 private하기에 보이지 않는다.

퍼블릭과 프라이빗의 구분은 일을 가장 효육적으로 처리하기 위해 존재한다. 손님은 요리를 어떻게 하는지 몰라도 메뉴판을 보고 주문을 할 수 있다. 클래스는 주방과도 같다. 클래스는 하나의 책임을 제대로 수행하기 위해 존재하며 수 많은 메서드를 구현하고 있다. 클래스의 핵심 책임을 메인으로 다루는 메서드부터, 클래스 내부에서만 사용하기 위해 만들어진 유틸리티 메서드까지 그 범위는 다양하다. 어떤 메서드는 클래스의 메뉴판과 같은 역할을 하는 퍼블릭 메서드이고, 어떤 메서드들은 자잘한 내부 구현에 관여하기 때문에 프라이빗 메서드이다.

#### 4.2.1. 퍼블릭 인터페이스

클래스의 퍼블릭 인터페이스를 구성하는 메서드는 바깥에 보여지는 클래스의 얼굴이다.

퍼블릭 인터페이스 메서드의 특징

- 클래스의 핵심 책임을 드러낸다.
- 다른 객체에 의해 호출될 수 있다.
- 쉽게 변경되지 않는다.
- 다른 객체가 안정적으로 의존할 수 있다.
- 테스트를 통해 꼼꼼하게 문서화되어 있다.

#### 4.2.2. 프라이빗 인터페이스

그 외의 메서드는 프라이빗 인터페이스의 부분이다.

프라이빗 인터페이스 메서드의 특징

- 세부적인 구현을 담당한다.
- 다른 객체에 의해 호출되지 않는다.
- 필요에 따라 언제든 변경할 수 있다.
- 다른 객체가 의존하기에는 위험하다.
- 테스트에서 다루지 않을 수도 있다.

#### 4.2.3. 책임, 의존성, 인터페이스

클래스의 단일 책임 : 클래스는 단일 책임을 위해 구성되어 있다.

- 클래스의 퍼블릭 인터페이스는 클래스의 얼굴과 마찬가지 이기 때문에 클래스의 책임을 표현한 문장과 매칭되어야 한다. (퍼블릭 인터페이스는 클래스의 책임에 대한 설명서)

의존성 관리하기 : 클래스는 자기 자신보다 덜 변하는 클래스에 의존해야 한다.

- 클래스를 public한 부분과 private한 부분으로 구분한다면, 클래스 내부에서도 자신보다 덜 변화하는 것에 의존해야한다.
- 클래스의 public한 부분은 안정적인 부분이다. private한 부분은 변경될 수 있는 부분이다.
- 즉, public함과 private함이 어떤 메서드에 의존하는게 더 유리한지 알려주는 지표가 된다. 하나의 클래스가 다른 클래스의 public한 메서드를 사용한면서 이 메서드가 안정적이기를 기대할 수 있다. 반대로 private한 메서드를 사용한다면 변할 수 있는 것에 의존한다는 의미를 내포하고 있어 위험이 증가한다.

### 4.3. 퍼블릭 인터페이스 찾기

퍼블릭 인터페이스를 찾는것은 쉽지 않다. 예제를 통해 인터페이스에 대한 기본적인 원칙 몇가지를 이해해보자.

#### 4.3.1. (예시) 자전거 여행 회사

로드바이크와 마운틴 바이크 여행을 다루는 회사에서 여행길을 추천한다. 각 여행길은 여행객이 방문할 수 있는 횟수가 제한되어 있으며, 정해진 수의 가이드와 정비사가 필요하다. 여행길은 체력조건에 따라 난이도별로 분류되고, 마운틴 바이크 여행은 기술적인 어려움에 따라 분류된다. 여행객의 체력조건과 자전거 기술의 수준에 따라 여행객이 주어진 여행길을 소화할 수 있는지를 판단한다. 여행객은 자전거를 빌릴수도 있고 자기 자전거를 가지고 와도 된다. 회사에는 가지고 있는 자전거가 많지않아 자전거 점포들과 자전거를 공유하는 시스템을 갖추고 있다.

다음과 같은 요구사항을 생각해 보자. (나중에 이것을 Usecase 라고 부를 것이다.)

- **여행객**은, **여행길을 선택**하기 위해서, **정해진 날짜**에, **자신에게 맞는 난이도**의, **자전거를 빌릴 수 있는**, **여행길 목록**을 보고싶어 한다.

#### 4.3.2. 의도를 구성하기

어플리케이션의 첫 코드를 짜는 것은 어려운 일이다. 무작정 코드를 작성하면 안된다. 어떤 사람은 테스트 코드부터 작성해야 한다고 한다. 고수들은 디자인에 대해 많이 경험해보고 알고 있기 때문에 의도를 가지고 있어, 테스트를 먼저 짜기 수월하다. 하지만 초보들은 아니다.

하지만, 우리도 이미 나름의 의도를 가지고 있다. 먼저 어떤 클래스가 있어야 할지 사업모델을 보면서 생각해보자.

Customer, Trip, Route, Bike, Mechanic 클래스 정도를 떠올렸을 것이다. 이 클래스들은 어플리케이션 속의 도메인 객체, 즉 정보와 행동을 모두 가지고 있는 명사들을 표현하기 때문이다. 도메인 객체를 찾아내기는 쉽지만, 이들이 어플리케이션의 핵심은 아니다. 오히려 함정에 빠지기 쉽다. 도메인 객체에만 집착하면 행동들을 이 객체 속에 넣어 버리기 쉽기 때문이다.

숙련된 전문가들은 이 객체들을 인지하지만, 집중하지는 않는다. 전문가들은 객체들 사이의 메세지에 주목을 한다. 메세지들은 새로운 객체를 찾도록 도와주는 가이드 역할을 해주며, 도메인 객체만큼 중요한 잘 보이지 않는 새로운 객체를 찾도록 도와준다.

우리는 Usecase를 만족시켜 줄 수 있는 객체들과 메세지의 의도를 먼저 구상할 필요가 있다.

#### 4.3.3. 시퀀스 다이어그램 사용하기

객체와 메세지를 탐구할 수 있는 가장 편리한 방법은 시퀀스 다이어그램을 사용하는 것이다. 시퀀스 다이어그램은 통한 모델링 언어(UML)에 정의되어 있으며, UML이 제공하는 많은 다이어그램 중 하나이다.

아래 그림은 위에서 제시한 Usecase를 표현한다.

![image](https://user-images.githubusercontent.com/53181778/85822804-b6fa2880-b7b6-11ea-9a1e-7ddfd669978b.png)

moe라는 고객 객체가 Trip 클래스에게 적절한 여행을 추천해달라는 메세지를 보내고 Trip클래스는 그에 대한 응답을 한다. 여기서 시퀀스 다이어그램의 중요한 점은 객체 사이를 오가는 메세지를 보여주고 있다는 것이다.

이 다이어그램 예시에서 각 개체는 같은 이름의 동일한 박스 두개로 표현된다. 하나는 위에 하나는 아래에 있고 그 둘은 세로의 점선으로 연결되어 있다. 이 다이어그램에는 두 개의 객체가 있는데, 하나는 moe Customer이고 다른 하나는 class Trip이다. 둘 사이의 메세지는 가로선의 화살표로 표현되어 있다. 그리고 메세지를 받은 객체는 메세지를 처리하는 동안 활성화 되고, 활성화는 세로로 긴 직사각형으로 표현되었다.

Usecase에 포함된 명사는 시퀀스 다이어 그램에서 객체로 표현되었고, 행동들은 메세지로 변경된다. suitable_trips메세지에는 3개의 인자를 필요로 한다. (on_date, of_difficulty, need_bike)

하지만, 과연 Trip에게 자전거에 대한 요청도 하는것이 맞을까? 그것이 Trip의 책임일까'? 일반적으로 표현해보면, 수신자가 이 메세지에 반응할 책임을 가지고 있는가?

시퀀스 다이어그램의 가치는 여기서 나온다. 다이어그램은 객체들이 주고받는 메시지를 명시적으로 보여주고, 객체들은 퍼블릭 인터페이스를 통해서만 소통하기 때문에 시퀀스 다이어그램은 인터페이스를 드러내고, 실험해보며 결국은 인터페이스를 정의하기 위한 도구가 된다.

메세지 기반의 디자인은 클래스 기반의 디자인 관점보다 유연한 어플리케이션을 만들어준다". **"이 클래스가 필요하다는 것은 아는데 이 클래스는 무엇을 해야할까?" 대신에 "이 메세지를 전송해야하는데 누구에게 해야할까?" 라는 관점에서 디자인을 하는 것이 메세지 기반의 디자인 관점이다.** 즉, 객체이기에 메세지를 보내는 것이 아니라, 메세지를 보내야하기 때문에 객체인 것이다.(닭이 먼저냐 달걀이 먼저냐..?)

위 다이어그램에서 Customer가 suitable_trips메세지를 보내는 것은 의심할 여지가 없다. 하지만 이 메세지를 받는 것이 Trip이 맞을까? 아마 새로운 대안을 찾아야 할 것이다. 여행에 어울리는 자전거가 있는지 파악하는 것이 Trip의 역할이 아니면 Bicycle 클래스의 책임인지도 모른다. Trip에게는 suitable_trips메세지에 대한 응답을 할 책임이 있고, Bicycle에게는 suitable_bicyle를 처리해야하는 책임이 있다.

정리해보면 다음과 같다.

- 고객은 여행 목록을 얻고자한다.
- suitable_trips 메세지를 구현하고 있는 객체가 있다.
- 적당한 여행지(suitable_trips)를 찾기 위해서는 적당한 자전거(suitable_bicycle)도 골라야한다.
- suitable_bicycle 메세지를 구현하고 있는 또 다른 객체가 있다.

![image](https://user-images.githubusercontent.com/53181778/85826347-6509d080-b7bf-11ea-9789-9e06e64b9824.png)

하지만, 어떤 측면에서는 나아졌지만, 다른 측면에서는 더 나빠졌다. Trip에서 추가적이 책임을 제거했지만, 이 책임을 단지 Customer로 바꾼 것이다. Customer클래스는 여행의 적합성을 평가하는 어플리케이션의 중심 로직을 담게 되어버렸다.

고객은 단지 주문판을 보고 음식을 주문해야하는데, 직접 요리를 하는 지경에 이른것이다.

#### 4.3.4. '어떻게' 해야하는지 알려주는 대신 '무엇을' 달라고 요구하기

**송신자가 원하는 것을 요구하는 메세지**와 **수신자가 어떻게 행동해야하는지 알려주는 메세지**의 차이를 아는 것은 매우 중요하다. 이것이 잘 정의된 퍼블릭 인터페이스를 가진, 재사용이 가능한 클래스를 만들기 위한 핵심이다.

what과 how 사이의 차이점을 설명하기 위해 상세한 예시가 필요하다. custom/trip 다자인 패턴은 조금 후 다시 검토를 하고, '여행, 자전거, 정비사'를 다루는 새 예시를 보자.

usecase : 여행이 시작되기 위해서는 모든 자전거가 잘 정비되어 있는지 확인해야한다.

Trip은 자전거를 어떻게 준비해야 하는지 알고 있을 수도 잇고, 정비사에게 이 작업들을 요청해야 할 수도 있다.

![image](https://user-images.githubusercontent.com/53181778/85827562-7bb12700-b7c1-11ea-8b45-98b00fb50871.png)

- Trip의 퍼블릭 인터페이스는 bicycles 메서드를 포함하고 있다.
- Mechanic의 퍼블릭 인터페이스는 celan_bicycle, pump_tire, lube_chain 그리고 check_brakes 메서드를 포함하고 있다.
- Trip은 celan_bicycle, pump_tire, lube_chain, check_brakes 메서드를 가지고 있는 객체를 필요로 한다.

이 디자인에서 Trip은 Mechanic이 하는 작업들을 모두 알고있다. 만약, 정비사가 준비과정에 수리도구 세트를 장착했는지 확인하는 메서드를 추가한다면, Trip에서도 이 메서드를 호출하도록 수정이 되어야 한다.

아래 그림은 Trip이 Mechanic에게 자전거를 준비하라고 요청하는 또 다른 방법을 보여준다. 자전거를 준비하기 위한 세부적인 구현사항은 Mechanic 내부에서 알고있다.

![image](https://user-images.githubusercontent.com/53181778/85827930-32ada280-b7c2-11ea-9940-b487a1449a84.png)

- Trip의 퍼블릭 인터페이스는 bicycles 메서드를 포함한다.
- Mechanic의 퍼블릭 인터페이스는 prepare_bicycle 메서드를 포함한다.
- Trip에게는 prepare_bicycle메서드를 가지고 있는 객체가 필요하다.

앞단계에서 Trip이 가지고 있던 책임을 Mechanic에게 넘겨주엇다. Trip은 자전거가 준비되어 있기를 바라고 Mechanic이 작업을 제대로 수행한다고 믿는다. 즉, `How`와 관련된 책임이 모두 Mechnic에게 넘어갔기 때문에 나중에 Mechanic을 보완하더라도 Trip은 언제나 원하는 결과를 얻을 수 있다.

자전거를 준비해야한다 = what, 그런데 어떻게 준비하냐(타이어 공기압, 브레이크 체크 등) = how

Trip과 Mechanic 사이의 관계가 how에서 what으로 바뀌면서 인터페이스의 양이 눈에 띄게 줄게 되었다. Mechanic은 여러 메서드를 노출하고 있지만, 위 그림에는 퍼블릭 인터페이스 속에 단 하나의 메서드 밖에 없다. Mechanic은 자신의 퍼블릭 인터페이스가 안정적이고 잘 변하지 않을 것이라고 약속했기 때문에 작은 퍼블릭 인터페이스를 갖는다는 것은 다른 객체가 의존할 수 있는 메서드의 수가 적다는 사실을 뜻한다.

하지만, Trip은 여전히 mechanic에 대해 너무 많이 알고잇다. Trip이 더 조금 알면서도 자신의 역할을 잘 수행할 수 있다면 코드는 보다 유여하고 유지보수하기 쉬워질 것이다.

#### 4.3.5. 맥락 의존성 찾기

Trip이 다른 객체에 대해 알고 있다는 사실이 Trip이 속한 맥락을 구성한다. Trip은 하나의 책임을 가지고 있지만, 특정한 맥락을 필요로 한다. Trip을 사용하려면 테스트를 위해서든 다른 용도에서든 **맥락이 먼저 설정**되어 있어야 한다.

여행을 준비하기 위해서는 언제나 자전거를 준비해야 하며 Trip은 **언제나 mechanic에게 prepare_bicycle메세지를 전송**해야 한다는 맥락을 가지고 있다. 하지만, prepare_bicycle 메서드에 반응하는 mechanic처럼 작동하는 객체가 없다면 Trip을 재사용 할 수 없다는 것이다. 이 것은 객체의 재사용성에 영향을 미치게 된다.

우리는 누구인지 모르는 객체와 협업하는 방법, 즉 의존성을 주입하는 방법을 알고있다. 이제, 새로운 문제는 Trip이 **Mechanic이 무엇을 하는지 모르는 채로** **Mechanic의 올바른 행동을 호출**하도록 만드는 부분이다. **Trip은 자신이 속한 맥락에서 독립적이면서도 mechanic과 협업**하고 싶다.

아래 그림에서 Trip은 Mechanic에게 자신이 원하는 것을 말하면서 자기 자신을 인자로 넘겼고, 바로 이어 Mechanic은 Trip을 호출해서 Trip으로부터 정비하기를 원하는 bicycle의 목록을 얻어 온다.

![image](https://user-images.githubusercontent.com/53181778/85828436-6210df00-b7c3-11ea-9053-14a8a2b0006c.png)

- Trip의 퍼블릭 인터페이스는 bicycles를 포함하고 있다.
- Mechanic의 퍼블릭 인터페이스는 prepare_trip을 포함하고 있고, 아마도 pre_pare_bicycle도 포함하고 있을 것이다.
- Trip은 prepare_trip 메서드에 반응할 수 있는 객체가 필요하다.
- Mechanic은 prepare_trip의 인자로 bicycles에 반응할 수 있는 객체가 필요하다.

이제 정비공이 어떻게 여행을 준비하는지에 대한 지식은 Mechanic 속에 고립되었고 Trip이 속한 맥락은 줄어들었다. Trip과 Mechanic 모두 수정하기도, 테스트하기도, 다시 사용하기도 쉬워졌다. Trip에게는 prepare_trip을 보낼 객체만 있으면 된다.

#### 4.3.6. 다른 객체를 믿기

클래스 사이에 관계는 "내가 원하는 것을 알고있고, 네가 주어진 역할을 제대로 하리라 믿고있다"는 것을 기반으로 객체지향을 설계하는 것이 좋다.

#### 4.3.7. 새로운 객체를 찾아내기 위해 메세지를 사용하기

What과 How의 차이도 알고, 맥락과 믿음이 왜 중요한지도 알고있다. 처음 보았던 Usecase에 대해서 다시 살펴보자.

- **여행객**은, **여행길을 선택**하기 위해서, **정해진 날짜**에, **자신에게 맞는 난이도**의, **자전거를 빌릴 수 있는**, **여행길 목록**을 보고싶어 한다.

4.3.3의 마지막 부분에서, Trip에서 너무 많은 책임을 지고있거, Bicycle로 자전거를 찾아야하는 책임을 옮겼었다. 하지만 Customer는 자신에게 어울리는 여행에 대해 너무 많이 알아야만 했고, 너무 많은 책임을 지게 된다. 이 것은 단일 책임 원칙을 위반하고 있고, Customer에게 너무 많은 맥락이 있다.

Customer가 suiatble_trips 메서드를 전송하는 일은 타당해 보인다. 문제는 송신자가 아닌 수신자에게 있다. 우리는 이 메서드를 구현할 객체를 아직 찾지 못한 것이다.

Customer, Trip, Bicycle이 교차하는 지점에서 어울리는 여행을 찾아 줄 객체가 필요하다. suitable_trips메서드는 이 객체의 퍼블릭 인터페이스의 한 부분을 이룰 것이다. 아래 그림에서 TripFinder라는 새로운 클래스를 추가했다.

![image](https://user-images.githubusercontent.com/53181778/85836167-2e3cb600-b7d1-11ea-9622-18e51d70e1a3.png)

TripFinder는 여행을 여행객과 어울리게 만드는 것이 무엇인지 모두 알고있다. 내부적으로는 어떨지 몰라도 이 클래스는 안정적인 퍼블릭 인터페이스를 제공한다.

suitable_trips 메서드를 ReipFinder로 옮겼기 때문에 다른 객체들도 이 행동에 접근할 수 있게 되었다.이제 이 행동이 Customer로 부터 분리되어 나왔기 때문에 다른 객체도 독립적으로 suitable_trips를 사용할 수 있다.

#### 4.3.8. 메세지 기반 어플리케이션 만들기

우리의 관심을 객체에서 메세지로 옮기면서 퍼블릭 인터페이스를 기반으로 어플리케이션을 디자인하는데 집중할 수 있게 되었다.

### 4.4 자신의 인터페이스를 드러내는 코드 작성하기

우리의 디자인 능력과 훈련 정도는 인터페이스의 명료함을 통해 드러난다. 인터페이스를 만들 떄 염두해 두어야 하는 기본적인 윈칙들을 알아보자.

#### 4.4.1. 명시적인 인터페이스 만들기

다른 사람이 우리가 작성한 메스드를 실행할 때 우리는 어떤 메서드에 의존해도 괜찮은지 알려줄 의무가 있다. 새로운 클래스를 만들 때마다 우리는 그 클래스의 인터페이스를 선언한다. 퍼블릭 인터페이스의 메서드는 다음과 같아야 한다.

- 엄밀하고 명시적으로 규정되어 있어야 한다.
- 어떻게 보다는 어떤 것에 대해 말해야 한다. (HOW < WHAT)
- 예측할 수 있는 한도에서 바뀌지 않을 이름을 지어야 한다.
- 추가적인 인자를 해시로 받아라.

프라이빗 인터페이스도 의도를 가지고 명시적으로 만드는 것이 좋다. 테스트는 그 자체로 문서의 역할을 하기 때문에 이런 노력을 뒷받침해 줄 수 있다. 프라이빗 메서드의 테스트는 만들지 않거나, 꼭 만들어야 한다면 퍼블릭 메서드 테스트와는 따로 분리하는 것이 좋다. 다른 프로그래머가 테스트를 보고 프라이빗 메서드에 의존하지 않도록 해야한다.

루비에서는 이와 관려해서 public, protected, private 키워드를 제공한다. 이 키워드들을 통해 메**서드가 안정적인지 아닌지 알려줄 수 있다**. 그리고 **메서드들이 얼마나 노출되는지 결정**한다. 메스드의 안정성을 알려주는 일과 다른 객체가 해당 메서드를 어떻게 사용할지를 관리하는 일은 완전히 다른일이다.

**Public, Protected, Private**

>  private 키워드 : 가장 불안정하고 눈에 띄지 않는 종류의 메서드를 나타낸다. 프라이빗 메서드는 수신자가 생략되어 있을 경우에만 호출할 수 있다. 반대로 말하면 수신자가 명시적으로 정해져 있다면 호출할 수 없다.
>
> - Trip클래스 내부에서 private인 fun_factor 메서드가 있다면, 클래스 내부에서 self.fun_factor나 클래스 외부에서 a_trip.fun_factor라고 메세지를 전송할 수 없다. 반면, Trip클래스 또는 Trip클래스의 자식클래스 인스턴스는 fun_factor라고 메서드를 전송할 수 있으며, 수신자는 없지만, self가 생략된 형태로 메서드를 전송할 수 있다.
>
> protected 키워드 : **불안정한 메서드**를 나타낸다. 하지만 그 노출 정도에서 private 키워드와 차이를 보인다. protected 메서드는 **수신자가 self이거나 같은 클래스의 인스턴스 또는 self의 자식 클래스의 인스턴스** 일 경우에 한해서 명시적인 수신자를 지정할 수 있다.
>
> - Trip의 fun_factor 메서드가 protected라면 언제나 self.fun_factor의 형태로 메세지를 전송하는 것이 좋다. 또는 a_trip.fun_factor라는 형태로 전송해도 좋다.

루비는 이 세가지 키워드뿐 아니라 private와 protected가 강제하는 노출 정도의 제약을 피해갈 수 있는 방법도 제공한다. 때문에 이 이슈는 좀 더 복잡해진다. 클래스의 사용자는 그 최초 선언이 어떠했는지와 상관없이 모든 메서드를 public으로 재정의 할 수 있다. 즉, 키워드가 만능은 아니라는 것이다.

키워드들을 사용하는 의미를 정리해보면,

- 오늘의 내가 미래의 프로그래머보다 더 나은 정보를 알고 있다고 믿는다.
- 내가 지금 불안정한 메서드라고 생각한 것을 미래의 프로그래머가 실수로 사용하지 못하게 만들어야 한다고 생각한다.

하지만 미래는 알 수 없다. 숙련된 프로그래머는 키워드를 사용하기보다는, 주석이나 메서드 이름에 차별을 주어 퍼블릭 인터페이스와 프라이빗 인터페이스를 관리한다. (예를 들면, 루비는 프라이빗 메서드에 `_`로 시작하는 이름을 지어준다.)

어떤 방식으로 처리하든 메서드의 안정성에 대한 정보를 전달해 주었다면 우리는 미래에 대한 의무를 다한 것이다.

#### 4.4.2. 다른 사람의 퍼블릭 인터페이스 존중하기

당연하다. 다른 클래스와 협업할 때는 그 클래스의 퍼블릭 인터페이스만 사용하도록 해야한다.

#### 4.4.3. 프라이빗 인터페이스에 의존할 때 주의하기

프라이빗 인터페이스에 의존할 수 밖에 없을 때는 3장에서 설명했던 의존성 격리(?)를 할 필요가 있다.어쩔수 없이 프라이빗으로 사용할 수 밖에 없더라도, 이 메서드를 어플리케이션 이곳저곳에서 사용하지 않도록 만들어야 한다.

#### 4.4.4. 맥락 최소화 시키기

퍼블릭 인터페이스를 구성할 떄는 다른 객체들과의 연결되어 있는 맥락을 최소화 할 수 있는 방향을 염두에 두어야 한다. How와 What을 구분하고, 송신자가 원하는 것을 클래스에 요청할 때 우리가 작성한 클래스의 구현과 작동방식에 대해 몰라도 되는 퍼블릭 메서드를 작성하자.

반대로 퍼블릭 인터페이스가 없거나 퍼블릭 인터페이스가 잘못 정의된 클래스가 시키는 대로 따르지 말자.

### 4.5. 데메테르 원칙

이제 책임(2장), 의존성(3장), 인터페이스(4장)에 대해 배웠고, 데메테르의 원칙에 대해 알아보자.

데메테르의 원칙(LoD)은 객체들의 결합을 낮추면서 코딩을 할 수 있도록 만들어주는 규칙이다. 낮은 결합도는 중요하지만, 디자인의 여러 면중 하나이다. 결합도를 낮추는 것과 상반되는 디자인 이슈가 있을 때 둘 사이에 잘 조율하는 능력도 중요하다. 데메테르 원칙을 어겨도 문제가 되지 않는 경우도 있지만, 어떤 경우는 퍼블릭 인터페이스를 잘 정의하지 못했다는 반증이 되기도한다.

#### 4.5.1. 데메테르 원칙의 정의

데메테르 원칙은 메서드가 메세지를 전송하지 말 것을 요구한다. 메세지를 전달받은 객체가 곧 바로 다른 타입의 객체에 메세지를 전달하는 것을 금지한다. 즉, 점을 하나만 사용하라는 의미이다.

만약 Trip의 depart메서드가 아래와 같은 코드를 포함하고 있다고 생각해보자.

​	customer.bicycle.wheel.tire

​	customer.bicycle.wheel.rotate

​	hash.keys.sort.join(', ')

각 메세지는 점을 여러개 포함하고 있다. 이 연쇄를 고장난 기차에 비유하곤 한다.

#### 4.5.2. 위반의 결과

2창에서 투명성,적절성,사용가능성,모범성 (TRUE)를 제시했다. 위 3개의 메세지는 TRUE의 관점에서 봐도 부적절하다.

적절성 : wheel이 tire나 rotate를 변경한다면 depart도 변경되어야 한다. 불필요한 영향력

투명성 : tire나 rotate를 수정하면 depart가 오작동을 할 수 있다. Trip과 wheel은 멀리 떨어져 있고 서로 연관되어 보이지 않기 때문에 이 오작동은 예상하기 쉽지 않다.

사용성 : wheel과 tire를 가지고 있는 bicycle은 있지만, bicycle을 가지고 있는 customer는 없다면 Trip을 사용할 수 없다. Trip을 사용하려면 이런 맥락을 고려해야 하기에 사용하기 쉽지 않다.

모법성 : 비슷한 패턴의 메세지를 다른 프로그램에서도 계속 생산할 것이기 때문에 전혀 모범적이지 않다.

처음 두 개의 메세지 연쇄는 거의 같은 것이다. 둘 사이의 차이점은 전자가 먼 곳에 있는 어트리뷰트(tire)를 가져오고 후자는 행동(rotate)를 호출한다는 것이다. 어트리뷰트를 반환하는 메세지 연쇄에 데메테르의 원칙을 얼마나 강제할 수 있는가에 의견이 분분하다. 지금과 같은 상황에서는 개체들의 연쇄를 타고 어트리뷰트에 접근하는 것이 효율적일 수 있다. 데메테르의 원칙을 따르는 비용과 미래의 수정 비용을 저울질해 볼 수있다.

메세지 연쇄를 통해 접근한 어트리뷰트의 값을 변경하지 않는다는 전제 아래서 이런 접근은 괜찮다. 만약, depart가 custom.bicycle.wheel.trie의 결과를 변경하려는 의도를 가지고 메세지를 전송한다면 이건 단순히 어트리뷰트를 가져오는 것이 아니다. 이건 Wheel에 속해야 하는 행동을 구현하고 잇는 것이다. 이런경우 두 메세지가 같아진다. 중간에 여러 객체를 끼고 있는 메세지 연쇄를 통해 멀리있는 행동에 접근하고 있는 것이다. 이런 방식의 코딩은 치러야 할 대가가 크며, 데메테르의 원칙을 따라야한다.

세 번째 메세지 연쇄인 `hash.keys.sort.join(', ')`는 문제가 없다. 이 코드는 데메테르의 원칙을 위반하지 않는다. **코드가 몇개의 점을 가지고 있는지가 아니라, 중간에 낀 객체들의 타입을 체크하면서 코드를 평가하자.**

- hash.keys는 Enumerable을 반환함
- hash.keys.sort 역시  Enumerable을 반환함
-  hash.keys.sort.join은 String을 반환함

최종적으로 String의 Enumerable을 반환한다는 점을 생각하면 중간에 낀 모든 객체들은 같은 타입을 반환하고 있다. 데메테르의 원칙을 위반했다고 보기 어렵다. 이 코드에서는 점을 제거하면 오히려 유지보수의 비용은 늘어날 것이다.

데메테르의 원칙은 적용하기에 애매한 경우가 많다. 이 원칙은 완벽한 것이 아니며 단지 우리의 디자인을 돕기 위해 존재한다.

#### 4.5.3. 원칙 위반을 피하기

고장난 기차형태의 코드를 피하기 위한 방법 중 하나는 `위임`을 사용하는 방법이다. 객체지향 프로그래밍에서 메세지를 위임한다는 뜻은 메세지를 다른 객체에 넘긴다는 의미이다. 종종 Wrapper Method를 통해서 메세지 연쇄에 포함되어 있는 지식을 캡슐화 하거나 감춘다.

메세지를 위임하기 위한 방법은 여러가지 있다. 루비는 `delegate.rb`와 `forwardable.rb`를 가지고 있고 루비온레일스는 `delegate`메서드를 제공한다. 이들은 모두 self에게 전송된 메세지를 가로채서 다른 객체에게 쉽게 전달할 수 있게 해준다.

위임은 데메테르의 원칙을 위반했다는 표시를 지워버리기 때문에 데메테르의 원칙을 따르지만, 주의해서 사용해야 한다. 위임의 결과는 원칙을 문자 그대로 따르고 진짜 이유는 무시하고 있을 수 있다. 위임을 통해 코드의 강한 결합을 감추는 것은 단순히 감추는 것일 뿐 이지 결합을 낮추는 것이 아니다.

#### 4.5.4. 데메테르의 원칙 듣기

데메테르의 원칙이 하려는 말은 "위임을 많이 사용"하라는 것이 아니다. 메세지 연쇄는 잘 알고있는 객체의 퍼블릭 인터페이스에 익숙하기 때문에 멀리 있는 행동에 접근하기 위해 만들어 지곤한다.

depart는 어떻게 객체들을 타고가면 원하는 것에 도달할 수 있는지 알고있다. 결국 depart메서드는 객체들의 전반적인 구조와 강하게 결합되어 있다는 것이다.

가장 분명한 문제점은 메세지 연쇄의 한 부분을 변경하게되면 Trip도 변경해야하는 위험이 있다는 것이다. 더 심각한 문제는 이 객체들의 연쇄를 depart메서드에서 알고 있기 때문에, 객체들의 매우 구체적인 구현에 얽혀 있기 때문에 depart를 다른 맬락에서 전혀 사용할 수 없다.

Customer는 언제나 Bicycle을 가져야하고, Bicycle은 rotate할 줄 아는 Wheel을 가지고 있어야 한다. depart메서드가 customer로 부터 **어떤 것**을 원하는지 판단하면서 코드를 디자인 했다면 코드를 아래와 같이 바꿀 수 있을 것이다.

​	customer.ride

메세지 관점에서 보면 당연한 것이다. ride메서드는 세부적인 구현을 Trip으로부터 감추고 맥락과 의존성을 모두 줄여준다. 디자인이 눈에 띄게 좋아진다.

데메테르의 원칙을 위반했기 때문에 만들어지는 고장난 기차는 어딘가에 **퍼블릭 인터페이스가 없는 객체**가 있다고 말해준다. 데메테르의 원칙에 귀 기울인다는 것은 메세지 기반의 관점을 취한다는 것이고, 그렇게 한다면 새로운 메세지를 발견할 수 있게 되고 그 메세지가 퍼블릭 인터페이스가 된다. 더 나아가 이 퍼블릭 인터페이스를 정의할 새로운 발견할 수 있다.

반면, 도메인 객체의 족쇄를 벗어버리지 못하면 (클래스 관점으로 문제를 해결하려고 한다면) 도메인 객체들의 퍼블릭 인터페이스만을 이용해 기다란 메세지 연쇄 코드를 작성하게 될 것이다.

## 5. Reducing Costs with Duck Typing

객체지향 디자인의 목표는 코드의 수정 비용을 줄이는 것이다. 디자인의 핵심은 메세지이며, 잘 정의된 퍼블릭 인터페이스를 구축하는 것이 왜 중요한지 배웠다. 이 둘을 종합한 디자인 테크닉을 이용하여 더 좋은 효과를 낼 수 있다.

그 기술의 이름은 duck typing(오리 타입)이다. 오리 타입은 특정 클래스에 종속되지 않은 퍼블릭 인터페이스이다. 여러 클래스를 가로지르는 이러한 인터페이스는 **클래스에 대한 값비싼 의존**을 **메세지에 대한 부드로운 의존**으로 대치한다. 즉, 어플리케이션을 유연하게 만들어 준다.

오리 타입 객체는 객체의 클래스보다는 행동에 의해 규정된다. (오리 타입이라고 불리는 이유도 여기서 나왔다. 객체가 오리처럼 걷고, 꽥꽥된다면 이 객체는 오리가 맞다.)

### 5.1. 오리타입 이해하기

프로그래밍 언어들은 '타입'이라는 용어를 통해 변수의 내용물이 어떤 종류인지 묘사한다. 절차적 언어는 보통 데이터의 종류를 표시하기 위해 고정된 타입들을 제공한다. 최소한 문자열, 숫자, 배열을 저장하기 위한 타입을 제공한다. 변수의 종류 또는 타입을 알기 때문에 그 내용물들을 어떻게 다루어야 하는지 예측할 수 있다.

루비에서 객체들의 타입을 예상할 수 있는 이유는 객체들의 퍼블릭 인터페이스를 믿기 때문이다. 즉, 한 객체가 다른 객체의 타입을 알고 있다면 대상 객체가 반응할 수 있는 메세지를 알고 있는 것이다.

당연한 말이지만, Mechanic클래스의 인스턴스는 Mechnic의 퍼블릭 인터페이스를 전부 가지고 있다. Mechanic의 인스턴스를 사용하는 객체는 이 인스턴스 자체가 Mechanic인 것처럼 취급할 수 있다. 어떤 인터스턴스가 클래스의 퍼블릭 인터페이스를 표현하고 있다는 것은 인스턴스의 본질적인 특성이다.

그러나, 어떤 객체가 하나의 인터페이스에만 반응할 수 있다고 생각할 필요는 없다. 루비 객체는 서로 다른 여러개의 인터페이스를 구현할 수 있다.

객체의 타입은 객체를 사용하는 사람의 쓰임에 따라 달라질 수 있다. 객체를 사용하는 사람은 객체의 클래스가 무엇인지 신경쓸 필요가 없으며 신경을 써서도 안 된다. 클래스는 객체가 퍼블릭 인터페이스를 갖추기 위한 하나의 수단에 불과하다. 객체가 자신의 클래스를 통해 얻는 퍼블릭 인터페이스는 객체가 포함하는 여러개의 퍼블릭 인터페이스 중 하나일 수 있다.  어플리케이션은 특정 클래스에 종속되지 않은 퍼블릭 인터페이스를 정의할 수 있다. 이런 인터페이스는 여러 클래스들 사이를 관통한다. 객체를 사용하는 사람은 모든 객체가 자신이 구현하고 있는 어떤 인터페이스 또는 모든 인터페이스에 맞춰 행동할거라 믿어도 된다. 중요한 것은 객체가 무엇인가 보다 어떻게 행동하는가 이다.

모든 상황에서 모든 객체가 예상한대로 움직인다고 믿을 수 있다면, 디자인은 무한한 가능성을 가지고 있는 것이다. 하지만, 반대로 난해한 혼란을 가중시킬 수 있다.

이러한 유연성을 현명하게 사용하기 위해서, 클래스를 가로지르는 타입(acroos-class type)을 알아야 한다. 클래스를 가로지르는 타입, 즉 오리 타입은 명시적이고 잘 정리된 계약서와 같은 퍼블릭 인터페이스를 가지고 있어야 한다.

#### 5.1.1. 오리 타입 무시하기

아래 코드에서 Trip의 prepare메서드는 자신이 인자로 받은 mechanic객체에 prepare_bicycles 메세지를 전송한다. 여기서, Mechanic클래스를 참조하는 객체가 없다는 점에 주목하자. 인자의 이름은 mechanic이지만, 사실은 Mechanic의 인스턴스가 아니더라도 인자로 받을 수 있다.

```ruby
class Trip
    attr_reader :bicycles, :customers, :vehicle

    # this 'mechanic' argument could be of any class
    def prepare(mechanic)
        mechanic.prepare_bicycles(bicycles)
    end

    # ...
end

# if you happen to pass an instance of *this* class,
# it works
class Mechanic
    def prepare_bicycles(bicycles)
        bicycles.each {|bicycle| prepare_bicycle(bicycle)}
    end

    def prepare_bicycle(bicycle)
        #...
    end
end
```

아래 그림은 위 코드와 상응하는 다이어 그램이다.

![image](https://user-images.githubusercontent.com/53181778/85971958-907ffb80-ba09-11ea-9ab1-7bbfc90565ce.png)

preapre 메서드 자체는 Mechanic 클래스에 의존하고 있진 않다. 하지만, prepare_bicycles라는 메서드에 반응할 수 잇는 객체를 받아야 한다는 것에 의존하고 있다. 이 의존성은 쉽게 무시될 수 있지만, 의존성은 분명히 존재한다. Trip의 prepare메서드는 여행준비를 담당하는 객체를 인자로 받았다고 확신하고 있다.

#### 5.1.2. 문제를 조합하기

4장에서 보았던 요구사항이 변경되었다고 생각해보자. 여행 준비에 정비공 이외에 여행 보조인과 운전사도 필요해졌다.

TripCoordinator와 Driver클래스를 만들고 각각에게 어울리는 책임을 지워준다. 그리고 Trip의 prepare 메서드가 인자로 넘어온 객체에게 알맞은 행동을 호출하도록 수정한다.

아래 코드는 이런 수정이 반영된 결과이다. 새로 만든 TripCoordinator와 Driver 클래스는 간단하고 괜찮아 보인다. 하지만, Trip의 prepare 메서드는 문제가 있어 보인다. prepare메서드는 세 개의 서로 다른 클래스를 참조하고 있고 각 클래스가 구현하는 메서드의 이름을 정확히 알고 있다. 의존성이 높아졌다. 코드의 수정에 대한 비용이 상승한것이다.

```ruby
#Trip preparation becomes more complicated
class Trip
    attr_reader :bicycles, :customers, :vehicle

    def prepare(preparers)
        preparers.each {|preparer|
            case preparer
            when Mechanic
                preparer.prepare_bicycles(bicycles)
            when TripCoordinator
                preparer.buy_food(customers)
            when Driver
                preparer.gas_up(vehicle)
                preparer.fill_water_tank(vehicle)
            end
            }
    end
end

# when you introduce TripCoordinator and Driver
class TripCoordinator
    def buy_food(customers)
        # ...
    end
end

class Driver
    def gas_up(vehicle)
        #...
    end

    def fill_water_tank(vehicle)
        #...
    end
end
```

이러한 코드는 중요한 메세지를 파악하지 못했을 때 나온다. 클래스 기반 관점이 자연스럽게 반전한 모양새이다.

코드가 이런 형태로 발전하는 과정을 살펴보자.

1. mechanic이라는 인자를 받고, prepare_bicycles이라는 메세지를 보내는 메서드로 생각을 한다.
2. prepare의 인자에 새로운 객체가 들어오게 되고, prepar_bicycles를 이해하지 못한다면, 프로그래머는 해당 객체가 이해할 수 있는 메세지를 찾는다.
3. TripCoordinator와 Driver 클래스의 퍼블릭 인터페이스를 살펴보고 buy_food,  gas_up, fill_water_tank와 같은 메스드를 발견
4. 그에 맞게 prepare 메서드를 수정한다.가장 명확한 방법인 그 메세지를 그대로 전송해버린다.

4번의 과정에서 문제가 발생한다. 인자들은 모두 다른 클래스의 인스턴스이며 다른 메서드를 구현하고 있다. 즉, 인스턴스를 알아야 적절한 메서드로 매칭이 가능하다. 여기서 의존성이 폭발해버린다.

위 코드의 의존성

- prepare메서드는 다른 사람은 알 수 없는 특정한 클래스에 기대고 있다.

- 클래스의 명시적인 이름에 기대고 있다.
- 클래스가 이해하는 메세지의 이름이 무엇인지, 그리고 이 메세지와 함께 전송해야 하는 인자가 무엇인지도 알고 있다.

만약, 새로운 타입의 객체를 더 추가로 받게 된다면, when 절은 계속해서 추가될 것이며 새로운 메세지도 추가될 것이다. 즉, 이런 코딩 스타일이 계속해서 재생산된다.

위 코드를 시컨스 다이어그램으로 표현하면 아래와 같다. 이 시컨스 다이어그램은 딱 보아도 복잡해 보인다. 이 복장성은 경고이다.

![image](https://user-images.githubusercontent.com/53181778/85973709-a217d200-ba0e-11ea-9cbd-3e1e9186f66c.png)

#### 5.1.3. 오리 타입 찾기

위와 같은 의존성을 제거하기 위해서 Trip의 prepare 메서드는 하나의 목적을 갖고 있기 때문에 prepare의 인자 역시 이 목표를 이루기 위해 협업하는 객체라는 사실을 알아야 한다. 그 객체들이 각각 어떤일을 하는지는 중요하지 않다.

인자의 클래스가 무엇을 할줄 아는지에 대해 알고 있는 것이 오히려 방해가 된다. 우리는 **prepare가 무엇을 원하는지에 대해 집중**해야 한다.

prepare의 관점에서 생각하면 문제는 매우 명확해진다. 인자들은 여행 준비에 동참하러 온 것 뿐이다. 인자가 주어진 작업을 제대로 할 줄 안다고 prepare가 믿기만 하면 디자인은 훨씬 간단해 진다.

아래 다이어그램에서 prepare메서드는 인자의 클래스에게 아무것도 기대하지 않는다. 단지, 이 인자가 Preparer(여행을 준비하는 객체)라고 기대할 뿐이다.

![image](https://user-images.githubusercontent.com/53181778/85974495-90372e80-ba10-11ea-8c4e-f9e0bbb53dd9.png)

기존의 클래스로부터 자유로워 졌고, 오리 타입을 만들어 냈다. 다음 문제인 prepare메서드가 Preparer에게 어떤 메세지를 전송할지 생각하는 것이다.

![image](https://user-images.githubusercontent.com/53181778/85975041-fc666200-ba11-11ea-9410-c936a3f83974.png)

위 다이어 그램에서는 새로운 메세지가 추가되었다. Trip의 prepare메서드는 자신의 모든 인자가 Preparer이고 prepare_tirp을 이해할 수 있기를 바란다.

Preparer란 구체적으로 존재하지 않고, 추상적이다. 즉, 실존하고 있지않은 디자인에 의해 만들어진 허구에 불과하다.
prepare_trip을 구현하고 있는 객체가 곧 Preparer이다. 반대로 이해하면, Prepare와 협업하는 객체들이 Preparer의 퍼블릭 인터페이스를 구현하고 있다고 봐야한다. 이 추상화를 이해하면 코드를 수정하는 것은 쉽다. Mechanic, TripCoordinator, Driver는 모두 Preparer처럼 행동해야 한다. 즉, prepare_trip을 구현하고 있어야 한다.

아래 코드는 새로운 디자인을 적용한 코드이다.

```ruby
# Trip preparation becomes easier
class Trip
    attr_reader :bicycles, :customers, :vehicle

    def prepare(preparers)
        preparers.each {|preparer|
            preparer.prepare_trip(self)}
    end
end

# when every preparer is a Duck
# that responds to ‘prepare_trip’
class Mechanic
    def prepare_trip(trip)
        trip.bicycles.each {|bicycle|
            prepare_bicycle(bicycle)}
    end

    # ...
end

class TripCoordinator
    def prepare_trip(trip)
        buy_food(trip.customers)
    end

    # ...
end

class Driver
    def prepare_trip(trip)
        vehicle = trip.vehicle
        gas_up(vehicle)
        fill_water_tank(vehicle)
    end
    # ...
end
```

#### 5.1.4. 오리 타입의 중요성

새로운 코드에는 나름의 대칭성이 있다. 이 대칭은 제대로된 디자인을 보여주는 대칭이다. 오리 타입으로 얻을 수 있는 이점은 이것 외에도 또 있다.

처음 코드에서 prepare 메서드는 구체적인 클래스에 의존했다면 마지막 코드는 오리타입에 의존한다. 첫 코드에서는 구체적이기 때문에 이해하기는 쉽지만, 확장하기에는 위험하다. 마지막 오리 타입 코드는 추상적이지만, 손쉬운 확장성을 제공한다.

오리 타입을 찾았기 떄문에 기존 코드를 수정하지 않고도 어플리케이션에서 새로운 행동을 이끌어낼 수 있다.

오리 타입을 사용하면 코드는 추상적으로 되면서 숨겨진 클래스를 파악하는데 더 많은 노력이 들기도 한다.

Polymorphism

> 객체지향 디자인에서 폴리몰피즘이라는 개념은 자주사용되지만, 단어의 활용법은 그 뜻을 충분히 전달해주지 못한다.
>
> 객체지향 프로그래멩에서 사용하는 폴리몰피즘의 의미는 **같은 메세지에 반응할 수 있는 여려 객체의 능력**을 의미한다. 메세지의 송신자는 수신자의 클래스를 신경 쓸 필요가 없다. 수신자는 주어진 행동에 걸맞는 자신만의 행동을 제공한다. 즉, 하나의 메세지(poly)가 여러개의 형태(morphs)를 갖게 된다.
>
> 폴리몰피즘을 구현하기 위한 방법은 여러가지가 있다. 오리타입도 그중 하나이다. 상속이나 루비의 모듈을 이용하여 행동을 공유하는 방법도 있다.
>
> 폴리모픽 메서드는 암묵적인 합의를 중시한다. 송신자의 관점에서 보면 이들은 상호 대체적이고, 폴리모픽 메서드를 구현하고 있는 모든 객체는 서로가 서로를 대체할 수 있다. 송신자는 이러한 대체에 대해서는 알 필요도 없다.

### 5.2. 오리 타입에 의존하는 코드 작성하기

오리 타입을 사용하기 위해, 클래스를 가로지르는 인터페이스를 사용하면 좋은 지점을 발견하는 능력부터 갖추어야 한다. 오리 타입의 구현 자체는 어렵지 않다. 어려운 부분은 오리타입의 필요성을 인지하고 인터페이스를 추상화하는 부분이다.

#### 5.2.1. 숨겨진 오리파일 인지하기

코드 속에는 미처 파악하지 못한 오리 타입이 숨겨져 있는 경우가 종종 있다. 몇 가지 일반적인 코딩 패턴은 오리 타입이 숨겨져 있다는 사실을 알려준다.

아래와 같은 경우에 오리타입을 적용할 수 있다.

- 클래스의 종류에 따라 스위치되는 case 문
- kind_of? 와 is_a?
- responds_to?

3가지의 경우에 대해서 살펴보자.

1. **클래스에 따라 변경되는 case 문**

   오리 타입이 숨겨져 있다고 알려주는 가장 일반적이고 명확한 패턴이다. 즉, 객체의 클래스 이름에 따라 다르게 작동하는 case 구문이다.

   ```ruby
   class Trip
       attr_reader :bicycles, :customers, :vehicle
       def prepare(preparers)
           preparers.each {|preparer|
               case preparer
               when Mechanic
                   preparer.prepare_bicycles(bicycles)
               when TripCoordinator
                   preparer.buy_food(customers)
               when Driver
                   preparer.gas_up(vehicle)
                   preparer.fill_water_tank(vehicle)
               end
               }
       end
   end
   ```

   이 패턴은 각 객체가 무언가를 공유하고 있다는 사실을 알려준다. prepare가 인자로부터얻고자 하는 것은 무엇인지 스스로에게 물어보면 답을 찾을 수 있다. 이 질문에 대한 답변이 우리가 전송해야 하는 메세지를 알려준다. 그리고 이 메세지가 숨어 있는 오리 타입을 찾아내기 위한 출발점이 된다.

   여기서 prepare 메서드는 자신의 인자가 여행을 준비하기를 바라고 있다. 때문에 오리 타입 prepare의 퍼블릭 인터페이스는 prepare_type을 가져야한다.

2. **kind_of? 와 is_a?**

   객체의 클래스를 확인할 수 있는 방법은 여러가지가 있다. 위의 case 구문은 그중 하나이다. kind_of?와 is_a? 메세지 역시 클래스를 확인해준다. 위의 코드를 아래와 같이 바꿀 수 있다.

   ```ruby
   if preparer.kind_of?(Mechanic)
       preparer.prepare_bicycles(bicycle)
   elsif preparer.kind_of?(TripCoordinator)
       preparer.buy_food(customers)
   elsif preparer.kind_of?(Driver)
       preparer.gas_up(vehicle)
       preparer.fill_water_tank(vehicle)
   end
   ```

3. **responds_to?**

   오리 타입에 익숙하지 않은 프로그래머라면, 클래스 이름에 의존하지 말아야한다고 생각하면서, responds_to?를 사용하려 할 수 있다.

   ```ruby
   if preparer.responds_to?(:prepare_bicycles)
       preparer.prepare_bicycles(bicycle)
   elsif preparer.responds_to?(:buy_food)
       preparer.buy_food(customers)
   elsif preparer.responds_to?(:gas_up)
       preparer.gas_up(vehicle)
       preparer.fill_water_tank(vehicle)
   end
   ```

   의존성이 조금 줄어들기는 했지만, 여전히 클래스에 의존하고 있다. 클래스를 명시적으로 참조하지는 않았지만, 간접적으로 참조하고 있다.

#### 5.2.2. 오리 타입 신뢰하기

협업하는 객체에 대한 믿음을 가진다는 것은 협업 객체에 대해 많이 알 필요가 없다는 것이다.

case문이나, kind_of 등을 사용한다면, 아직 퍼블릭 인터페이스를 발굴해내지 못한 어떤 객체가 있다는 뜻이다. 이 객체가 구체적인 클래스가 아니라 오리타입이라는 사실은 전혀 중요하지 않다. 중요한것은 발굴하지 못한 인터페이스가 있다는 점이지, 인터페이스를 구현하고 있는 클래스가 아니다.

일단 오리 타입을 머릿속에 그려낼 수 있다면, 그 인터페이스를 정의하자. 이 인터페이스를 필요로 하는 곳에 인터페이스를 구현하고 인터페이스를 구현하고 있는 객체들이 제대로 행동하리라 믿어야 한다.

#### 5.2.3. 오리 타입 문서작성

가장 단순한 형태의 오리 타입은 퍼블릭 인터페이스에 대한 합의만으로 존재한다. 여러 클래스가 prepare_trip을 구현하고 있다. 덕분에 클래스를 Preparer처럼 취급할 수 있다.

하지만, 코드의 관점에서 Preparer 오리 타입은 가상의 것에 불과하다. 그렇기 때문에 코드 속에서 오리 타입을 잘 보여주기 위해 문서를 작성하는 것이 좋다. 다해히도, 좋은 테스트는 그 자체로 최고의 문서가 되기도 한다. 이 테스트에 대해서는 9장에서 살펴보자.

#### 5.2.4. 오리타입 사이에서 코드 공유하기

Preparer 오리 타입은 모두 자신의 클래스에 필요한 행동만 구현하고 있다. Mechanic, Driver, TripCoordinator 모두 각자의 prepare_trip을 구현하고 있다. 오리 타입이 공유하고 있는 것은 이 메서드 시그니처 뿐이다. 인터페이스만을 공유하지, 그 세부 구현은 공유하지 않는다.

하지만, 종종 오리타입을 사용하다 보면 오리 타입 클래스끼리는 종종 같은 행동을 공유하는 경우가 존재한다. 코드를 공유하는 오리 타입을 작성하는 방법은 7장에서 다룬다.

#### 5.2.5. 현명하게 오리타입 선택하기

아래 코드는 rails에서 가져온 코드이다. (active_record/relations/finder_methods.rb)

입력 값을 어떻게 처리해야 할지 결정하기 위해 클래스를 확인하고 있다. 지금까지의 내용과는 반대되는 방식이다.

첫 번째 메서드는 인자의 클래스에 기반해서 어떻게 행동해야 할지 결정하고 있다.

수신된 객체의 클래스를 확인하고 이 결과에 따라 어떤 메세지를 전송할지 결정하는 방식이다.

```ruby
# A convenience wrapper for <tt>find(:first, *args)</tt>.
# You can pass in all the same arguments to this
# method as you can to <tt>find(:first)</tt>.
def first(*args)
    if args.any?
        if args.first.kind_of?(Integer) ||
                (loaded? && !args.first.kind_of?(Hash))
            to_a.first(*args)
        else
            apply_finder_options(args.first).first
        end
    else
        find_first
    end
end
```

이 코드와 이전 코드의 차이점은 코드가 확인하고 있는 클래스의 안정성이다. 이 예시에서는 루비의 코어 클래스인 Integer와 Hash에 의존하고 있기 떄문에 수정될 가능성이 매우 낮다. 이 코드에 오리타입이 숨겨져 있을 수 있지만, 이 오리 타입을 찾아 구현한다고 해서 어플리케이션의 유지보수 비용을 줄여주지는 않을 것이다.

여기서 알 수 있듯이 오리타입을 만들지 말지는 프로그래머에게 달려있는 문제이다. 이 코드에서 오리타입을 구현하려면 기본 클래스를 수정해야 하는데, 기본 클래스를 수정하는 방법을 몽키패치라 한다. 몽키패치는 루비의 멋진 기능 중 하나이지만, 어설프게 건드렸다가는 큰 위험이 따른다.

### 5.3. 오리 타입의 무서움을 정복하기

동적 타입과 정적 타입을 다룰 시간이 왔다. 정적언어와 오리 타입간의 관계에 대해서 다루어 보자.

#### 5.3.1. 정적 타입으로 오리 타입 거부하기

타입을 변수 내용물의 카테고리라고 정의해보자. 프로그래밍 언어는 정적 타입이거나 동적 타입언어다. 대부분의 정적 타입 언어는 변수와 메서드 파라미터의 타입을 명시적으로 선언할 것을 요구한다. 동적 타입 언어에서는 이런 선언을 생략할 수 있다. 별도의 선언 없이도 어떤 변수에든 아무 값이나 넣을 수 있고 어떤 메서드에든 아무 인자나 넘길 수 있다.

누군가는 동적 타입을 사용하는데 불편함을 느낀다. 이는 동적 언어를 사용해본 경험이 부족하기 때문이다. 다른 일부는 정적 타입이 보다 안정적이라고 믿기 때문에 불편해한다.

동적 언어를 두렵게 느끼는 프로그래머들은 객체의 클래스를 확인하는 습관이 있다. 이런 과정이 동적 언어의 힘을 반감시키며 오리 타입을 사용할 수 없도록 만든다.

프로그래머가 인자의 클래스를 알고 있어야만 제대로 작동하는 메서드, 이런 메서드는 새로운 클래스가 등장했을 때 타입 에러를 발생시키게 된다. 정적 타입 언어를 밎는 프로그래머들은 이 실패가 타입을 확인해야 하는 이유라고 믿는다. 타입 확인을 추가하면 할수록 코드는 점점 덜 유연해지고 점점 더 클래스에 의존하게 된다. 그렇기 때문에 새로운 의존성과 타입 실패의 악순환에 빠져들게 된다. 이 문제에 대한 해결책은 모든 타입 확인을 지워버리는 것이라는 사실을 잘 믿지 못한다.

오리 타입은 이런 함정에서 빠져나올 수 있는 방법을 제시한다. 오리 타입이 클래스에 대한 의존성을 제거하면 타입 실패 역시 제거가 된다. 오리 타입은 코드가 안정적으로 의존할 수 있는 추상화를 드러내준다.

#### 5.3.2. 정적 타입 vs 동적 타입

동적 타입과 정적 타입을 비교해 보자.

동적 타입과 정적 타입은 모두 약속하는 바가 존재하며 나름의 이점과 단점을 가지고 있다.

**정적 타입 지지자들이 말하는 정적 타입 언어의 장점 :**

- 컴파일 시점에 컴파일러가 타입 에러를 잡아준다.
- 눈에 보이는 타입 정보가 문서의 역할을 한다.
- 컴파일된 코드는 빠르게 동작할 수 있도록 최적화 되어 있다.

이런 이점들은 각각에 상응하는 가정을 받아들일 경우에만 의미가 있다.

- 컴파일러가 타입을 확인하지 않으면 런타임 타입 에러가 발생할 것 이다.
- 프로그래머는 전체 맥락에서 객체의 타입을 추측할 수 없고, 코드를 이해하지 못할 것이다.
- 이러한 최적화를 거치지 않으면 어플리케이션이 너무 느릴 것이다.

**동적 타입 지지자들이 말하는 동적 타입 언어의 장점 :**

- 코드가 해석(interpreted)되면 동적으로 로드(load)될 수 있다. compile/make 과정을 거칠 필요가 없다.
- 소스 코드에 명시적인 타입 정보를 포함할 필요가 없다.
- 메타프로그래밍이 더 쉬워진다.

다음과 같은 가정을 받아들인다면 이런 이점은 더 강화된다.

- compile/make 과정이 없으면 전체 어플리케이션 개발이 보다 빠르게 진행된다.
- 타입을 선언하는 코드가 없으면 프로그래머가 코드를 이해하기 쉽다. 맥락 속에서 객체의 타입을 추측할 수 있다.
- 메타프로그래밍은 프로그래밍 언어의 바람직한 기능이다.

#### 5.3.3. 동적 타입 언어 받아들이기

특정 어플리케이션의 경우, 최적화된 정적 타입 코드가 동적 타입 구현보다 훨씬 나은 결과를 내린다는 사실은 의심할 여지가 없다. 동적 타입 어플리케이션이 충분한 성능을 낼 수 있을 만큼 최적화 되지 않는다면, 정적 타입만이 대안이된다.

타입 선언이 문서의 의미를 갖는다는 주장은 좀 더 주관적이다. 누군가에게는 거추장 스럽고 누군가에게는 혼란을 줄여준다.

메타프로그래밍(코드를 작성하는 코드 짜기)에 대해서는 프로그래머마다 확고한 입장을 가지고 있다. 그리고 개개인의 과거 경험이 메타프로그래밍에 대한 선호를 가른다. 간단한 코드 한 조각으로 커다란 문제를 해결한 경험이 있는 사람이면 평생토록 메타프로그램 지지자가 된다. 반면, 불명확하고 불필요한 메타프로그래밍 코드를 디버깅했던 경험이 있는 사람은 메타프로그램을 싫어할 것이다.

메타프로그래밍을 쉽게 할 수 있다는 점은 동적 타입이 왜 좋은지에 대한 근거가 된다.

남아 있는 두개의 이점은 정적 타입이 컴파일 할 때 타입을 확인한다는 것과 동적 타입은 compile/make 과정을 거치지 않는다는 점이다. 정적 타입 지지자들은 실행시점에 예기치 않은 타입에러를 방지하는 것이 필요할 뿐 아니라, 그 가치는 컴파일러를 제거하면서 얻을 수 있는 프로그래밍 효율을 훨씬 능가한다고 말하고 아래의 내용을 주장한다.

- 컴파일러는 의도치 않은 타입 에러를 확실히 잡아준다.
- 컴파일러가 없다면 타입에러는 분명 발생한다.

하지만, 동적 타입은 "컴파일러는 타입 에러를 방지해 줄 수도 없고, 방지해 주지도 않는다"라고 말한다.

컴파일러는 의도치 않은 타입 에러로 부터 우리를 구해주지 못한다. 변수의 타입 변형을 지원하는 모든 언어는 타입 에러의 위험에 노출되어 있다. 컴파일에서는 타입에러가 발생하지 않아도 런타임에서는 발생할 수 있다는 것이다.

더 나아가, 실제 개발 현장에서 컴파일러가 방지해 줄 수 있는 런타임 타입 에러는 거의 발생하지 않는다.

동적 타입은 컴파일 순간의 타입 확인과 상당한 수준의 개발 효율을 맞바꿀 수 있게 해준다. 오리 타입은 정적 타입 스타일의 코드에 의해서 만들어지게 된다. 오리 타입을 사용하기 위해서는 동적 타입을 받아들여야만 한다.

## 6. Acquiring Behavior Through Inheritance

지금까지는 최소한의 맥락을 가지며, 인터페이스가 분명하고, 재사용 가능한 의존성이 주입된 객체들을 만드는 법에 대해서 알아보았다.

객체지향 언어에서 코드를 공유할 수 있는 방법을 제공하는데, 바로 `상속`이라는 개념이다.

### 6.1. 고전적인 상속 이해하기

기본적인 상속의 개념은 '자동화된 메세지 전달 시스템'이다. 특정 객체가 이해할 수 없는 메세지를 전달 받았을 경우, 상속 시스템을 통해 메세지를 다른 객체에게 전달한다. 명시적으로 메세지를 위임하는 코드를 작성하지 않아도 두 객체 사이의 상속관계를 정의하면 자동으로 메세지를 전달하게 된다.

고전적인 상속 관계는 하위클래스를 만드는 것을 통해 정의된다. 메세지는 하위 클래스에서 상위클래스로 전달되며, 클래스의 위계관계가 공유되는 코드를 정의한다.

고전적인 상속이라는 의미가 낡은 방식의 상속을 의미하는 것이 아니다. 단지, 다른 방식의 상속 시스템과 구분하기 위해 이 책에서 사용하는 개념이다. 예를 들면, 자바스크립트는 프로토 상속을 가지고 있고, 루비는 7장에서 다루게 될 모듈을 통한 상속을 한다.

### 6.2. 상속을 사용하는 곳을 인지하기

상속은 어디에 필요할까? 여행회사에서 로드 바이크를 빌려준다고 생각해보자. 로드 바이크를 정비하기 위한 부품들을 정비공들이 가지고 다닌다. 자전거의 종류에 따라 부품을 추가로 가지고 다닐 수 있다.

#### 6.2.1. 구체적인 클래스에서 시작하기

아래 코드와 같이 Bicycle 클래스가 있으며 모든 로드 자전거는 이 클래스의 인스턴스이다.

자전거의 크기, 핸들바 테이프 색상, 타이어 크기, 체인 종류를 알아야 하며, 타이어와 체인은 꼭 필요한 부품이기 때문에 언제나 여분을 챙겨두어야 한다. 핸들바 테이프도 중요하기 떄문에 꼭 필요한 제품이다.

```ruby
class Bicycle
    attr_reader :size, :tape_color
    def initialize(args)
        @size = args[:size]
        @tape_color = args[:tape_color]
    end
    # every bike has the same defaults for
    # tire and chain size
    def spares
        {   chain: '10-speed',
            tire_size: '23',
            tape_color: tape_color  }
    end

    # Many other methods...
end

bike = Bicycle.new(
    size: 'M',
    tape_color: 'red' )

bike.size # -> 'M'
bike.spares
# -> {:tire_size => "23",
# :chain => "10-speed",
# :tape_color => "red"}
```

Bicycle 인스턴스는 spares, size, tape_color 메세지를 이해할 수 있고, mechanic은 각 Bicycles에게 어떤 예비 부품이 필요한지 spares 메세지를 통해 물어 볼 수 있다. spares 메서드가 코드 안에 기본값을 적어 놓긴 했지만, 이 경우에는 충분히 괜찮다.

여행회사에서 로드 바이크 이외에 마운틴 바이크까지 제공하기로 했다. 로드바이크와 공유되는 특성도 있고 아닌 특성도 존재하게 된다. 로드바이크에는 핸들바 테이프가 필요했다면, 마운틴 바이크는 서스펜션이 필요하다.

#### 6.2.2. 여러 타입 임베딩하기

자전거에 대한 대부분의 행동을 이미 구현해놓은 구체 클래스가 있기 때문에, 클래스에 코드를 조금 추가해서 수정하고 싶은 유혹에 빠질 수 있다.

아래 코드에서는 Bicycle 클래스를 수정해서 spares메서드가 로드와 마운틴 바이크 모드에 적용될 수 있도록 수정한다. 그리고 style, front_shock 그리고 rear_shock 변수와 액세서가 추가되었다.

코드가 이상하다고 느껴져도 걱정말자. 단순히 안티패턴을 보여주기 위한 예시이다. 안티패턴이란 문제가 없어보이지만, 실제로는 문제가 되는 패턴으로 더 좋은 방식으로 작성될 수 있는 패턴이다.

```ruby
class Bicycle
    attr_reader :style, :size, :tape_color,
    :front_shock, :rear_shock

    def initialize(args)
        @style = args[:style]
        @size = args[:size]
        @tape_color = args[:tape_color]
        @front_shock = args[:front_shock]
        @rear_shock = args[:rear_shock]
    end

    # checking "style" starts down a slippery slope
    def spares
        if style == :road
            { chain: '10-speed',
                tire_size: '23', # milimeters
                tape_color: tape_color }
        else
            { chain: '10-speed',
                tire_size: '2.1', # inches
                rear_shock: rear_shock }
        end
    end
end

bike = Bicycle.new(
    style: :mountain,
    size: 'S',
    front_shock: 'Manitou',
    rear_shock: 'Fox')

bike.spares
# -> {:tire_size => "2.1",
# :chain => "10-speed",
# :rear_shock => 'Fox'}
```

이 코드는 style변수가 가지고 있는 값을 확인하고 어떤 예비 부품이 필요한지 결정한다. 이런 방식으로 코드를 구성하면 좋지 않다. 그리고, spares, size, teap_color, front_shock 등의 퍼블릭 인터페이스를 제공하지만, 특정 바이크에만 존재하는 부품의 이름을 따서 만든 메서드는 신뢰 할 수 없다.

이 클래스는 여러 책임을 가지며, 수정요청에 노출되기 쉬운 코드를 가지고 있고, 그 자체로는 재사용이 불가능하다.

if문을 통해 어떤 종류인지 확인하는 작업을 통해 오리타입과 유사함을 알 수 있다. 오리 타입은 if문이 난발된 패턴을 통해 숨겨진 오리 타입을 찾을 수 있었다. 이번 장에서는 숨겨진 하위 클래스를 찾으면 된다.

#### 6.2.3. 숨겨진 타입 찾기

spares메서드의 if문 style이라는 이름의 변수에 따라 선택적으로 작동한다. style은 Bicycle을 서로 다른 두 종류로 구분한다. 이 두 종류는 상당 부분을 공유하지만, 다른 부분도 존재한다. 이러한 유형을 상속을 통해서 해결할 수 있다.

즉, 밀접하게 연관된 타입들이 같은 행동을 공유하지만, 특정한 관점에서는 다른 경우에는 상속을 이용하면 좋다.

#### 6.2.4. 상속 선택하기

모든 객체는 **메세지를 직접 처리**하거나 **다른 객체가 처리할 수 있도록 메세지를 넘긴다**. 상속은 두 객체 사이의 관계를 정의하며, 첫 번째 객체가 이해할 수 없는 메세지를 수신하면 다음 객체에게 자동으로 메세지를 전달하거나 위임한다.

상속은 종종 가계도를 연상시키지만, 사실은 조금 다르다. 자식은 두명의 부모를 가질 수 있고, 이러한 것을 허용하는 언어를 `다중상속`을 지원하는 언어라고 말한다. 그리고 이런 언어들로 디자인을 한다면, 가끔 흥미로운 이슈가 발생한다. 여러 부모를 가진 자식 객체가 자신이 이해할 수 없는 메세지를 받았을 때 어떤 부모에게 메세지를 넘겨야할지 정해야하며, 누구에게 우선권이 있는지 판단하는 문제이다.

그렇기 때문에 여러 객체지향 언어들은 이러한 문제를 피하기 위해 `단일상속`을 지원한다. 자식 클래스는 하나의 상위 클래스만 가질 수 있다는 것이다.

고전적 상속을 통한 메세지 전달은 행동을 공유하는 클래스들 사이에서 이루어지는 작업이다. **오리 타입은 클래스들을 가로지르기 때문에 공통의 행동을 공유하는 고전적 상속을 사용하지 않는다**. 오리 타입은 루비의 `모듈`을 이용해서 코드를 공유한다.(다음장에서 다룬다.)

상속된 객체가 이해할 수 없는 메세지를 받으면 루비는 자동으로 메세지를 상위클래스의 연쇄속으로 전달한다. (superclass chain) 상위 클래스를 따라 올라가면서 이 메세지를 처리할 수 있는 클래스를 찾는다. 아래 그림은 nil?메세지에 반응하는 것을 보여준다.

![image](https://user-images.githubusercontent.com/53181778/86082150-0485d680-bad2-11ea-9dd3-f85afe062375.png)

nil은 NilClass의 인스턴스라는 점을 알고있다면, nil은 다른 객체들 처럼 그저 하나의 객체에 불과하다. 루비는 nil?메서드를 두 군데서 구현하고 있다. 하나는 Nil 클래스 안에 있고, 다른 하나는 Object 클래스 안에서 구현헀다. 만약, NilClass 객체에 nil?메세지를 보낸다면 true를 반환할 것이고, 다른 객체에게 nil?메세지를 보냈다면, nil?메세지를 찾기위해 상위 클래스로 거쳐 올라가게 되고 결국 Object에 있는 nil? 메서드에서 false를 리턴하게 될 것이다.

이해하지 못하는 메세지는 상위클래스로 전달한다는 것은 하위클래스에서 상위클래스의 모든 행동을 가지고 있다는 것을 의미한다.

#### 6.2.5. 상속 관계 그리기

인터페이스를 만들기 위해 UML을 사용했던것 처럼 클래스 사이의 관계도를 도식화하기 위해 UML 클래스 다이어 그램을 사용할 수 있다.

다이어그램의 박스는 클래스를 의미한다. 화살표의 방향은 상위클래스를 향한다.

![image](https://user-images.githubusercontent.com/53181778/86082579-13b95400-bad3-11ea-8ebe-a683d2db04e1.png)

### 6.3. 상속의 오용

상속의 잘못된 사용의 예를 살펴보자. 아래 코드는 MountainBike라는 하위클래스를 만든 코드이다. initialize와 spares를 구현하고 있다. 이 두 메서드는 이미 Bicycle이 이미 구현하고 있기 때문에 Override되고 있다.

```ruby
class MountainBike < Bicycle
    attr_reader :front_shock, :rear_shock

    def initialize(args)
        @front_shock = args[:front_shock]
        @rear_shock = args[:rear_shock]
        super(args)
    end

    def spares
        super.merge(rear_shock: rear_shock)
    end
end
```

메서드 안에 sper를 전송하면 이 메세지를 상위 클래스의 연쇄 속으로 넘겨주게 된다. 즉, initialize 메서드가 super를 전송하면 상위클래스의 initialize 메서드를 실행시킨다.

하지만, 이는 여러가지 문제를 가지고 있다. 아래 예시에서 MountaionBike의 size와 spares를 요청하면 어떻게 되는지 살펴보자.

```ruby
mountain_bike = MountainBike.new(
    size: 'S',
    front_shock: 'Manitou',
    rear_shock: 'Fox')

mountain_bike.size # -> 'S'

mountain_bike.spares
# -> {:tire_size => "23", <- wrong!
# :chain => "10-speed",
# :tape_color => nil, <- not applicable
# :front_shock => 'Manitou',
# :rear_shock => "Fox"}
```

size에 대해서는 S로 잘 알려준다. 하지만, tpae_color가 마치 필요한듯 알려주고, tire_size에 대해서는 잘못된 정보를 알려준다. 그 이유는 Bicycle이 상위클래스의 용도로 설계된 것이 아닌 구체 클래스이기 때문이다. 로드바이크의 특성을 디폴트로 가지고 있기 때문인 것이다.

Bicycle에는 Mountain 자전거에는 필요하지도 않은 속성까지 포함되어 있는 것이다. 즉, 상위클래스가 잘못 되었다.

### 6.4. 추상화 찾기

처음 로드 바이크만 있을 때는 Bicycle이라는 이름이 문제가 되지 않았지만, 마운틴 바이크가 추가되면서 문제가 되었다.

하위클래스는 상위클래스의 특수한 형태(specialization)이다. MountainBike클래스는 Bicycle의 모든 행동을 갖추고 있고, 추가적인 행동을 가지고 있어야 한다. Bicycle과 협업할 수 있는 모든 객체는 MountainBike에 대해 아무것도 모른채 MountainBike와 협업할 수 있어야한다.

상속이 제대로 작동하기 위해서는 두 가지가 언제나 충족되어야 한다.

1. 모델링하는 객체들이 명백하게 `일반 - 특수`의 관계를 가지고 있어야 한다.
2. 올바른 코딩 기술을 사용해야 한다.

현재, Bicycle에 RoadBike라는 특수의 특성이 섞어있다. 이것을 분리해야 한다.

#### 6.4.1. 추상화 상위 클래스 만들기

![image](https://user-images.githubusercontent.com/53181778/86085888-449d8700-badb-11ea-9104-8d89c0553fd9.png)

Bicycle은 공통된 행동만, RoadBike와 MountainBike는 특수한 행동만 추가할 것이다.

이제 Bicycle은 추상클래스가 되었다. 의존성 관리에서 추상성은 모든 구체적인 것으로부터 분리된 것이라고 정의했었다. 새로 만들어진 Bicycle 클래스는 자전거의 모든 것을 정의하고 있지 않고, 공유하는 부분만을 정의한다. 즉, Bicycle은 더 이상 new메세지들 수신하는 대상이 아니라는 것이다. Bicycle는 더이상 하나의 완전한 자전거를 재현하고 있지 않기 때문이다.

어떤 프로그래밍 언어들은 추상 클래스라는 것을 명시적으로 하기 위해 abstrat와 같은 키워드를 제공하여 컴파일러가 잘못된 인스턴스의 생성을 막아주는 경우도 있다.

추상 클래스는 상속하기 위해서 존재한다. 하나의 하위클래스만 갖는 추상화된 클래스를 만드는 것은 사용되지 않는다. 미래의 가능성만으로 상속을 사용하는 것은 좋지 않을 수 있다. 상속을 사용해야하는 시점이 왔을 때 사용하는 것이 현명하다. 하지만 두 종류의 자전거를 다뤄야 하는 상황이더라도 상속을 사용해야 하는 시점이 아닐수 있다. 상속 관계를 만드는 것은 높은 비용이 들기 때문이다.

아직 Bicycle 상속 관계를 만들지 않기로 했다면, 마운틴 바이크와 로드 바이크 클래스는 중복되는 코드를 많이 가지게 될 것이다. 상속 관계를 만들기로 했다면, 나중에 추가될 다른 자전거에 대한 정보가 부족해 추상화를 위한 충분한 정보를 가지고 있지 않을지도 모른다는 위험을 감수하는 것이다.

즉, 상속 관계를 만들지 말지를 결정하는 것은 '세 번째 종류의 자전거가 얼마나 빨리 필요하게 될지'그리고 '중복 코드를 관리하는 비용이 얼마나 큰지'사이에 달려있다.

하지만, 지금은 두 종류의 자전거 뿐이지만 상속관계를 만들 이유는 충분하기 때문에 만들어 보자.

```ruby
class Bicycle
    # This class is now empty.
    # All code has been moved to RoadBike.
end

class RoadBike < Bicycle
    # Now a subclass of Bicycle.
    # Contains all code from the old Bicycle class.
end

class MountainBike < Bicycle
    # Still a subclass of Bicycle (which is now empty).
    # Code has not changed.
end
```

Bicycle 클래스는 비었고, 기존에 있던 코드는 모드 RoadBike클래스로 옮겼다. MouctainBike는 이전에 짰던 코드와 같다. 마운틴 바이크가 의존하던 코드들은 이제 형제 클래스인 로드바이크로 모두 옮겨진 것이고, 마운틴 바이크는 로드바이크로 접근할 수 없다.

이런 재배치가 의미 있는 이유ㅜ는 하위클래스의 코드를 상위클래스로 올리는 것이 상위클래스의 코드를 하위클래스로 내리는 것보다 수월하기 때문이다. 아직은 이해가 잘 안되겠지만, 일련의 과정이다.

![image](https://user-images.githubusercontent.com/53181778/86086763-79aad900-badd-11ea-95a0-6deea4567d23.png)

RoadBike는 필요한 모든 행동을 가지고 있기 떄문에 제대로 작동하지만 MoutainBike는 완전히 고장이 난다. 아래의 코드와 같은 에러가 발생할 것이다.

```ruby
road_bike = RoadBike.new(
    size: 'M',
    tape_color: 'red' )

road_bike.size # => "M"

mountain_bike = MountainBike.new(
    size: 'S',
    front_shock: 'Manitou',
    rear_shock: 'Fox')

mountain_bike.size
# NoMethodError: undefined method 'size'
```

이런 에러가 발생하는 이유는 MountainBike와 Bicycle 모두에서 size와 관련된 메서드를 가지고 있지 않기 때문이다.

#### 6.4.2. 추상적인 행동을 상위로 올리기

size와 spares는 모든 자전거에 적용될 수 있는 메서드이다. 이런 행동들은 Bicycle의 퍼블릭 인터페이스에 속한다. 즉, RoadBike가 아닌 상위 클래스인 Bicycle에 위치해야한다. size가 가장 간단한 메서드이기 떄문에 이것부터 작업한는 것이 가장 자연스럽다.

아래 코드에서 볼 수 있듯, 메서드를 상위클래스로 올리는 작업은 3가지 과정이 필요하다. `1)attr_reader`, `2)initailize 메서드`를 RaodBike에서 Bicycle로 옮겨야하고, RoadBike의 initailize 메서드에서 `3)super`를 전송해야한다.

```ruby
class Bicycle
    attr_reader :size # <- promoted from RoadBike

    def initialize(args={})
        @size = args[:size] # <- promoted from RoadBike
    end
end

class RoadBike < Bicycle
    attr_reader :tape_color

    def initialize(args)
        @tape_color = args[:tape_color]
        super(args) # <- RoadBike now MUST send 'super'
    end
    # ...
end
```

sper를 쓰지 않으면, size가 초기화 되지않음에 유의하자.

이제는 MountainBike도 size 메세지에 반응할 수 있게 되었다.

```ruby
road_bike = RoadBike.new(
    size: 'M',
    tape_color: 'red' )

road_bike.size # -> ""M""

mountain_bike = MountainBike.new(
    size: 'S',
    front_shock: 'Manitou',
    rear_shock: 'Fox')

mountain_bike.size # -> 'S'
```

하지만, 의문이 있다. 다시 Bicycle로 size를 옮길것이라면 왜 Roadbike로 내렸다가 귀찮게 다시 올리는 걸까? 이것이 바로 `핵심 전략`이다.

상속을 구현하는데 어려움은 구체적인 것과 추상적인 것을 구분하지 못하는 것이다. 일단 구체 클래스였던 상위클래스의 모든 내용을 하위클래스로 옮겨 추상적인 부분만 상위클래스로 옮겨야, 상위클래스에 구체적인 요소를 남길 수 있는 실수를 줄여준다.

이런 전략은 실패했더라도 수정하기 쉬운 문제를 발생시킨다.추상화하지 않고 빼먹은 코드가 있더라도 다른 하위클래스가 해당 행동을 필요로 하기 때문에 문제가 바로 눈에 띈다.  만약, 반대방향으로 구체적인것만 하위로 내린다면, 간단한 실수로 인해 많은 비용이 들게 될 수 있다. 구체적인 것이기 남아 있어도, 구체적인 것이기 때문에 새로운 하위클래스에 적용하기 어렵고, 하위 클래스는 상속의 기본 법칙을 위반하게 된다.

#### 6.4.3. 구체적인 것에서 추상적인 것 분리하기

RoadBike와 MountainBike 모두 각자 spares 메서드를 구현하고 있다. RoadBike의 Spares는 원래 있던 구체적인 Bicycle 클래스에서 가져온 그대로 이며 잘 동작한다.

```ruby
class RoadBike < Bicycle
    # ...
    def spares
        { chain: '10-speed',
            tire_size: '23',
            tape_color: tape_color}
    end
end
```

MountainBike의 spares는 하위클래스를 만들려는 첫 번째 시도 후에 남겨진 것이다. (아래 코드) 하지만, 아직 Bicycle클래스에서 spare 메서드를 구현하고 있지 않기 때문에 에러가 발생한다.

```ruby
class MountainBike < Bicycle
    # ...
    def spares
        super.merge({rear_shock: rear_shock})
    end
end

mountain_bike.spares
# NoMethodError: super: no superclass method 'spares'
```

이 문제를 해결하기 위해 spares 메서드를 상위 클래스에 추가해야 한다. 하지만 단순히 코드를 끌어 올리는 것으로 해결되지 않는다. 메서드 내부에 추상적인 것과 구체적인 것이 섞여있기 때문이다. 그러한 부분들을 적절히 분리하자.

모든 자전거가 공유해야 하는 부분을 위로 올리는 것에 집중해보면, chain, tire_size가 있다. 이것들은 size와 같은 어트리뷰트에 해당하기 때문에 accessors와 setter를 통해 접근해야 한다.(하드코딩은 좋지 않다)

아래의 요구사항을 따를 수 있어야 한다.

- Bicycle 체인과 타이어 크기를 가진다.
- 모든 자전거는 체인의 기본값을 공유한다.
- 하위클래스는 자신만의 타이어 크기를 기본값으로 가진다.
- 하위클래스의 구체적인 인스턴스는 기본값을 무시하고 인스턴스 고유의 값을 설정할 수 있다.

아래 코드를 살펴보자.

```ruby
class Bicycle
    attr_reader :size, :chain, :tire_size

    def initialize(args={})
        @size = args[:size]
        @chain = args[:chain]
        @tire_size = args[:tire_size]
    end
    # ... .
end
```

로드바이크와 마운틴바이크는 Bicycle의 attr_Reader 정의를 상속받고 있고 둘 모두 initaize에서 super를 전송해야 한다. 이제 모든 자전거는 size, chain, tire_size가 무엇인지 이해하고 있고 자전거가 해당하는 하위클래스에 맞게 특수한 어트리뷰트도 사용할 수 있다. 즉, 요구사항중 첫 번째 요구사항과 마지막 요구사항이 해결되었다.

이제 두 번째, 세 번째 요구사항인 기본값과 관련된 내용을 살펴보자.

#### 6.4.4. 템플릿 메서드 패턴 사용하기

Bicycle의 initialize 메서드가 기본값을 가져오는 메세지를 전송하도록 할 것이다. 여기서는 두 개의 새로운 메세지 default_chain과 default_tire_size가 각 6,7,번 줄에 나온다.

기본값을 메서드로 감싸는것이 일반적으로는 좋은 습관이지만, 여기서는 등장한 새로운 메세지는 또 다른 의미를 가지고 있다. Bicycle이 메세지를 전송하는 궁극적인 목표는 하위클래스가 이 메서드를 재정의 하는 것을 통해 하위 클래스만의 특수한 행동을 추가할 수 있도록 하기 위함이다.

기본 구조를 상위클래스가 정의하고, 상위클래스에서 메세지를 전송하여 하위 클래스의 특수한 값을 얻는 기술을 `템플릿 메서드 패턴`이라고 부른다.

아래 코드에서 로드바이크와 마운틴 바이크는 default_tire_size를 구현하고 있지만, default_chain을 구현하고 있지는 않다. chain은 클래스와 무관하게 동일한 값을 가지기 때문에 Bicycle 클래스에 사용되었고, tire_size는 클래스마다 다른 크기를 가지기 때문에 각 클래스에 메서드를 사용한 것이다.

```ruby
class Bicycle
    attr_reader :size, :chain, :tire_size

    def initialize(args={})
        @size = args[:size]
        @chain = args[:chain] || default_chain
        @tire_size = args[:tire_size] || default_tire_size
    end

    def default_chain # <- common default
        '10-speed'
    end
end

class RoadBike < Bicycle
    # ...
    def default_tire_size # <- subclass default
        '23'
    end
end

class MountainBike < Bicycle
    # ...
    def default_tire_size # <- subclass default
        '2.1'
    end
end
```

제 Bicycle는 하위클래스에게 구조를 제공한다. 또는 공통의 알고리즘을 제공한다. 그리고 메세지 전송을 통해 하위클래스가 알고리즘에 개입할 수 있게 해준다. 이제 모든 자전거는 동일한 체인을 사용하며 다른 크기의 타이어를 가진다.

```ruby
road_bike = RoadBike.new(
    size: 'M',
    tape_color: 'red' )

road_bike.tire_size # => '23'
road_bike.chain # => "10-speed"

mountain_bike = MountainBike.new(
    size: 'S',
    front_shock: 'Manitou',
    rear_shock: 'Fox')

mountain_bike.tire_size # => '2.1'
road_bike.chain # => "10-speed"
```

하지만 여전히 코드에는 문제점이 남아있다.

#### 6.4.5. 모든 템플릿 메서드 구현하기

Bicycle의 initialize메서드는 default_tire_size 메서드를 전송하지만 스스로는 이 메서드를 구현하고 있지 않다. **이 생략이 나중에 문제가 될 수 있다**.  만약 새로운 자전거로 `리컴벤트`라는 자전거를 추가한다고 가정해 보자. 리컴벤트 자전거는 낮고 긴 자전거로, 누워서 타는 자전거이다.

RecumbentBike 하위클래스를 만들면서 default_tire_size메서드를 구현하지 않았다면 어떻게 될까?

```ruby
class RecumbentBike < Bicycle
    def default_chain
        '9-speed'
    end
end

bent = RecumbentBike.new
# NameError: undefined local variable or method
# 'default_tire_size'
```

위와 같은 에러가 발생할 것이다. 이러한 실수는 처음 디자인한 사람이 아닌 다른 프로그래머가 저지르게 되는 실수이다. cycle을 만든 사람이고 하위클래스가 갖춰야 하는 것을 잘 알고 있다면 문제가 되지 않지만, 그 사실을 모른다면 문제가 될 수 있다.

Bicycle 클래스의 구조는 하위 클래스가 default_tire_size를 구현하도록 만들어져 있다.

문제가 발생할 여지가 있는 것은 문제가 발생하기 전에 해결하는 것이 좋다. 템플릿 메서드 패턴을 사용하는 클래스는 자신이 전송하는 메서드를 직접 구현해 놓아야 한다. 아래와 같이 코드를 작성해 놓더라도, 직접 구현해 놓아야 한다.

```ruby
class Bicycle
    #...
    def default_tire_size
        raise NotImplementedError
    end
end
```

하위클래스가 이 메세지를 구현해야 한다고 명시적으로 말해주는 것은 구 자체로 훌륭한 문서가 된다.

이렇게 코드를 짜면, RecumbentBike 인스턴스를 만들 때 에러를 보여주게 됨으로 코드의 수정이 용이해진다.

```ruby
bent = RecumbentBike.new
# NotImplementedError: NotImplementedError
```

하지만, 더 명확한 정보를 주는 것이 좋다. 아래와 같이 추가적인 정보를 제공해 주도록 하자.

```ruby
class Bicycle
    #...
    def default_tire_size
        raise NotImplementedError,
        "This #{self.class} cannot respond to:"
    end
end
```

가 정보는 문제를 명확하게 드러내준다. 실행결과를 살펴보자.

```ruby
bent = RecumbentBike.new
# NotImplementedError:
# This RecumbentBike cannot respond to:
# 'default_tire_size'
```

이 에러메세지는 문제를 쉽게 해결 가능하도록 해준다. 이런식의 문서화는 반드시 꼭 필요하다.

### 6.5. 상위클래스와 하위클래스 사이의 커플링 관리하기

이제 Bicycle은 자전거의 추상적인 행동을 모두 포함하고 있다.

이제 상위클래스의 spares메서드만 구현하면 된다. 각 방법은 상위클래스와 하위클래스 사이의 결합(coupling)이 모두 다르다. 커플링을 관리하는 것은 중요하며, 강하게 결합된 클래스는 서로 들러붙어 있어 독립적으로 수정할 수 없게 되기도 한다.

spares를 구현하는 두 가지 방법에 대해서 알아보자.

#### 6.5.1. 커플링 이해하기

첫 번째 구현방식은 간단하지만, 클래스 간 강력한 결합을 만들어 낸다.

로드바이크는 아래와 같이  spares를 구현하고 있다.

```ruby
class RoadBike < Bicycle
    # ...
    def spares
        { chain: '10-speed',
            tire_size: '23',
            tape_color: tape_color}
    end
end
```

에 메서드에는 이것저것 다 섞여 있다.

하드코딩된 체인과 타이어 크기의 값을 변수와 메세지로 뽑아냈으며, 이 부분만을 Bicycle로 올려놓앗다. 자전거 체인과 타이어 크기와 관련된 코드는 이제 상위 클래스에 속한다.

마운틴 바이크는 아래와 같이 spares를 구현하고 있다.

```ruby
class MountainBike < Bicycle
    # ...
    def spares
        super.merge({rear_shock: rear_shock})
    end
end
```

이 메서드는 sper를 전송한다. 클래스는 상위 클래스가 spares를 구현하고 있다고 생각한다. 자신의 예비부품을 spuer의 결과값과 합친다. 여기서 super의 반환값을 해시라고 가정하고 있다.

아래와 같이 Bicycle의 spares를 구현하면 큰 문제없이 동작한다.

```ruby
class Bicycle
    #...
    def spares
        { tire_size: tire_size,
            chain: chain}
    end
end
```

이러한 요구사항을 모두 만족하는 코드를 작성하면 아래와 같은 코드가 나온다. 이 코드는 알아보기 쉬운 패턴을 가지고 있다. Bicycle이 전송하는 모든 템플릿 메서드는 Bicycle 내에서 구현되어 있고, 마운틴 바이크와 로드바이크 모두 initialize와 spares메서드에서 super를 전송한다.

```ruby
class Bicycle
    attr_reader :size, :chain, :tire_size

    def initialize(args={})
        @size = args[:size]
        @chain = args[:chain] || default_chain
        @tire_size = args[:tire_size] || default_tire_size
    end

    def spares
        { tire_size: tire_size,
            chain: chain}
    end

    def default_chain
        '10-speed'
    end

    def default_tire_size
        raise NotImplementedError
    end
end

class RoadBike < Bicycle
    attr_reader :tape_color

    def initialize(args)
        @tape_color = args[:tape_color]
        super(args)
    end

    def spares
        super.merge({ tape_color: tape_color})
    end

    def default_tire_size
        '23'
    end
end

class MountainBike < Bicycle
    attr_reader :front_shock, :rear_shock

    def initialize(args)
        @front_shock = args[:front_shock]
        @rear_shock = args[:rear_shock]
        super(args)
    end

    def spares
        super.merge({rear_shock: rear_shock})
    end

    def default_tire_size
        '2.1'
    end
end
```

이 클래스 상속 관계는 잘 동작하지만, 여전히 함정이 숨어있다. 마운틴바이크와 로드바이크 하위 클래스가 비슷한 패턴을 따르고 있다. 이 둘은 모두 자신에 대해아는 것(고육한 부품을 사용한다는 점)이 있으며, 상위 클래스에 대해 아는 것(spares 메서드가 해시를 반환한다는 점, initialize 메서드에 반응한다는 점)도 있다. 즉, 다른 클래스에 대해 알고 있다면 의존성이 만들어 진다. 의존성에 따라 객체가 강하게 결합된다. 이 의존성은 객체가 `super`를 전송하면서 만들어진다.

어떤 프로그래머가 하위 클래스를 만들면서 initialize메서드에서 super를 전송하는 것을 깜빡했다면, 아래와 같은 문제가 발생할 것이다.

```ruby
class RecumbentBike < Bicycle
    attr_reader :flag

    def initialize(args)
        @flag = args[:flag] # forgot to send ‘super’
    end

    def spares
        super.merge({flag: flag})
    end

    def default_chain
        '9-speed'
    end

    def default_tire_size
        '28'
    end
end

bent = RecumbentBike.new(flag: 'tall and orange')
bent.spares
# -> {:tire_size => nil, <- didn't get initialized
# :chain => nil,
# :flag => "tall and orange"}
```

리컴벤트 자전거가 초기화에서 super를 전송하지 않아, 부모클래스에서 제공하는 공통 초기화 과정을 빼먹게 된다. spare메서드에서도 이 문제는 동일하게 발생할 수 있다.

이러한 패턴은 알고리즘에 대한 지식을 하위클래스가 알아야 함을 의미하며, 하위클래스에게 명시적으로 super를 전송하라고 강제한다. 같은 지점에서 super를 전송하는 코드 중복이 발생하고, 미래의 프로그래머가 새로운 하위클래스를 만들면서 실수할 가능성을 높인다.

#### 6.5.2. Hook 메세지를 사용하여 하위클래스 커플링 제거하기

위의 문제는 하위클래스가 알고리즘을 알고 있고 super를 전송하는 방법대신,  **Hook 메세지를 사용**한다면 해결할 수 있다. 훅 메세지는 **정해진 메서드 구현**을 통해 **하위클래스가 정보를 제공**할 수 있도록 만들어준다.  이 방법을 사용하면 하위클래스는 알고리즘에 대해 몰라도 되고, 상위 클래스가 모든 권한을 가져가게 된다.

초기화 과정에서 훅 메세지를 사용하는 예시를 살펴보자. Bicycle의 initialize 메서드는 post_initialize 메서드를 전송한다. 그리고 이 메서드를 직접 구현하고, Bicycle은 아무것도 하지 않는 메서드를 만든다. RoadBike는 post_initailize 메서드를 재정의하는 것을 통해 자신만의 고유한 초기화 과정을 갖출 수 있다.

```ruby
class Bicycle

    def initialize(args={})
        @size = args[:size]
        @chain = args[:chain] || default_chain
        @tire_size = args[:tire_size] || default_tire_size

        post_initialize(args) # Bicycle both sends
    end

    def post_initialize(args) # and implements this
        nil
    end
    # ...
end

class RoadBike < Bicycle

    def post_initialize(args) # RoadBike can
        @tape_color = args[:tape_color] # optionally
    end # override it
    # ...
end
```

로드바이크의 initialize메서드 자체를 제거하여, 로드바이크 클래스에서 초기화 과정에는 관여하지 않게 되었다. 대신 추상적인 알고리즘에 자신만의 특수한 내용을 추가한다. post_initalize를 전송하는 것은 Bicycle의 책임이다.\

RoadBike는 여전히 자기 자신에게 필요한 초기호 ㅏ방식을 알고 있고, 그 역할을 담당하고 잇다. 하지만 초기화가 언제 이루어져야 하는지는 결정하지 않는다.

언제 전송할지를 상위클래스에서 관리한다는 것은 하위클래스를 변경하지 않고도 알고리즘을 수정할 수 있다는 뜻이다.

같은 기술을 spares 메서드에도 적용해보자. spares는 해시를 반환한다는 사실을 하위클래스가 알고 있을 필요 없이 훅을 구현해서 Bicycle에 관리 권한을 주면 클래스 사이의 결합도를 낮출 수 있다.

아래 예시에서는 local_spares를 전송하도록 수정한 것이다. Bicycle은 빈 해시를 반환하는 기본구현을 제공하고 있다. RoadBike는 이 훅을 이용하고 재정의해서 자기에게 필요한 local_spares를 반환한다. 로드 자전거에만 필요한 부품을 추가했다.

```ruby
class Bicycle
    # ...
    def spares
        { tire_size: tire_size,
            chain: chain}.merge(local_spares)
    end

    # hook for subclasses to override
    def local_spares
        {}
    end

end

class RoadBike < Bicycle
    # ...
    def local_spares
        {tape_color: tape_color}
    end

end
```

로드바이크의 local_spares 메서드는 기존의 spares 메서드를 대체하고 있다. 특수 부품 정보를 제공하는 내용은 그대로 남아있지만, 상위 클래스와의 결합은 느슨해졌다. 로드 바이크는 Bicycle이 spares 메서드를 구현한다는 사실을 알 필요가 없다.

이제 전체 코드를 수정해보면 아래와 같다.

```ruby
class Bicycle
    attr_reader :size, :chain, :tire_size

    def initialize(args={})
        @size = args[:size]
        @chain = args[:chain] || default_chain
        @tire_size = args[:tire_size] || default_tire_size
        post_initialize(args)
    end

    def spares
        { tire_size: tire_size,
            chain: chain}.merge(local_spares)
    end

    def default_tire_size
        raise NotImplementedError
    end

    # subclasses may override
    def post_initialize(args)
        nil
    end

    def local_spares
        {}
    end

    def default_chain
        '10-speed'
    end

end

class RoadBike < Bicycle
    attr_reader :tape_color

    def post_initialize(args)
        @tape_color = args[:tape_color]
    end

    def local_spares
        {tape_color: tape_color}
    end

    def default_tire_size
        '23'
    end
end

class MountainBike < Bicycle
    attr_reader :front_shock, :rear_shock

    def post_initialize(args)
        @front_shock = args[:front_shock]
        @rear_shock = args[:rear_shock]
    end

    def local_spares
        {rear_shock: rear_shock}
    end

    def default_tire_size
        '2.1'
    end
end
```

자식 클래스는 구체적인 구현만을 가지고 있기 때문에 훨씬 가독성이 좋다.

새로 추가되는 하위클래스는 템플릿 메서드만 구현하고 있으면 된다. 마지막 예시로 새로운 하위클래스를 추가하는 것이 얼마나 쉬운지 살펴보자.

```ruby
class RecumbentBike < Bicycle
    attr_reader :flag

    def post_initialize(args)
        @flag = args[:flag]
    end

    def local_spares
        {flag: flag}
    end

    def default_chain
        "9-speed"
    end

    def default_tire_size
        '28'
    end
end

bent = RecumbentBike.new(flag: 'tall and orange')
bent.spares
# -> {:tire_size => "28",
# :chain => "9-speed",
# :flag => "tall and orange"}
```

RecumbentBike의 코드는 뚜렷하고, 예측이 가능하며 쉽게 작성되었다.

## 7.
