# 18. 동적 계획법

>동적 계획법에 대해 알아보고 그 활용법에 대해서 학습한다.

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./README.md)

---

<!-- TOC -->

- [1. 수학적 귀납법](#1-수학적-귀납법)
- [2. 메모이제이션 (Memoizaion)](#2-메모이제이션-memoizaion)
- [3. 동적 계획 알고리즘](#3-동적-계획-알고리즘)
	- [3.1. 동적 계획법의 적용 요건](#31-동적-계획법의-적용-요건)
- [4. 동적 계획법 활용](#4-동적-계획법-활용)
	- [4.1. 동전 거르슴돈 문제](#41-동전-거르슴돈-문제)
	- [4.2. 이항 계수 문제](#42-이항-계수-문제)
	- [4.3. 0-1 배낭 문제](#43-0-1-배낭-문제)

<!-- /TOC -->

## 1.  수학적 귀납법

- 피보나치 수열의 점화식

  > F0 = 0, F1 = 1
  >
  > Fn = F<sub>n-1</sub> + F<sub>n-2</sub> for ( n ≥ 2)

  피보나치 수열을 재귀로 구현하면 다수의 중복 함수 호출이 발생

  => 수학적 귀납법을 이용하여 중복 호출을 계산

- 귀납법

> 1. 귀납 기본 : 주어진 등식이 n = 1 일 떄 성립함을 증명
>
> 2. 귀납 가정 :n일 때 성립한다고 가정
>
> 3. 귀납 단계 : n+1일 때 성립함을 증명
>
> =>모든 n에 대하여 성립

- 수학적 귀납법을 이용한 증명 과정
  - 귀납 기본 : n = 1 (혹은 n = 0)에 대해 등식이 성립함을 증명
  - 귀납 가정 : 임의의 n에 대해 등식이 성립한다고 가정
  - 귀납 단계 : 등식이 n+1에 대해서도 성립함을 증명

- 재귀 방법의 피보나치 수열의 함수 호출 횟수 계산

  T = 함수의 호출 횟수

  ```
  T(0) = 1;
  T(1) = 1;
  T(n) = T(n-1) + T(n-2) + 1 for(n >= 2)
  	> 2 x T(n-2) > 2^2 x T(n-4) > 2^3 x T(n-6)... > 2^(n/2) x T(0)
  	= 2^(n/2)
  ```

  즉, 재귀적 알고리즘으로 구성한 피보나치 수열의 재귀트리의 노드의 수 T(n)은 n>=2인 모든 n에 대하여 T(n) ＞2<sup>n/2</sup>

- 재귀 함수를 사용한 피보나치 수열의 함수 중복 호출

  - n번째 피보나치 수를 구하기 위해 알아야 할 값

    - fibo(0) ~ fibo(n-1)까지의 값

    - fibo()함수를 n번 호출하여 값을 알면 된다.

  - n번째 피보나치 수를 구하기 위해 재귀 호출로 작성된 fibo(n)함수 호출

    - fibo()함수 2<sup>n/2</sup>번 이상 호출

  즉, n번만 호출하면 구할 수 있지만, 재귀함수를 사용하면 2<sup>n/2</sup>번 이상 호출해야하므로, n이 커질수록 시간 복잡도도  2<sup>n</sup>에 비례하여 증가한다.

## 2. 메모이제이션 (Memoizaion)

- 컴퓨터 프로그램을 실행할 떄 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술

  - 동적 계획법을 적용하기 위해 사용되는 핵심 기술

- 피보나치 수를 구하는 알고리즘에서 입력 값 n에 대한 계산 결과를 저장하여 실행시간을 O(n)으로 줄일 수 있다.

  ```c
  memo[N] = {0, 1, 0, };

  fibo1(n)
  {
  	if(n >= 2&& memo[n] == 0)
  	{
  		memo[n] = fibo1(n - 1) + fibo1(n - 2);
  	}
      return memo[n];
  }
  ```

  - 하지만, 메모이제이션을 적용했다 하더라도, 추가 메모리 공간이 필요하고, 재귀호출이 사용되기 때문에 n값이 커질 수록 함수 호출에 따른 추가작업이 필요하여 실행속도가 저하되며, 스택 오버플로우가 발생할 수 있다.

    => 재귀호출을 사용하지 않는 알고리즘을 사용

## 3. 동적 계획 알고리즘

동적 계획법 : 작은 부분에서 큰 부분의 해들을 모두 구하여 최종적으로 원래 주어진 문제를 해결하는 설계 기법

- 최적화 문제 해결
  - 최대값 또는 최소값을 구하는 문제
  - 여러 개의 최적해 중 임의의 최적해 하나를 찾는 것
- 완전 검색을 좀더 효율적으로 하는 방법
- 재귀와 메모이제이션을 결합한 것
  - 재귀 : 문제를 재귀적으로 정의해서 해결하는 것
- 점화식을 찾으면 된다.
  - 점화식을 찾으려면 문제를 분석하여 재귀적으로 정의하고 수식 형태로 표현해야 함

### 3.1. 동적 계획법의 적용 요건

- 동적 계획법을 적용하기 위해서는 두가지 요건을 가지고 있을 때 적용할 수 있다.

  - 중복 부분문제 구조

    - 작은 문제를 먼저 해결하고 최적해를 구해 큰 문제를 해결한다.
    - 즉, 순확적으로 문제를 해결한다. 이때, 순환적인 관계의 명시적 표현에 점화식을 사용한다.
    - 문제의 순환적 성질로 이전에 계산된 작은 문제의 해가 더 큰 문제의 해를 구할 때 중복사용된다.(메모이제이션 사용)

  - 최적 부분 문제 구조

    - 주어진 문제가 최적화의 원칙을 만족해야만 적용이 가능하다.

      - 최적화의 원칙 : 어떤 문제에 대한 해가 최적일 때 그 해를 구성하는 작은 문제들의 해 역시 최적이어야 한다는 것

      - 최적화의 원칙이 적용되지 않는 예

        - 최장경로 문제

          ![image](https://user-images.githubusercontent.com/53181778/79090103-87c14700-7d83-11ea-891d-fb779732100d.png)

- 분할정복 vs 동적 계획법

  두 알고리즘은 부분문제의 해를 구해 더 큰 문제의 해를 구한다는 공통점이 있지만 다른 알고리즘이다.

  - 분할 정복 : 하향식 방법 (주어진 문제를 더 이상 나눌 수 없을 때까지 쪼갠다.)
    1. 주어진 문제를 부분 문제들로 분할
    2.  부분문제를 재귀적으로 해결, 필요 시 부분문제의 해를 결합
    3. 병합 정렬과 퀵 정렬은 작은 문제의 해가 큰 문제의 해에 중복해서 사용되지 않는다.

  - 동적 계획법 : 상향식 방법 (의존성에 위배되지 않게 작은 문제의 해를 구한다.)

    - 부분문제들이 더 작은 부분문제들의 해를 공유

    - 모든 부분문제를 한번만 계산하고 결과를 저장하여 필요 시 재사용

- 동적 계획법 적용

  1. 최적해 구조의 특성 파악

     - 문제를 더 작은 부분 문제로 나누어 본다.

  2. 최적해 값의 재귀적 정의

     - 부분 문제들의 최적해를 사용하여 더 큰 문제의 최적해 값 정의
     - 점화식 사용 가능

  3. 상향식 방법으로 최적해 값 계산

     - 의존성에 위배되지 않도록 가장 작은 부분 문제부터 해를 구한 뒤 테이블에 저장

     - 테이블에 저장되어 있는 부분 문제의 해를 이용하여 점차적으로 상위 부분 문제의 최적해를 구함

- 피보나치 수의 동적 계획법 적용 알고리즘

  ```c
  fibo_dp(n)
  {
  	f[0] = 0;
  	f[1] = 1;
      for(i = 2; i <= n; i++)
      {
          f[i] = f[i-1] + f[i-2];
      }
      return f[n];
  }
  ```

  반복문 사용으로 함수 호출이 발생하지 않음

## 4. 동적 계획법 활용

### 4.1. 동전 거르슴돈 문제

> 사용할 수 있는 동전 : 1원, 4원, 6원
>
> 거스름돈 8원에 대한 최소 동전 개수는?

- 최적해 : 2개 (4원, 4원)

- 그리디 방법 접근 : 3개 (6원, 1원, 1원) => 최적해 X

- 완전검색 + 백트래킹

  - 각 동전에 대해 재귀적으로 해결

    - 1원 동전 1개 + 7원에 대한 최적해
    - 4원 동전 1개 + 4원에 대한 최적해
    - 6원 동전 1개 + 2원에 대한 최적해

    => 3가지 해 중 최적해 선택

    ![image](https://user-images.githubusercontent.com/53181778/79091128-12577580-7d87-11ea-95ca-e6e22816f46e.png)

  - 이 방법은 중복이 많이 발생한다. 같은 색상의 노드들은 같은 동작을 한다.

- 동적계획법 (상향식)

  - 1원에 대한 최적해 -> 2원에 대한 최적해 -> ... 8원에 대한 최적해를 순차적으로 구함
  - 부분 문제들 사이의 의존성

  ![image](https://user-images.githubusercontent.com/53181778/79091813-b3473000-7d89-11ea-9627-b0aaee8d8923.png)

  - 알고리즘

  ```c
  //change : 거스름돈
  //coin[COINNUM] = {6, 4, 1} : 동전의 종류
  //momo[] : 부분해 저장
  coinChange(change)
  {
      memo[0] = 0;
      for(int N=1; N <= change; n++)
      {
          min = INF;
          for(int i = 1; i <= COINNUM - 1; i++)
          {
              if(N >= coin[i])
                  if(memo[N - coin[i]] < min)
                      min = memo[N - coin[i]];
          }
          memo[N] = min + 1;
      }
      return memo[change];
  }
  ```

  ![image](https://user-images.githubusercontent.com/53181778/79092411-c5c26900-7d8b-11ea-8140-5e2939bc79df.png)

### 4.2. 이항 계수 문제

![image](https://user-images.githubusercontent.com/53181778/79092465-f86c6180-7d8b-11ea-9672-0351ff669948.png)

- X<sup>k</sup>y<sup>n-k</sup>의 계수 =  <sub>n</sub>C<sub>k</sub>  : 이항계수

  ![image](https://user-images.githubusercontent.com/53181778/79092565-45503800-7d8c-11ea-8801-4afd4723715d.png)

- 파스칼의 삼각형

  ![image](https://user-images.githubusercontent.com/53181778/79092616-69ac1480-7d8c-11ea-9e82-683b5b4b1fd5.png)

- 재귀호출을 이용한 이항 계수의 계산

  입력 : 음수가 아닌 정수 n과 k (k<=n)

  ```c
  bino(n, k)
  {
      if(k == 0 || n == k)
          return 1;
      else
          return (bino(n-1, k-1) +bono(n-1, k));
  }
  ```

  - 중복 호출 다수 발생

- 메모이 제이션을 이용한 이항 계수 계산

  ```c
  //B[N][N] : 문제의 해를 저장하는 테이블, -1로 초기화
  bino(n, k)
  {
      if(k == 0 || n == k)
          return 1;
      if(B[n][r] != -1)
          return B[n][r];
      B[n][r] = bino(n-1, k-1) +bono(n-1, k);
  	return Bpn[n][r];
  }
  ```

- 동적계획법 활용(상향식)

  - 행 우선 탐색으로 진행

    아래 그림에서, (5,3)의 값을 구할 때, (4,4)의 값은 필요가 없다.

    - 행 값이 값보다 커지면 열값을 k까지 증가 시키면 된다.

    ![image](https://user-images.githubusercontent.com/53181778/79092902-59e10000-7d8d-11ea-8715-9a5a1a59a70a.png)

  ```c
  //B[N][N] : 문제의 해를 저장하는 테이블, -1로 초기화
  bino(n, k)
  {
      for(int i =0; i<=n; i++)
      {
          for(int j = 0; j<=minimum(i, k); j++)
          {
              if(j==0 || j==i)
                  B[i][j] = 1;
              else
                  B[i][j] = B[i][j] = B[i-1][j-1] + B[i-1][j];
          }
      }
  	return Bpn[n][k];
  }
  ```

### 4.3. 0-1 배낭 문제

배낭의 용량이 W이고 물건 n개가 있을 때, 각 물건의 크기와 가격이 주어졌을 때, 배낭에 담은 물건들의 가치의 합이 최대가 되도록 하는 문제

- 완전 검색

  - 모든 부분집합을 구해서, 총 무게가 W이상인 집합은 제외시키고, 나머지 집합에서 총 값이 가장 큰 집합을 선택

  - 예시

    ![image](https://user-images.githubusercontent.com/53181778/79183022-498f5a80-7e4b-11ea-82bd-d871931dc45f.png)

  - 상태 공간 트리

    ![image](https://user-images.githubusercontent.com/53181778/79183067-63c93880-7e4b-11ea-867a-774bc32eaa3e.png)

  - 알고리즘

    ```c
    //W:배낭의 무게, k:배낭에 넣을 물건, 방문하는 노드 높이
    //curValue : 현재까지 담은 물건의 총 가치, maxValue : 최대가지
    //NUM_OF_ITEM : 물건의 개수

    knapsack(W, k, curValue)
    {
        if(w >= 0)
        {
            if(k = NUM OF ITEM)
            {
                if(maxValue < curValue)
                    maxValue = curValue;
        		else
                {
                    knapsack(W-weight[k], k+1, curValue + value[k]);
                    Knapsack(W, k+1, curValue);
                }
            }
        }
    }
    ```

- 부분 문제 정의

  - n번째 물건의 가치 : Vn

  - case1 : n번째 물건 포함

    - 배낭의 남은 무게 : W-wn
    - 물건들의 집합 = 1, 2, ..., n-1

  - case2 : n번째 물건 미포함

    - 배낭의 남은 무게 : W
    - 물건들의 집합 = 1, 2, ..., n-1

  - 최적해 = max { case1의 최대 가치 + Vn, case 2의 최대 가치}

  - (vi, wi) = (물건 가치, 무게)

  - k\[i][w] = 물건 1~i 까지만 고려하고, 배남의 용량이 w일 때 최대 가치

    - `1<=i<=n`
    - `1<=w<=W`

  - 점화식

    ![image](https://user-images.githubusercontent.com/53181778/79183904-c02d5780-7e4d-11ea-800c-ae4d92f77ae3.png)

- 재귀와 메모이제이션 적용 알고리즘

  ```c
  //k[i][W]: 부분 문제의 해(최대가치)를 저장하기 위한 배열, -1로 초기화
  //i : 배낭에 넣을 물건
  //W : 배낭 무게

  knapsack(i, W)
  {
  	if(K[i][W] != -1)  //무게 W에 대한 최대 가치가 구해졌으면 값 반환
         return K[i][W];
      if(i ==0 || W == 0)  //i가 0이거나 W가 0이면 0 저장 후 반환
          return (K[i][W] = 0);
      else
      {
          case1 = 0; case2 = 0;
      	if(W>=weight[i])   //(남은)배낭의 무게가 i번째 무게보다 크거나 같은지 비교
       	   case1 = knapsack(i - 1, W-weight[i]) + value[i]; // 배낭에 담을 수 있다면 배낭 무게에서 i 번째 물건의 무게를 빼서 재귀호출하고 반환 값에서 i 번째 물건의 가치를 더해 case1에 저장
     		case2 = knapsack(i - 1, W); //배낭의 무게를 변경하지 않고 재귀 호출하고 반환된 값을 case2에 저장
      	K[i][W] = max(case1, case2);
      }
      return K[i][W];
  }
  ```

  - 함수 호출 트리

    ![image](https://user-images.githubusercontent.com/53181778/79184479-39797a00-7e4f-11ea-8145-cf00b775a3dc.png)

- 상향식 동적 계획법

  - 부분문제의 의존성

    ![image](https://user-images.githubusercontent.com/53181778/79186254-156c6780-7e54-11ea-8f2c-dc2015868eec.png)

    - 모든 문제에 대한 해를 구한다.
    - 행단위로 좌에서 우로 구하면 의존성에 위배되지 않음

  - 알고리즘

    ```c
    //k[i][W]: 부분 문제의 해(최대가치)를 저장하기 위한 배열, -1로 초기화
    //i : 배낭에 넣을 물건
    //W : 배낭 무게

    knapsack(i, W)
    {
    	for(int i = 0; i <= n; i++)
            K[i][0] = 0;
    	for(int w = 0; w <= W; w++)
            K[0][w] = 0;
        for(int i = 0; i <= n; i++)
        {
            for(int w = 0; w <= W; w++)
            {
                if(weight[i] > w)  //현재 배낭의 무게가 i번째 물건의무게보다 작은경우
                    K[i][w] = k[i - 1][w];
                else
                    K[i][w] = max(k[i - 1][w-wi] + vi, K[i-1][w]);
            }
        }
        return K[n][W];
    }
    ```

    ![image](https://user-images.githubusercontent.com/53181778/79186628-28336c00-7e55-11ea-8016-e87d34d34a13.png)



