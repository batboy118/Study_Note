# 00. 복잡도_Complexity

> 알고리즘의 성능의 척도가 되는 시간복잡도와 공간복잡도에 대해 정리했습니다.
>
> 참고 : [링크1](https://joshuajangblog.wordpress.com/2016/09/21/time_complexity_big_o_in_easy_explanation), [링크2](https://madplay.github.io/post/time-complexity-space-complexity)

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./)

---
<!-- TOC -->

- [1. 계산 모델](#1-계산-모델)
	- [1.1. 알고리즘이란?](#11-알고리즘이란)
	- [1.2. 계산 모델(model of computation) 이 규정하는 것](#12-계산-모델model-of-computation-이-규정하는-것)
	- [1.3. 임의 접근 머신 (Random Access Machine)](#13-임의-접근-머신-random-access-machine)
	- [1.4. 포인터 머신 (Pointer Machine)](#14-포인터-머신-pointer-machine)
- [2. 시간 복잡도](#2-시간-복잡도)
	- [2.1. 시간 복잡도란?](#21-시간-복잡도란)
	- [2.2. Big-O 표기법](#22-big-o-표기법)
	- [2.3. 시간복잡도 예시](#23-시간복잡도-예시)
	- [2.4. Big-O 표기법의 수학적 정의와 예시](#24-big-o-표기법의-수학적-정의와-예시)
- [3. 공간 복잡도](#3-공간-복잡도)
	- [3.1. 공간복잡도란?](#31-공간복잡도란)
	- [3.2. 공간 복잡도 예시](#32-공간-복잡도-예시)
- [4. 공간복잡도 VS 시간복잡도](#4-공간복잡도-vs-시간복잡도)

<!-- /TOC -->

## 1. 계산 모델

### 1.1. 알고리즘이란?

컴퓨터 프로그램의 수학적 추상화

문제 해결을 위한 계산 과정

![img](https://i.imgur.com/XP0gH8l.png)

### 1.2. 계산 모델(model of computation) 이 규정하는 것

- 알고리즘이 할 수 있는 연산
- 각 연산의 비용 (시간, 공간, …)
- 알고리즘의 비용 = 연산 비용의 합
  - 알고리즘의 시간 비용의 합 = 알고리즘의 실행 시간

### 1.3. 임의 접근 머신 (Random Access Machine)

- 거대한 배열로 만들어진 임의 접근 머신 (RAM)

- 레지스터 (각 1개의 워드)

- Θ(1) 시간 안에 할 수 있는 일
  - 레지스터에 접근
  - 레지스터 i에 있는 워드를 레지스터 j로 불러오기
  - 레지스터에서 (+, −, ∗, /, &, |, ˆ) 계산
  - 레지스터 i를 j에 있는 메모리에 저장
- 워드란? w bit를 의미 : `w ≥ log₂(memory size) bit` (워드가 모든 메모리를 인덱싱 할 수 있어야 하기 때문에)
  - 기본적인 객체(e.g., 정수)가 워드에 들어맞는다고 가정한다
  - 엄청나게 큰수의 연산은 어떻게 할까? (워드 단위를 넘어서는)
- 현실적이고 강력함 → 추상적 개념 구현

### 1.4. 포인터 머신 (Pointer Machine)

- 동적 할당된 객체 (ex, 파이썬의 튜플, C++의 벡터 등)

- 객체 는 O(1)개의 필드를 갖는다.
- 필드는 워드 (e.g., 정수)가 될수 있고, 또는 객체/널을 가리키는 포인터
- RAM보다 약하다 (RAM으로 구현 가능)

## 2. 시간 복잡도

### 2.1. 시간 복잡도란?

- 입력 'N'에 대하여 구현된 알고리즘이 문제를 해결하는데 얼마나 오래걸리는지 분석
- Big-O 표기법으로 시간복잡도를 정의함

### 2.2. Big-O 표기법

- 알고리즘의 문제 해결에 걸리는 시간을 나타낸 식 중에서 가장 큰 차수( n이 무한대로 갈 때 영향을 가장 크게 미치는 항)만 표기하는 표기법

  예시)

  | Regular | Big-O  |                             |
  | ------- | ------ | --------------------------- |
  | 2       | O(1)   | It's just a constant number |
  | 2n + 10 | O(n)   | n has the largest effect    |
  | 5n^2    | O(n^2) | n^2 has the largest effect  |

### 2.3. 시간복잡도 예시

- 대표적인 시간 복잡도

  1. **O(1) – 상수 시간** : 입력값 n 이 주어졌을 때, n의 크기와 상관없이 알고리즘이 문제를 해결하는데 오직 한 단계만 거치는 경우
  2. **O(log n) – 로그 시간** : 입력값 n 이 주어졌을 때, 문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어드는 경우
  3. **O(n) – 직선적 시간** : 문제를 해결하기 위한 단계의 수와 입력값 n이 1:1 관계를 가지는 경우
  4. **O(n^2) – 2차 시간** : 문제를 해결하기 위한 단계의 수가 입력값 n의 제곱인 경우
  5. **O(C^n) – 지수 시간** : 문제를 해결하기 위한 단계의 수가 주어진 상수값 C 의 n 제곱인 경우

  예시) n = 16 일 경우

  | Big-O     | steps        |                                                    |
  | --------- | ------------ | -------------------------------------------------- |
  | O (1)     | 1 step       | O(1)는 시간복잡도가 1                              |
  | O (log n) | 4 steps      | O(log n)는 시간복잡도가 4 (log 의 밑이 2라고 가정) |
  | O (n)     | 16 steps     | O(n)는 시간복잡도가 16                             |
  | O(n^2)    | 256 steps    | O(n^2)는 시간복잡도가 256                          |
  | O(2^n)    | 65,536 steps | ...                                                |

- 예시 코드

  ```c
    /* Case 1 */
    sum = n * n;

    /* Case 2 */
    sum = 0
    for 1 to n do
        sum = sum + n;

    /* Case 3 */
    sum = 0
    for i 1 to n do
        for j 1 to n do
            sum = sum + 1;
  ```

  위 3개의 알고리즘의 연산 횟수를 비교해보면 아래와 같이 나타낼 수 있다.

  (간단하게 확인하기 위해 루프 제어 연산은 제외)

  Case 1 : 대입 연산 : 1번, 곱셉 연산 : 1번 ⇒ 총 연산 횟수 : 2

  Case 2 : 대입 연산 : n+1, 덧셈 연산 : n ⇒ 총 연산 횟수 : 2n+1

  Case 3 : 대입 연산 : n*n+1, 덧셈 연산 : n*n ⇒ 총 연산 횟수 : 2n^2+1

  > 하나의 연산이 **t 만큼의 시간**이 필요하다고 가정한다면,
  >
  > **Case 1의 경우**는 2t 만큼의 시간이 필요하고,
  >
  > **Case 2의 경우**는 (2n+1)t 만큼의 시간이 필요하며,
  >
  > **Case 3의 경우**에는 (2n2+1)t 만큼의 시간이 필요하다.

  Case 2의 Big-O 표기법으로 자세하게 살펴보면,

  ```c
    sum = 0
    for i = 1 to n do
        sum = sum + n;

    // i <- 1 : 대입 연산 1회
    // to : n + 1 번의 비교 연산(루프를 탈출하기 직전의 비교 연산 포함)
    // n : n 번의 연산
  ```

  하나의 루프 제어문은 전체적으로 보면 2n+2개의 연산을 추가하게 되어,

  루프문을 제외 했을 때의 결과인 2n+1와 루프 제어문의 연산인 2n+2가 되어 총 연산 횟수는 4n+3이 된다.

  하지만, Big-O 표기법에서는 n이 커짐으로 정비례하는 관계이기 때문에 계수4는 무시되고, 상수 3역시 무시된다. 따라서, 최종적인 Big-O 표기법으로 Case 2를 표현하면, **O(n)** 이 된다.

### 2.4. Big-O 표기법의 수학적 정의와 예시

- 수학적 정의

  두 개의 함수 f(n) 과 g(n) 이 주어졌을 때, 모든 n≥n0 에 대하여 |f(n)|≤c|g(n)| 을 만족하는 2개의 상수 c와 n0가 존재하면 f(n)=O(g(n)) 이다.

  f(n)=5 이면 O(n) 이다. n0=1,c=10 일 때, n≥1 에 대하여 5 ≤ 10⋅1 이 되기 때문이다.

  f(n)=3n^2+100 이면 O(n^2) 이다. n0=100,c=5 일 때 n≥100 에 대하여 3^2+100≤5n^2 이 되기 때문이다.

- Big-O 표기법 일반적인 성능

| Big-O    | N=32 일때 연산량                       | 속도 |
| -------- | -------------------------------------- | ---- |
| O(1)     | 1                                      | 빠름 |
| O(logN)  | 5                                      |      |
| O(N)     | 32                                     |      |
| O(NlogN) | 160                                    |      |
| O(N^2)   | 1024                                   |      |
| O (N^3)  | 32768                                  |      |
| O(2^N)   | 4294967296                             |      |
| O(3^N)   | 1853020188851841                       |      |
| O(N!)    | 2.6313083693369353016721801216 x 10^35‬ | 느림 |

- 최선, 평균, 최악의 경우

  동일한 알고리즘도 입력되는 데이터에 따라 처리 시간에 큰 차이를 보일 수 있다. 예를 들어, 데이터가 무작위로 정렬되어 있는지 어떠한 규칙을 가지고 정렬되어 있는지에 따라 알고리즘의 속도는 차이를 보일 것 이다.

> Best Case : 실행 시간이 가장 작은 최적의 상황
>
>Average Case : 모든 가능한 입력 상황을 고려한 평균 수행 시간을 의미
>
>Worst Case : 실행 시간이 가장 오래걸리는 최악의 상황

  ⇒ 평균적인 실행시간이 가장 일반적인 것 처럼 생각할 수 있지만, 모든 상황을 고려하여 알고리즘을 적용하기란 매우 어려운 일이기 때문에, 보통 **최악의 경우** 를 주로 사용한다.

## 3. 공간 복잡도

### 3.1. 공간복잡도란?

- 프로그램을 실행시킨 후 완료까지 필요로 하는 자원 공간의 양을 의미 (메모리 사용량)

- '총 공간 요구 = 고정 공간 요구 + 가변 공간 요구'로 표현

  `S(P) = c + Sp(n)`

  고정 공간 ( c ) : 입력과 출력의 횟수나 크기에 관계 없는 공간 (코드 저장 공간, 단순 변수, 상수 등)

  가변 공간 ( Sp(n) ) : 해결하려는 문제의 특정 인스턴스에 의존하는 크기를 가진 구조화 변수들을 위해 필요한 공간, 함수가 순환 호출을 할 경우 요구되는 추가 공간 (동적으로 필요한 공간)

### 3.2. 공간 복잡도 예시

```c
// 1번 예시

int factorial(int n)
{
    if(n > 1) return n * factorial(n - 1);
    else return 1;
}
```

n이 1이하일 때까지 함수가 재귀적으로 호출되어 스택에 n부터 1까지 쌓임 → 공간 복잡도는 O(n)

```c
// 2번 예시

int factorial(int n)
{
    int i = 0;
    int fac = 1;
    for(i = 1; i <= n; i++)
    {
        fac = fac * i;
    }
    return fac;
}
```

n값에 상관 n, i, fac 변수만 저장될 공간이 사용됨.

→ 공간 복잡도는 O(1)

## 4. 공간복잡도 VS 시간복잡도

- 시간복잡도와 공간복잡도는 반비례적인 경향이 있어, 알고리즘의 척도는 보통 시간 복잡도 위주로 판단함
