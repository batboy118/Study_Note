# 15. 그래프의 최소 비용 문제

>그래프에서의 최소 비용 문제는 대표적으로 두 가지가 있다. 그래프에서 모든 정점들을 연결하는 간선들의 가중치의 합이 최소가 되는 트리를 찾는 문제인 **최소 신장 트리 문제**와 시작 정점에서 목표 정점까지의 간선의 가중치 합이 최소가 되는 경로를 찾는 **최단 경로 문제**이다.

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./README.md)

---

<!-- TOC -->

- [1. 최소 신장 트리](#1-최소-신장-트리)
	- [1.1. 신장 트리 (Spanning Tree)](#11-신장-트리-spanning-tree)
	- [1.2. 최소 신장 트리 (Minimum Spanning Tree)](#12-최소-신장-트리-minimum-spanning-tree)
	- [1.3. 프림 알고리즘](#13-프림-알고리즘)
	- [1.4. 크루스칼 알고리즘](#14-크루스칼-알고리즘)
- [2. 최단 경로 문제](#2-최단-경로-문제)
	- [2.1. 다익스트라 알고리즘](#21-다익스트라-알고리즘)
	- [2.2. 벨만-포드 알고리즘](#22-벨만-포드-알고리즘)
- [3. 각 알고리즘의 복잡도 분석](#3-각-알고리즘의-복잡도-분석)
	- [3.1. 프림 & 크루스칼 알고리즘](#31-프림--크루스칼-알고리즘)
	- [3.2. 벨만포드 & 다익스트라 알고리즘](#32-벨만포드--다익스트라-알고리즘)

<!-- /TOC -->

## 1. 최소 신장 트리

### 1.1. 신장 트리 (Spanning Tree)

- N개의 정점을 포함하는 무향 그래프에서 `n개의 정점과 n-1개의 간선`으로 구성된 트리

  ![image](https://user-images.githubusercontent.com/53181778/78098177-c8a57d00-73cd-11ea-814a-478eddbf8efe.png)

  오른쪽이 신장트리들 이다.

### 1.2. 최소 신장 트리 (Minimum Spanning Tree)

- 간선의 가중치를 줘서 신장 트리를 구성하는 **가중치의 합이 최소**인 신장 트리

  ![image](https://user-images.githubusercontent.com/53181778/78098266-0f937280-73ce-11ea-9ca9-b5bfe554922d.png)

최소 신장트리를 찾는 알고리즘에는 프림과 크루스칼 알고리즘이 존재한다.

### 1.3. 프림 알고리즘

- 한 정점에 연결된 간선들 중, 하나씩 선택하면서 최소 신장 트리를 만들어가는 방식
  1. 임의의 시작 정점을 하나 선택
  2. 선택한 정점들과 인점하는 정접들 중에 최소 비용의 간선이 존재하는 정점을 선택
  3. 모든 정점이 선택될 때까지 앞의 과정을 반복
- 정점을 하나씩 선택할 때 마다 간선을 추가하면서 트리를 확장함
- 두 종류의 상호 배타 집합이 필요하다

  1. 트리 정점(Tree vertices) : 최소 신장 트리를 만들기 위해 선택된 정점
  2. 비트리 정점(non-tree vertices) : 선택되지 않은 정점
- 알고리즘
  1. 초기 그래프의 모든 정점들의 key 값을 무한대로 설정
  2. 시작 정점(strat vertex)을 설정
     - 프림 알고리즘은 어떠한 점을 설정하더라도 항상 같은 트리가 형성된다.
  3. 시작 정점의 초기 key값을 0으로 설정
     - 이때, 시작정점이 Queue에 들어있는 key 값 중 최소 key를 가지는 정점이 된다.
  4. Queue에 들어있는 가장 작은 key값을 가지는 정점을 선택 후 모든 `인접 정점의 key`값이  `간선의 가중치`의 값보다 크다면, `간선의 가중치`를 각 인접 정점의 key 값으로 저장
  5. 이때, key값이 갱신된 인접 정점들이 현재 정점을 가리키도록 한 후 현재 정점을 Queue에서 삭제 합니다.
  6. Queue가 빌 때까지 4, 5번을 반복합니다.

- 수도 코드

```c
MST_PRIM(G, r) //G : 그래프, r : 시작 정점
{
    for(모든 정점의 집합의 원소 u)  // 초기화
    {
        u.key = INF;//u.key는 연결된 간선 중 최소 가중치를 의미, 무한대로 초기화
        u.pi = NULL;//트리에서 정점 u의 부모를 의미, 무한대로 NULL 초기화
    }
    r.key = 0;		//시작 정점의 key 값을 0으로 설정
    Q = G.V;  //큐에 모든 정점을 넣는다.
    while(Q is not empty)
    {
        u = Extract_Min(Q);  //키 값이 가장 작은 정점을 큐에서 가져오기
        for(u에 인접한 모든 v에 대해서)
        {
            if(v에 저장된 key값이 간선의 값보다 작으면)
            {
                v.pi = u; //간선 정보 저장(연결된 정점)
        		v.key = weight(u, v); //트리와의 거리 저장
            }
        }
    }
}
```

### 1.4. 크루스칼 알고리즘

- 최소 가중치 간선을 하나씩 선택해서 최소 신장 트리를 찾는 알고리즘

  - 싸이클이 생기지 않아야 함
  - N개의 정점을 포함하는 그래프에서 n-1개의 간선을 선택하는 방식

- 프림알고리즘은 하나의 트리를 확장시켜 나가는 방식이라면, 크루스칼 알고리즘은 간선을 선택하는 과정에 여러개의 트리가 존재하여 트리를 합치는 방식으로 진행된다.(유니온 파인드)

- Kruskal's 알고리즘은 두 개의 트리를 연결하는 모든 간선 중 가장 작은 간선( u , v )를 찾아 MST의 부분집합에 추가해야 한다.

- 알고리즘

  1. 최조, 모든 간선을 가중치에 따라 오름차순으로 정렬 (옵션)
  2. 초기값으로 모든 정접에 대해 각 정점이 하나의 집합을 이루도록 함 (모든 집합에 대해 개별 트리 생성)
  3. 모든 간선 중 가중치가 가장 작은 간선을 선택하여 간선에 연결되 두 집합에 대해 find연산을 하여 서로 대표값을 확인하고, 대표값이 다르다면 간선으로 연결된 두 집합(트리)를 union으로 결합해 준다. (대표값을 공유하게 됨)
     - 가장치가 가장 낮은 간선부터 선택하면서 트리를 합치는데, 만약, 간선에 사이클이 존재(같은 트리이면)하면 다음으로 가중치가 낮은 간선을 선택한다.
  4. 3~4번을 반복하면서, 하나의 트리로 합쳐지면 (n-1개의 간선이 선택되면) 끝낸다.

  - n-1개의 간선이 선택될 때까지 앞의 과정 반복

- 수도 코드

  ```c
  //간선으로 생선된 트리를 상호 배타 집합으로 관리함
  MST_KRUSKAL(G)
  {
      T = {} ;//T는 최소 신장 트리의 간선 집합, 비어있는 집합 생성
  	for(모든 정점 v에 대해) //각 정점을 집합으로 만든다.
          Make_set(v);
      sort 간선들(G,E)를 가중치 순으로 정렬;
      While(T의 크기 < |V| - 1)  // 정점수 -1 만큼 반복
      {
          가중치가 가장낮은 간선 (u, v)를 선택;
          if(find_Set(u) != find_set(v)) //싸이클 검사
          {
              T에 (u, v)를 삽입;  // 간선 정보를 삽입
              Union(u,v);  //u와 v를 하나의 집합으로 만든다.
          }
      }
      return T;
  }
  ```

- 크루스칼 알고리즘의 특징
  - 간선 선택 과정에서 생성되는 트리를 관리하기 위해 상호 배타 집합을 사용
    - 트리에 속한 노드들은 자신을 루트로 하는 서브 트리의 높이를 랭크라는 이름으로 저장
  - 선택한 간선으로 두 개의 트리가 한 개의 트리로 합쳐질 때 깍 드리에 해당하는 상호 배타 집합을 Union연산으로 합침
  - 랭크 값이 작은 트리를 랭크 값이 큰 서브 트리로 포함시키게 되면 트리에 포함된 노드들의 랭크 값을 수정할 필요가 없다.

## 2. 최단 경로 문제

최단 경로 : 간선의 가중치가 있는 **유향 그래프**에서 두 정점 사이의 경로들 중에 간선의 가중치의 합이 최소인 경로

- 단일 시작점 최단 경로 문제
  - 다익 스트라 알고리즘
    - 음의 가중치 허용하지 않음
  - 벨만-포드 알고리즘
    - 음의 가중치 허용 (단, 가중치의 합이 음인 사이클은 허용하지 않음)
- 모든 쌍 최단 경로 문제
  - 플로이드-위샬 알고리즘

### 2.1. 다익스트라 알고리즘

- 시작 정점에서 거리가 최소인 정점 부터 선택해 나가면서 최단 경로를 구하는 방식

  - 탐욕 기법을 사용한 알고리즘으로 최소 신장 트리를 구하는 프림 알고리즘과 유사

- 음의 가중치를 가지게 되면 그리디 알고리즘이 꼬이게 되어, 올바른 결과가 나오지 않는다.

- 알고리즘

  1. 시작 정점을 제외한 모든 정점을 무한대의 값으로 설정
  2. (Relax) 현재 정점과 인접한 모든 정점의 key 값을 갱신한다. 이때 인접 정점의 D값이  `현재 정점의 D값 + 간선의 가중치`보다 클 경우에만 `현재 정점의 D값 + 간선의 가중치`로 변경한다.
  3. 큐에 있는 현재 정점을 제거한다.
  4. (Extract) 큐에 남아 있는 정점 중 가장 작은 D값을 가지는 정점을 선택한다.
  5. 2 ~ 4번의 작업을 동일하게 수행한다. 만약 남아 있는 정점이 없다면 작업을 종료한다.

- 수도 코드

  ```c
  Relax(u, v, W)
  {
      if(v.d > u.d+w(u,v))
      {
          v.d=u.d + w(u,v);
          v.pi = u;
      }
  }

  DIJKSTRA(G, w, s)
  {
      모든 정점의 d값을 무한대로 설정;
      시작 정점 d값 0으로 설정;
      S = {}; // 집합 S
      Q = G.v; // 큐에 모든 정점 삽입
      while(Q is not empty)
      {
          u = Extract-min(Q);
          S = S U {u};// u 집합 S에 삽입
          for(u의 인접정점인 모든 v에 대해서)
              Relax(u, v, w);
      }
  }
  ```

### 2.2. 벨만-포드 알고리즘

- 음의 가중치를 가져도 되지만, 음의 싸이클은 허용하지 않는다.

  - 예 : v2 -> v3의 가중치 2보다 v3 -> v2의 가중치 -4가 절대값이 더 크므로, v2와 v3가 순환하게 된다. 벨만 포드 알고리즘은 SSP를 구할 수 있음은 물론, 최단경로에 도달할 수 없음을 false를 반환함으로써 표현할 수 있다. 이것을 벨만 포드 알고리즘의 정확성이라 한다.

    ![image](https://user-images.githubusercontent.com/53181778/78419154-5a152900-7632-11ea-92d7-219327efb085.png)

- 다익스트라로 최단경로를 구할 수 있다면 벨만-포드로도 구할 수 있다.

- 출발점에서 각 정점까지 간선 하나로 구성된 경로 고려, 최단 경로 구함

- 최대 간선 2개까지 고려, 최단 경로 구함

- 최대 간선 n-1개까지 고려한 경로들에서 최단 경로 구함

- 다익스트라 보다 시간이 오래 걸림

- 벨만 포드 알고리즘은 **정점의 개수**만큼 **모든 간선**을 Relax하는 작업을 수행

- 알고리즘

  1. 시작 정점은 0으로, 나머지 정점의 D값은 무한대로 할당한다.
  2. 정점 V1으로 시작해서 모든 간선에 대해 Relax 하여 정점의 값들을 갱신 한다.
  3. 갱신된 이전의 값은 유지한 채로, 차례대로 정점 V2, V3, V4 ...를 출발점으로 모든 간선에 대해서 Relax를 반복한다.

- 수도 코드

  ```c
  Relax(u, v, W)
  {
      if(v.d > u.d+w(u,v))
      {
          v.d=u.d + w(u,v);
          v.pi = u;
      }
  }

  BELLMAN-FORD(G, w, s)
  {
      모든 정점의 d값을 무한대로 설정;  // 그래프 초기화
      시작 정점은 0으로 할당;
      for(i = 1 to |G.V| -1)	// 모든 정점을 돌면서, 모든 간선에 대한 릴렉스
      	for(모든 간선 edge(u,v)에 대해)
              Relax(u, v, W);
      for(모든 간선 edge(u,v)에 대해)  // 음의 가중치를 갖는 싸이클 존재 확인
          if(v.d > u.d + w(u,v))
              return (false);
      return (true);
  }
  ```

## 3. 각 알고리즘의 복잡도 분석

### 3.1. 프림 & 크루스칼 알고리즘

- 프림은 정점 위주의 알고리즘, 크루스칼은 간선 위주의 알고리즘이다.
- 시간 복잡도는 비슷하지만, 일반적으로 Dense한(간선이 많은) 그래프의 경우 프림이, 그렇지 않은 경우에는 크루스칼이 유리하다.
- 프림의 경우 최소 거리의 정점을 찾는 부분에서 **자료구조의 성능**에 영향을 받는다.

- 크루스칼은 간선을 weight 기준으로 정렬하는 과정이 오래 걸린다.

- 복잡도 비교 (V는 정점, E는 간선의 수)

  - 프림

    - 인접 행렬을 사용 했을 경우 : `O(V²)`
    - 이진 힙과 인접 리스트를 사용했을 경우 : `O(E logV)`

  - 크루스칼 : `O(E logE)` (= `O(E log V)`)

    > 크루스칼 알고리즘의 시간복잡도는 ![img](https://t1.daumcdn.net/cfile/tistory/9965BB405B7022F109)번의 Union-Find연산이,
    >
    > ![더블클릭을 하시면 수식을 수정할 수 있습니다.](https://t1.daumcdn.net/cfile/tistory/992EE0365B7023062F)번의 make-set연산 합쳐 총 ![img](https://t1.daumcdn.net/cfile/tistory/991B16385B70232F17)의 시간이 걸리고 ![img](https://t1.daumcdn.net/cfile/tistory/992D3C3F5B70236F33)이므로
    >
    > 결론적으로 시간복잡도는 ![img](https://t1.daumcdn.net/cfile/tistory/995DE2365B70237F28)라 할 수 있다.
    >
    > 퀵 소트나 머지 소트 등을 사용했다고 가정할 시 크루스칼 알고리즘의 복잡도

### 3.2. 벨만포드 & 다익스트라 알고리즘

- 복잡도 비교

  - 다익 스트라 : `O(E log V)`

    > 시간 복잡도에 영향을 주는 작업은 두 가지인데 하나는 각 정점마다 인접한 간선들을 모두 검사하는 작업이고, 다른 하나는 우선순위 큐에 원소를 넣고 삭제하는 작업이다.
    >
    > 모든 간선이 한 번씩 검사된다는 점에서 첫 번째 작업이 O(E), 각 간선마다 우선순위 큐에 자료가 삽입 연산이 일어난다는 점에서 O(E log E)이며 이 둘을 합쳤을 때(E + E log E) time complexity는 O(E log E)이다. 대개의 그래프의 경우 V^2 > E이므로 O(log E) = O(log V)이고 time complexity는O(E log V)로 볼 수 있다.

  - 벨만 포드 : `O(VE) 또는 O(E ^ 2)`

    >모든 수를 고려하는 벨만-포드 알고리즘은 다익스트라 알고리즘에 비해 느릴 수밖에 없다. 라운드는 V - 1이고, 각 라운드마다 모든 에지를 검사하기 때문에
    >
    >O(VE) 또는 O(E ^2)이라고 볼 수 있다.
