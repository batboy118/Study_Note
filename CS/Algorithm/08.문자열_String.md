# 08. 문자열_String

> 컴퓨터에서 문자를 저장하는 방법을 아는 것은 매우 중요하다. 아스키코드와 유니코드에 대한 개념을 이해해보고, 컴퓨터가 문자열을 어떻게 처리하는지 알아보자.

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./)

---

<!-- TOC -->

- [1. 문자 집합d](#1-문자-집합d)
	- [1.1. 아스키 코드](#11-아스키-코드)
	- [1.2. 확장 아스키코드](#12-확장-아스키코드)
	- [1.3. 유니코드](#13-유니코드)
- [2. 인코딩](#2-인코딩)
	- [2.1. 문자 집합 vs 인코딩](#21-문자-집합-vs-인코딩)
	- [2.2. 인코딩 종류](#22-인코딩-종류)
		- [2.2.1 UTF-8](#221-utf-8)
		- [2.2.2. UTF-16](#222-utf-16)
		- [2.2.3. UTF-32](#223-utf-32)
	- [2.3. BOM](#23-bom)
- [3. 문자열](#3-문자열)
	- [3.1 C 언어에서 스트링 처리](#31-c-언어에서-스트링-처리)
	- [3.2. Java에서의 스트링 처리](#32-java에서의-스트링-처리)
	- [3.3. C 와 Java의 스트링 처리의 기본적인 차이점](#33-c-와-java의-스트링-처리의-기본적인-차이점)
	- [3.4 문자열 복사](#34-문자열 복사)
	- [3.5. 문자열 뒤집기(역순)](#35-문자열 뒤집기역순)
	- [3.5. 문자열 비교](#35-문자열 비교)
	- [3.6. 숫자 문자열을 숫자로](#36-숫자-문자열을-숫자로)

<!-- /TOC -->

## 1. 문자 집합d

- 컴퓨터에서 문자를 저장하는 방법

- 문자 집합은 정보를 표현하기 위한 글자나 기호들의 집합을 정의한 것

  ⇒ `아스키 코드`, `유니코드`

### 1.1. 아스키 코드

- 7bit로 인코딩된 문자로 `printable 캐릭터`는 숫자, 영어, 특수기호 등으로 구성되어 있음
- 0 ~ 127번까지 총 128개의 문자로 구성
- [위키백과](https://ko.wikipedia.org/wiki/ASCII)

### 1.2. 확장 아스키코드

- 아스키코드가 8bit로 확장된 형태로 더 많은 `특수기호`를 포함
- 아스키 코드에서 최상위 bit 하나가 추가된 형태로, 128 ~ 255번까지 확장됨
- 0 ~ 255번까지 총 256개의 문자로 구성

### 1.3. 유니코드

- 다국어 처리를 위한 표준 문자들의 집합
- 유니코드는 하나의 코드셋으로 모든 문자를 나타내야하고, 가변길이라는 특성때문에 특별한 처리를 거쳐 인코딩되게 된다.
- 유니코드도 다양한 인코딩이 존재한다.
- U+ 라는 접두어가 붙어있으면 유니코드 라는 의미이다. 아스키코드의 0x41은 대문자 A이고, 이를 유니코드표에서 찾으면 U+0041이 된다.

## 2. 인코딩

### 2.1. 문자 집합 vs 인코딩

- `character set`: 정보를 표현하기 위한 글자들의 집합을 정의한 것. 한 문자 집합을 여러 문자 인코딩에서도 사용가능 (ex: 유니코드)
- `character encoding`: 문자나 기호들의 집합을 컴퓨터에서 표현하는 방법.(UTF8, UTF16)

- 인코딩이 필요한 이유

  유니코드나 아스키 코드와 같은 문자들은, 문자를 저장하는 변수의 크기가 정해져 있다. 만약에 다른 캐릭터 셋을 가지고 문자를 처리한다면 모두 구분해서 다르게 구현해야한다.

  예를들면, 파일을 인식 시 이 파일이 USC-2, USC-4인지 인식하고 각 경우를 구분해서 모두 다르게 구현해야 하는 문제가 발생하게 된다.

> 유니코드라는 `character set`은 각 글자가 특정 bytes에 대응되는 집합을 의미한다. 예를 들어 **‘안’**은 유니코드로 **“C5 48”**이라는 값과 대응되고, **‘녕’**은 **“B1 55”**라는 값에 대응된다.
>
> `UTF8`과 `UTF16`은 모두 유니코드라는 character set을 이용한 `인코딩 방식`을 의미한다.
> 인코딩은 쉽게 말해 컴퓨터가 이해할 수 있는 byte값으로 변환함을 의미한다. 따라서 **‘안’**을 UTF8로 인코딩 한다는 의미는 **“C5 48”**이라는 값을 규칙에 따라 특정 byte값으로 변환하겠다는 의미이고, 이는 **“EC 95 88(안) EB 88 95(녕)”**로 변환된다. 비슷하게 **‘안’**을 UTF16으로 인코딩하면 **“C5 48”**이라는 값이 규칙에 따라 **“C5 48(안) B1 55(녕)”**로 변환되게 된다.

### 2.2. 인코딩 종류

#### 2.2.1 UTF-8

가변길이 유니코드 인코딩(`1byte ~ 4byte`)으로 **ASCII 영역(127이하)은 그대로 1byte의 동일값**을 사용한다. **한글은 주로 3byte**로 표현한다. 문자에 따라 1~4byte로 가변적 표현을 한다. **인터넷 사이트에서 가장 많이 쓰이는 인코딩**으로 엔디안에 상관없이 똑같이 읽을 수 있다는 장점이 있다. 또한 **리눅스나 maxos에서는 운영체제 자체의 인코딩 형식을 UTF-8로 통일**했다.

- 인코딩 방식

  유니코드 코드 포인트를 나타내는 비트들은 여러 부분으로 나뉘어서, UTF-8로 표현된 바이트의 하위 비트들에 들어 간다. `U+007F`까지의 문자는 7비트 ASCII문자와 동일한 방법으로 표시되며, 그 이후의 문자는 다음과 같은 4바이트까지의 비트 패턴으로 표시된다. 7비트 ASCII 문자와 혼동되지 않게 하기 위하여 모든 바이트들의 최상위 비트는 1이다.

| 코드 범위(16진법) | UTF-8 표현(이진법)                  | 설명                                                         |
| ----------------- | ----------------------------------- | ------------------------------------------------------------ |
| 000000-00007F     | 0xxxxxxx                            | ASCII와 동일한 범위                                          |
| 000080-0007FF     | 110xxxxx 10xxxxxx                   | 첫 바이트는 `110`로 시작하고,<br/>나머지 바이트들은 `10`으로 시작함 |
| 000800-00FFFF     | 1110xxxx 10xxxxxx 10xxxxxx          | 첫 바이트는 `1110`로 시작하고,<br/>나머지 바이트들은 `10`으로 시작함 |
| 010000-10FFFF     | 11110xxx 10zzxxxx 10xxxxxx 10xxxxxx | 첫 바이트는 `11110`로 시작하고,<br/>나머지 바이트들은 `10`으로 시작함 |

[위키백과](https://ko.wikipedia.org/wiki/UTF-8)

>UTF-8인코딩 방식에서 한글의 경우 주로 `3바이트 구간`에 존재해서 한글로 작성된 문서의 경우 `2바이트 구간`에 한글이 존재하는 EUC-KR이나 UTF-16으로 저장한 것 보다 UTF-8로 저장했을 때 파일의 크기가 더 커진다.

> MS 계열 프레임워크에서 C/C++등을 이용해 비 유니코드의 멀티바이트 캐릭터를 UTF-8 형식으로 변환하기 위해서는 와이드바이트 형식의 완전 2바이트 유니코드로 변환한 다음 다시 UTF-8 플래그를 주어 멀티바이트 형식으로 다시 변환하는 과정이 필요하다.

#### 2.2.2. UTF-16

가변길이 유니코드 인코딩(`2byte, 4byte`)으로 2byte영역(BMP영역)까지는 `UCS-2`(2byte 유니코드 캐릭터 셋)와 동일(하나, 가변길이 부호화를 통해 4byte영역까지 확장함으로써 더 많은 문자를 표현할 수 있다. **ASCII 영역(127이하) 문자들도 각각 2byte로 표현되므로 변환없이는 영문자도 호환되지 않는다.** 윈도우에서 주로 사용하는 방식이다.

#### 2.2.3. UTF-32

가변길이 유니코드 인코딩이지만 기본 바이트가 `4byte`이다. **UCS-4**와 완벽히 호환된다. 아직까지 **UCS-4**보다 더 큰 문자집합이 없기 때문에 특별히 가변길이를 고려하지 않아도 돼 프로그램 내부적으로 사용되기도 한다. 하지만 메모리 낭비가 심하다.

### 2.3. BOM

Byte Order Mark. 문서의 처음에 눈에 보이지 않는 특정 바이트를 넣어 문서가 어떤 Endian, 인코딩 방식을 사용하고 있는지 알려주기 위한 장치다. 상황에 따라 이게 오히려 문제를 일으키기도 한다. 유닉스/리눅스 계열에서는 쓰지 않는 것이 관례. 웹 프로그래밍에서도 사용하지 않는 것이 좋다.

- UTF-8 >> EE BB BF (UTF-8 Signature, 단지 UTF-8로 인코딩되었다는 사실을 알리는 사인.)

- UTF-16 Big Endian >> FE FF

- UTF-16 Little Endian >> FF FE

- UTF-32 Big Endian >> 00 00 FE FF

- UTF-32 Little ENdian >> FF FE 00 00

## 3. 문자열

- 문자열의 길이를 알 수 있는 방법

  - 구분자(delimited) : C언어에서의 스트링 (`\0`)

  - 길이 조절 : 스트링 클래스에 길이의 정보를 담고 있는 경우 (JAVA)

    - 자바 스트링 클래스에는 기본 객체 메다 데이터 이외에도 네가지 필드가 존재함
      1. hash 값 (hash)
      2. string 길이 (count)
      3. string 시작점(offset)
      4. 실제 string 배열에 대한 참조(value)
    - 자바에서는 스트링이 스트링 길이를 관리하는 가변길이 구조를 가짐

    ![image](https://user-images.githubusercontent.com/53181778/76684929-bc68a400-6607-11ea-8aac-8040937ae392.png)

### 3.1 C 언어에서 스트링 처리

- 문자배열에 string을 저장할 때는 항상 마지막에 끝을 표시하는 Null문자 `\0` 을 넣어줘야 함
- string 처리에 필요한 연산을 함수형태로 제공해 준다.
  - `strlen()`, `strcpy()`, `strcmp()` 등

### 3.2. Java에서의 스트링 처리

- String 데이터를 저장, 처리해주는 클래스를 제공해준다.
  - `String str = "abc";`  또는 `String str = new String("abc");`
- String 처리에 필요한 연산을 연산자, 메쏘드 형태로 제공
  - `+`, `-`, `length()`, `replace()`, `split()`, `substring()` 등

### 3.3. C 와 Java의 스트링 처리의 기본적인 차이점

- C는` ascii 코드`로 저장

- Java는 `유니코드`로 저장 (UTF-16, 2byte 방식 사용)

  ![image-20200315002947723](C:\Users\118jj\AppData\Roaming\Typora\typora-user-images\image-20200315002947723.png)



### 3.4 문자열 복사

- 소스로부터 한 글자씩 읽어 타겟에 한 글자씩 복사한다.
- Null를 만나면 Null문자를 찍고 복사를 종료한다.

```c
while(*src)
{
    *des = *src;
    des++;
    src++;
}
*des = '\0';
```

### 3.5. 문자열 뒤집기(역순)

1. 새롭게 string을 생성하지 않고 string을 뒤집는 방법
   - 임시 변수가 필요
   - string 길이의 절반 만큼만 반복

2. 새로운 string을 생성하여 역순의 string을 만드는 방법

### 3.5. 문자열 비교

- 스트링이 사전적 순서의 대소 관계를 비교하여 차이를 리턴
  - str1이 더 크면 양수, 작으면 음수, 같으면 0을 리턴함
- 앞에서부터 비교함

```c
int	my_strcmp(const char *str1, const char *str2)
{
    int i = 0, j = 0;
    while(str1[i] != '\0')
        if(str1[i++] != str2[j++])
            	break;
    return (str1[i] - str2[j])
}
```

### 3.6. 숫자 문자열을 숫자로

- 숫자 문자열을 일반 숫자처럼 사용하면 에러가 발생한다. 숫자 문자열을 숫자형으로 바꾸어 사용해야 한다.

- C 언어에서는 문자열을 int형으로 변환시켜주는  `atoi()` 함수를 제공해 준다.

> cf ) 숫자를 숫자 문자열로 바꾸는 함수는 `itoa()`

```c
int	atoi(const char *string)
{
	int value = 0; digit = c;
    while((c = *string++) != '\0'){
        if(c >= '0' && c<= '9')
            digit = c - '0';
        else
            break;
        value = (vaue * 10) + digit;
    }
    return value;
}
```
