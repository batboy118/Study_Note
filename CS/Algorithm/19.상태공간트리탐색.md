# 19. 분기 한정

>상태 공간 트리를 탐색하는 방법중 분기 한정에 대해 학습한다.

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./README.md)

---

<!-- TOC -->

- [1. 상태 공간 트리 탐색](#1-상태-공간-트리-탐색)
- [2. 각 방법을 배낭 문제에 적용](#2-각-방법을-배낭-문제에-적용)
	- [2.1. 분기 한정 깊이 우선 탐색 + 백트래킹](#21-분기-한정-깊이-우선-탐색--백트래킹)
	- [2.2. 분기 한정 너비 우선 탐색](#22-분기-한정-너비-우선-탐색)

<!-- /TOC -->

## 1. 상태 공간 트리 탐색

- 상태 공간 트리 탐색 방법 3가지

  - 깊이 우선 탐색 (+ 백트래킹)

  - 너비 우선 탐색
  - 최고 우선 탐색(A* 알고리즘)

- 분기 한정

  1. 상태 공간 트리 탐색 과정에서 최적해를 찾을 가능성 없음 -> 가지치기 수행

  2. 지금까지 찾은 가장 좋은 해보다 더 좋은 해가 있는지 판단

     - 사용하는 전략에 따라 분기한정의 효율성 좌우

     - 상태공간 트리 노드 방문 시 마다 노드의 유망성 판단 => 한계치(bound) 계산

     - 한계치가 지금까지 찾은 최적의 값보다 좋지 않으면 유망하지 않음

       > 한계치(bound) : 그 노드에서 계속 탐색을 수행하면 얻을 수 있는 후보 해답의 최대치


## 2. 각 방법을 배낭 문제에 적용

### 2.1. 분기 한정 깊이 우선 탐색 + 백트래킹

상태 공간 트리 구축 후 백트래킹 기법으로 문제 해결

![image](https://user-images.githubusercontent.com/53181778/80111657-1cfde000-85bb-11ea-9572-862677b4809f.png)

루트 노드 ~ 단말 노드의 모든 경로가 해답의 후보가 된다.

=> 검색이 완료되기 전에는 해답을 알 수 없다.

즉, 검색하는 동안에는 항상 그 때까지 찾은 최적해를 기억(저장)해야 함

```c
// best : 지금까지 찾은 최대 가치
// value(v) : 노드 v에서의 가치
checknode(node v)
{
    node u;
    if vlue(v) is better than best
        best <- value(v);
    if promising(v)
        for each child u of v
            checknode(u);
}
```

노드 v의 유망성을 점검하는 방법은?

배남문제의 한계치 계산

- wi : i번째 물건의 무게
- pi : i번째 물건의 가치
- pi/wi : 무게당 가치
- 무게당 가치의 값이 큰 것부터 내림차순으로 물건 정렬
- 정렬된 순서로 1번부터 번호를 부여하여 물건 구분
- 방문하는 노드에서 다음 값들을 계산
  - profit : 그 노드에 오기까지 넣었던 물건들의 **가치**의 합
  - weight : 그 노드에 오기 까지 넣었던 물건들의 **무게**의 합

### 2.2. 분기 한정 너비 우선 탐색
