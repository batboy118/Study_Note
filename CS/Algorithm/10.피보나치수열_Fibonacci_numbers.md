# 10. 피보나치 수열_Fibonacci numbers

>재귀와 DP를 활용하여 피보나치 수열을 구하는 방법을 학습하겠다.

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./README.md)

---

<!-- TOC -->

- [1. 피보나치 수열 구하기](#1-피보나치-수열-구하기)
	- [1.1. 피보나치 수열이란?](#11-피보나치-수열이란)
	- [1.2. 재귀 함수로 피보나치 수열 구현](#12-재귀-함수로-피보나치-수열-구현)
	- [1.3. Memoization](#13-memoization)
	- [1.4. DP를 이용한 피보나치 수열 구하기](#14-dp를-이용한-피보나치-수열-구하기)
		- [1.4.1. recursive DP & iterative DP](#141-recursive-dp--iterative-dp)

<!-- /TOC -->

## 1. 피보나치 수열 구하기

### 1.1. 피보나치 수열이란?

- `0, 1, 1, 2, 3, 5, 8, 13, ...`
  - 첫 번째 항이 0이고, 두번 째 항이 1이다.
  - 세 번째 항부터는 이전의 두 수의 합을 다음 항으로 하는 수열이다.

- 피보나치 수열의 i번 째 값을 계산
  - F<sub>0</sub> = 0, F<sub>1</sub> = 1
  - F<sub>i</sub> = F<sub>i-1</sub> + F<sub>i-2</sub>  (for i ≥ 2)

### 1.2. 재귀 함수로 피보나치 수열 구현

- n 번째 항을 구하는 함수

```c++
fibo(int n){
	if(n < 2){
		return n;
	}
	else{
		return fibo(n - 1) + fibo(n - 2)
	}
}
```

- 단순하 함수로 피보나치 수열을 구하게 되면 함수의 `중복 호출`을 많이하게 되어 효율이 좋지 않다.

![image](https://user-images.githubusercontent.com/53181778/77383708-85b72a00-6d7b-11ea-9a64-4e12960b2205.png)

​		⇒ **`Memoization`을 이용하여 중복 호출을 방지함**

### 1.3. Memoization

- 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 방법

- DP의 핵심이 되는 기법 ( 동적 계획 )


### 1.4. DP를 이용한 피보나치 수열 구하기

- DP의 과정
  1. 문제를 부분 문제로 분할
  2. 부분 문제로 나누는 일이 끝나면, 가장 작은 부분의 문제부터 해를 구함
  3. 그 결과는 테이블에 저장하고, 테이블에 저장된 부분 문제의 해를 이용하여 상위 문제의 해를 구함

- 피보나치 수열을 재귀로 풀어보기

  - 문제를 부분 문제로 분할

    - F(n)함수는 F(n-1)과 F(n-2)의 합

    - F(n-1)함수는 F(n-2)과 F(n-3)의 합

      ...

    - F(2)함수는 F(1)과 F(0)의 합
    - F(n)은 F(n-1), F(n-2), ... , F(2), F(1), F(0)의 부분 집합으로 나뉨

  - 가장 작은 부분 문제부터 해를 구하고 결과를 테이블에 저장

  - 테이블에 저장된 값을 이용해 상위 문제를 해결

- 피보나치 수를 구하는 알고리즘에서 `fibo(n)`의 값을 계산하자마자 저장하면 실행시간을 줄일 수 있음

  - Memoization을 위한 배열 f를 할당하고 f[0]은 0으로 f[1]은 1로 초기화
  - 나머지는 모두 0으로 초기화

#### 1.4.1. recursive DP & iterative DP

- **재귀를 이용한 DP**

    ```c
    fib1(int n){
    	if(n > 2 && f[n] == 0){
    		f[n] = fib1(n-1) + fib1(n-2)
    	}
    	return f[n];
    }
    ```

- **iterative방식의 DP**

    ```c
    fib2(int n){
        f[0] = 0;
        f[1] = 1;

        for(int i=0; i<=n; i++){
            f[i] = f[i-1]+f[i-2];
        }
        return f[n]
    }
    ```

- recerive와 iterative 구현 비교

    - recerive 방식
      - 재귀적 구조는 내부의 시스템 호출 Stack을 사용하는 `Overhead`가 발생
    - iterative 방식
      - 재귀적 구조 보다 성능면에서 보다 효율적
