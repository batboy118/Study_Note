# 13.분할정복 Divide and Conquer

>해결할 문제를 여러개의 작은 부분으로 나눈뒤, 각각의 작은 문제를 해결하고 해결된 결과를 모아 전체 문제를 해결하는 방법이다. 

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./)

---

<!-- TOC -->

- [1. 깊이 우선 탐색 (DFS)](#1-깊이-우선-탐색-dfs)
- [2. 너비 우선 탐색 (BFS)](#2-너비-우선-탐색-bfs)

<!-- /TOC -->

## 1. 분할정복

### 1.1. 분할 정복의 순서

1. 분할 : 해결할 문제를 여러 개의 작은 부분으로 나눔
2. 정복 : 나눈 작은 문제를 각각 해결
3. 통합 : (필요하다면) 해결된 해답을 모음

### 1.2. 거듭제곱 구하기

- 일반적인 거듭 제곱 알고리즘 : `O(n)`

  ```c
  int Power(int base, int exp)
  {
  	int i = 0;
      int result = 1;
      
      for(i = 0; i < exp; i++)
          result = result * base;
      return result;
  }
  ```

- 분할 정복 기반의 알고리즘 : `O(long2n)`

  ```c
  int Power(int base, int exp)
  {
      if(exp == 1) return base;
      else if (base == 0) return 1;
      
      if(exp%2 == 0)
      {
          int newbase = Power(base, exp/2);
          return (newbase * newbase);
      }
      else
      {
          int newbase = Power(base, (exp-1)/2);
          return (newbase * newbase) * base;
      }
  }
  ```

### 1.3. 분할정복을 이용한 정렬 알고리즘

- 분할 정복의 대표적인 정렬 방식으로 `퀵정렬`과 `합병정렬` 이 있다.
  - 가장 큰 차이점은 퀵소트는 합병의 과정이 없다는 점이다.

![image](https://user-images.githubusercontent.com/53181778/77496034-f7f24200-6e41-11ea-9688-c52ac54ddd39.png)

- 퀵 정렬 알고리즘

  - 평균 복잡도 : O(n logn)
  - 최악의 복잡도 : O(n²)

  ```c
  int		partition(int a[], int begin, int end)
  {
  	int pivot = (begin + end) / 2;
      int L = begin;
      int R = end;
      while(L < R)
      {
          while(a[L] < a[pivot] && L < R)
              L = L + 1;
          while(a[R] >= a[pivot] && L < R)
              R = R - 1;
          if(L < R)
          {
              if(L == pivot)
                  pivot = R;
              int temp = a[L];
              a[L] = a[R];
              a[R] = temp;
          }
      }
      int temp = a[pivot];
      a[pivot] = a[R];
      a[R] = temp;
      return (R);
  }
  
  void	quciksort(int a[], int begin, int end)
  {
      if(begin < end)
      {
          int	p = partition(a, begin, end); // 분할과정 : pivot을 기준으로 정렬된 오른쪽 첫 인덱스를 p에 저장
          quciksort(a, begin, p-1);	// 왼쪽 부분 정렬
          quciksort(a, p+1,end);		// 오른쪽 부분 정렬
      }
  }
  ```

  - povit을 기준으로 작은것은 왼쪽 큰것은 오른쪽에 배치하는 방법
  - partition 함수의 L은 pivot 보다 작은 값일 경우, 계속해서 증가하고, R은 pivot보다 크거나 같을 경우 감소한다. 이때, L < R 인 경우 두개의 값을 교환하고 같은 작업을 반복한다.

![img](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F092bb037-1f55-4d52-9424-bc2236d1a73c%2FUntitled.png?table=block&id=c0c791b4-c5c1-4751-9d56-4d39ee68a0d4&width=2890&cache=v2)