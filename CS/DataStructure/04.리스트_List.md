# 04. 리스트 List

> 리스트의 개념에 대해 학습 합니다.

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./README.md)

---

<!-- TOC -->

- [1. 리스트 (List)](#1-리스트-list)
	- [1.1. List란?](#11-list란)
	- [1.2. 종류](#12-종류)
		- [1.2.1. 순차 List](#121-순차-list)
		- [1.2.2. 연결 List](#122-연결-list)
	- [1.3. 연산](#13-연산)
	- [1.4. 구현](#14-구현)
		- [1.4.1. 1차원 배열을 사용한 구현](#141-1차원-배열을-사용한-구현)
		- [1.4.2. 연결 List를 사용한 구현](#142-연결-list를-사용한-구현)
			- [1.4.2.1. 단순 연결 List](#1421-단순-연결-list)
			- [1.4.2.2. 이중 연결 List](#1422-이중-연결-list)
- [2. List의 활용](#2-list의-활용)
	- [2.1. 스택 stack](#21-스택-stack)
		- [2.1.1. push와 pop 연산 구현](#211-push와-pop-연산-구현)

<!-- /TOC -->
## 1. 리스트 (List)

### 1.1. List란?

- 순서를 가진 데이터의 집합을 가리키는 **추상자료형**

- 동일한 데이터를 가지고 있어도 상관 없음

### 1.2. 종류

#### 1.2.1. 순차 List

- 배열 기반
- 논리적인 순서와 물리적인 순서가 같은 구조
- 구현이 간단하며, 인덱스를 이용한 랜덤 액세스가 가능함
- 논리적 순서와 물리적 순서가 동일하기 때문에 삽입, 삭제가 되는 경우 물리적인 순서를 논리적인 순서에 맞추기 위한 데이터의 이동이 필요함(오버헤드 발생)

#### 1.2.2. 연결 List

- 메모리의 동적 할당을 기반
- 각 노드가 구조체 형식으로 되어 있어, 구조체 내부에 다음 노드의 주소를 가리키는 포인터 변수가 존재
- 자료의 논리적인 순서와 메모리 상의 물리적인 순서가 일치하지 않고, 개별적으로 위치하고 있는 원소의주소를 연결하여 하나의 전체적인 자료구조를 이룸
- 각 노드가 물리적인 순서에 구애받지 않기 때문에 삽입과 삭제가 자유로운 편이이다. (오버헤드 발생하지 않음)
- 자료구조의 크기를 동적으로 조정할 수 있어, 메모리의 효율적인 사용이 가능함

### 1.3. 연산

- `addtoFirst()`
  - List의 앞쪽에 원소를 추가하는 연산
- `addtoLAst()`
  - List의 뒤쪽에 원소를 추가하는 연산
- `add()`
  - List의 특정 위치에 원소를 추가하는 연산
- `delete()`
  - List의 특정 위치에 있는 원소를 삭제하는 연산
- `get()`
  - List의 특정 위치에 있는 원소를 리턴하는 연산

### 1.4. 구현

#### 1.4.1. 1차원 배열을 사용한 구현

- 삽입 연산 : 삽입 위치 다음의 항목들을 이동해야 함 ⇒ 시간이 오래 걸림

![image](https://user-images.githubusercontent.com/53181778/77272373-f8a3a080-6ca8-11ea-89b5-6c469f18fcf2.png)

- 삭제 연산 : 삭제 위치 다음의 항목들을 이동해야 함

![image](https://user-images.githubusercontent.com/53181778/77272377-fd685480-6ca8-11ea-8f8d-6d39e68b0273.png)

- 배열의 크기가 고정되어 있어, 실제 사용보다 크게 잡으면 메모리 낭비가 심하고 작게하면 배열을 새로 만들어야하는 경우 발생
- 원소의 개수가 많고 삽입/삭제 연산이 빈번할 수록 작업에 소요되는 시간이 늘어남
-  삽입과 삭제가 적고 데이터의 수가 정해져 있을 경우 유용함

#### 1.4.2. 연결 List를 사용한 구현

- 구현이 배열을 이용한 순차 List 보다 복잡함

- `노드` : 연결 List에서 하나의 원소레 필요한 데이터를 갖고 있는 자료단위

  - 데이터 필드

    원소의 값을 저장하는 자료구조

    저장할 원소의 종류나 크기에 따라 구조를 정의하여 사용

  - 링크 필드

    다음 노드의 주소를 저장하는 자료구조

- `헤드` : List의 처음 노드를 가리키는 자료구조

  - 데이터가 저장되지 않음, 링크 필드만 존재함

    ![image](https://user-images.githubusercontent.com/53181778/77272494-4b7d5800-6ca9-11ea-8e15-923a9024f680.png)

##### 1.4.2.1. 단순 연결 List

- 노드가 하나의 필드에 의해 다음 노드와 연결되는 구조를 가짐

- 헤드가 가장 앞의 노드를 가리키고, 링크 필드가 연속으로 다음 노드를 가리킴

- 최종적으로 Null을 가리키는 노드가 List의 가장 마지막 노드임

  ![image](https://user-images.githubusercontent.com/53181778/77272938-4b318c80-6caa-11ea-9dec-fbfef0f80ed1.png)

- **원소 삽입 과정**
  1. 메모리를 할당하여 새로운 노드 new 생성
  2. 새로운 노드 new의 데이터 필드에 데이터를 저장
  3. 삽입될 위치의 바로 앞에 위치한 노드의 링크 필드를 new에 복사
  4. new의 주소를 앞 노드의 링크 필드에 저장

- **삭제 과정**
  1. 삭제할 노드의 앞 노드(선행노드) 탐색
     - 선행노드를 따로 저장해 두어야 함
  2. 삭제할 노드의 링크 필드(다음 노드의 주소)를 선행노드의 링크 필드에 복사
  3. 삭제할 노드를 삭제

- **검색 연산**
  1. 헤드부터 시작하여 탐색
  2. 노드의 링크 필드가 Null일 때까지 탐색
  3. 노드의 데이터 필드가 검색 데이터와 동일하면 탐색 중지
  4. 해당 노드를 반환

##### 1.4.2.2. 이중 연결 List

- 양쪽 방향으로 순회할 수 잇도록 노드를 연결한 List
- 두 개의 링크 필드와 한 개의 데이터 필드로 구성

![image](https://user-images.githubusercontent.com/53181778/77273670-10305880-6cac-11ea-8347-ba868d26f906.png)

- **노드 삽입 과정**
  1.  메모리를 할당하여 새로운 노드 new 생성
  2. 새로운 노드 new의 데이터 필드에 데이터를 저장
  3. 삽입될 위치의 선행 노드의 next를 삽입될 노드 new의 next에 저장
  4. 삽입할 노드의 prev에 선행 노드의 주소 저장
  5. 삽입될 위치의 선행 노드의 next에 new의 주소를 저장
  6. new의 주소를 다음 노드의 prev에 저장

- **삭제 과정**

1. 삭제할 노드 탐색
2. 삭제할 노드의 앞 노드의 next에 삭제할 노드의 next를 저장
3. 삭제할 노드의 뒷 노드의 prev에 삭제할 노드의 prev를 저장
4. 삭제할 노드를 삭제

## 2. List의 활용

### 2.1. 스택 stack

- Stack내의 순서는 List의 링크를 통해 연결됨

- Push : List의 마지막 노드 삽입

- Pop : List의 마지막 노드 반환/삭제

- 변수 Top : List의 마지막 노드를 가리키는 변수

- 초기 상태 : Top = NULL

- A, B, C를 순서대로 삽입하였을 경우 아래와 같다.

  - 삽입을 앞으로만 한다.
  - 항상 마지막 노드의 다음노드는 Null을 가리킴

  ![image](https://user-images.githubusercontent.com/53181778/77275696-df065700-6cb0-11ea-890b-7659c0c313cf.png)

#### 2.1.1. push와 pop 연산 구현

1. NULL 값을 가지는 노드를 만들어 Stack 초기화

   ![image](https://user-images.githubusercontent.com/53181778/77275835-2ab90080-6cb1-11ea-9002-118e09ffa330.png)

2. push()

   - 새로운 노드를 가장 앞에 삽입하고, top에 새로 추가된 node의 주소 저장

     ![image](https://user-images.githubusercontent.com/53181778/77275844-30164b00-6cb1-11ea-830f-ea9905e79c77.png)

3. pop()
   
   - top에 다음 node의 주소를 저장하고, 가장 첫 노드를 삭제
