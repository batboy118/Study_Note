# 06. 힙 Heap

> 힙의 개념에 대해 학습 합니다.

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./)

---

<!-- TOC -->

- [1. 힙 (Heap)](#1-힙-heap)
	- [1.1. 힙이란?](#11-힙이란)
	- [1.2. 힙의 종류](#12-힙의-종류)
	- [1.3. 힙을 배열로 표현하기](#13-힙을-배열로-표현하기)
	- [1.5. 우선순위 큐](#15-우선순위-큐)
	- [1.5. 최대 힙 만들기](#15-최대-힙-만들기)
	- [1.6. 힙의 삽입 삭제](#16-힙의-삽입-삭제)
		- [1.6.1. 삽입 연산](#161-삽입-연산)
		- [1.6.2. 삭제 연산](#162-삭제-연산)

<!-- /TOC -->

## 1. 힙 (Heap)

### 1.1. 힙이란?

- complete binary tree를 이용한 자료구조

  ⇒ complete binary tree에 있는 노드 중에서 `키값이 가장 큰 노드`나 `키값이 가장 작은 노드`를 찾기 위해서 만든 자료구조로 보통 `우선순위큐`를 구현할 때 사용한다.

- 완전 이진트리의 한 종류로 배열을 시각화함

  ![image](https://user-images.githubusercontent.com/53181778/77606779-69002b00-6f10-11ea-876d-54864e4afc5c.png)

### 1.2. 힙의 종류

- 최대 힙(Max Heap)
  - 키값이 가장 큰 노드를 찾기 위한 Complete binary Tree

  - 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리

    `부모 노드의 키값 >= 자식 노드의 키값`

  - 루트 노드 : 키값이 가장 큰 노드

- 최소 힙(Min Heap)
  - 키값이 가장 작은 노드를 찾기 위한 Complete binary Tree
  - 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리
    `부모 노드의 키값 <= 자식 노드의 키값`
  - 루트 노드 : 키값이 가장 작은 노드

![image](https://user-images.githubusercontent.com/53181778/77607169-62be7e80-6f11-11ea-9bcd-3964f301fd65.png)

### 1.3. 힙을 배열로 표현하기

- 루트 노드 A[1]
- A[i]의 부모노드 = A[i/2]
- A[i]의 왼쪽자식 = A[2*i]
- A[i]의 오른쪽자식 = A[2*i + 1]

### 1.5. 우선순위 큐

- 요소들의 집합 S를 구현하는 자료구조

  - 선입 선출의 구조가 아닌 **우선순위가 높은 순서**대로 큐에서 나가는 자료 구조

    ⇒ 시물레이션, 네트워크 트래픽 제어, 운영체제의 태스크 스케줄링에 사용 됨

  - 배열을 사용하여 우선순위 큐를 구현하면 삭제, 삽입 연산에서 재배치에 시간이 걸림

  - 연결리스트로 우선순위큐를 구현하더라도 비교연산이 많이 발생함

    ⇒ **Heap 자료구조로 우선순위 큐를 구현하여 해결가능**

### 1.5. 최대 힙 만들기

**max_heapify** : 어떤 루트의 서브 트리에서 힙 특성을 위반한 한 가지 값이 제자리를 찾아가도록 만든다.

- 서로 다른 여러개의 힙을 합쳐서 맥스힙을 만들고 싶을 때 사용
- left(i)와 right(i) **서브 트리들이 최대-힙 이라고 가정**하고 사용
- 위에서 아래로 검사
- 만약 요소 A[i]가 최대-힙 특성을 위반한다면, 요소 A[i]를 트리 아래로 흘러 내려가도록 하면서 위반을 수정한다. 인덱스 i의 서브 트리들을 최대-힙으로 만든다. 그리고 수정된 힙을 반환한다.
- log(n)의 복잡도를 가진다.

- i 번째 노드 최대힙 만들기 예시
  - i 번째 노드에 있는 값이 최대힙을 만족할 때 까지 재귀를 호출함

    ```
    Max_Heapify(A,i):
        l = left(i)
        r = right(i)
        if (l <= heap_size(A) and A[l] > A[i])
            then largest = l
        else
            largest = i
        if (r <= heap_size(A) and A[r] > A[largest])
            then largest = r
        if largest != i
            then exchange A[i] and A[largest]
            Max_Heapify(A, largest)
    ```

- **build_max_heap** : 정렬이 안된 힙을 최대힙으로 만드는 연산

  - A[1…n]를 최대-힙으로 변환

    ```
    Build_Max_Heap(A):
        for i=n/2 downto 1
            do Max_Heapify(A, i)
    ```

    n/2부터 시작하는 이유?

    - n/2는 단말노드를 가지는 노드 (단말 노드의 바로 위 노드) 중 가장 끝에 위치한 노드이다. 즉, n/2의 좌우 서브 트리는 max-heap이고, n/2보다 큰 노드는 서브 트리가 존재하지 않기 때문에, 2/n부터 노드 index 줄여 나가면서 Max-Heapify를 호출 하면 전체가 최대 힙이 된다.
      - 2/n+1 ~ n 번째 노드들은 모두 단말 노드이다.
      - i >= n/2 + 1 이면 2i > n가 되기 때문에 서브 트리가 존재 하지 않을 수 있다.

  - 단말 노드는 항상 최대 힙 상태이다.

- Max_Heapify(A, i)가 2/n번 반복되기 때문에 O(nlogn) 복잡도를 가지는 것 처럼보이지만, 사실 분석해보면 O(n) 복잡도를 가진다.

  - 단말 노드 바로 위에 있는 노드들은 Max_Heapify하는 데 O(1) 시간이 걸린다. 일반적으로 단말 노드보다 L단계 위에 있는 노드들은 O(L) 시간이 걸린다.

  - 1단계에서 n/4 노드들을 가지고, 2단계에서 n/8을 가지고, 한 개의 루트 노드만 남을 때까지 계속 이어진다. 마지막은 단말 노드로부터 log n 단계이다.

  - for문에서 하는 전체 일의 양은 다음과 같이 계산된다. (C는 상수)

    n/4 (1 c) + n/8 (2 c) + n/16 (3 c) + … + 1 (lg n c)

  - n/4 = 2^k 라고 가정하면 간단하게 바꿀 수 있다.

    c 2^k( 1/2^0 + 2/2^1 + 3/2^2 + … (k+1)/2^k )

    => 괄호 안의 항은 상수로 수렴. 즉, 2^k만 남고, 2^k는 n/4가 된다.

  - 즉, Build_Max_Heap 의 복잡도는 **O(n)**이다.

- Max-Heap 예시

  ![image](https://user-images.githubusercontent.com/53181778/77612439-0f076180-6f20-11ea-9f32-02136b3dbe9c.png)




### 1.6. 힙의 삽입 삭제

#### 1.6.1. 삽입 연산

1. complete binary tree를 유지 하면서 새로운 노드 공간을 할당함 (순차적으로 노드 생성)
2. 할당된 공간에 key를 임시로 저장
3. 생성된 공간의 부모 노드의 키를 확인해서 삽입할 키가 부모 노드의 키보다 더 크면 키를 바꾸고, 반대의 경우 그자리에 삽입 (반복)

- **17 삽입**

![image](https://user-images.githubusercontent.com/53181778/77285023-fbfa5480-6cc7-11ea-8e76-5ba7f2fa09d2.png)

​	⇒ 19보다 17이 작으므로 그대로 삽입 됨

- **23 삽입**

  1. 비어 있는 곳에 임시로 23을 삽입
  2. 부모 노드와 19와 위치 바꾸기
  3. 부모노드 20과 위치 바꾸기

  ![image](https://user-images.githubusercontent.com/53181778/77285311-98bcf200-6cc8-11ea-863b-fdccde3531e2.png)



  ⇒ 부모노드보다 자식노드가 크기 때문에 순차적으로 올라가고, 더이상 비교할 부모노드가 없으므로 삽입 연산 작업을 마침

#### 1.6.2. 삭제 연산

- Heap에서는 `루트 노드의 원소만을 삭제` 할 수 있다.

  - 루트 노드의 원소만을 삭제하여 반환
  - Heap의 종류에 따라 최대값 또는 최소값을 구할 수 있음

  - **`이름 이용해서 우선순위 큐를 힙으로 구현할 수 있음`**

- 연산 순서
  1. 루트 노드의 원소 삭제(반환)
  2. 마지막 번호의 노드를 루트 노드 위치로 이동
  3. 새로 삽입된 루트 노드와 자식노드 들을 비교하여 가장 큰 값과 교환함
  4. 새로 삽입된 노드의 값이 자리를 잡을 때 까지 반복함

![image](https://user-images.githubusercontent.com/53181778/77286086-762bd880-6cca-11ea-9f00-777b739272c8.png)
