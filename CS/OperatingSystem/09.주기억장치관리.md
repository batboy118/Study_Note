# 09. 주기억장치 관리

> 메모리는 CPU만큼 컴퓨터를 사용하는데 매우 중요한 자원이다. 지금 까지 CPU 관리에 대해서 학습 했다면, 지금 부터는 메모리 관리에 대해서 살펴보자.

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./)

---

<!-- TOC -->

- [1. 메모리 역사](#1-메모리-역사)
- [2. 프로그램을 메모리에 올리기](#2-프로그램을-메모리에-올리기)
- [3. 메모리 낭비 방지](#3-메모리-낭비-방지)
	- [3.1. 동적 적재 (Dynamic Loading)](#31-동적-적재-dynamic-loading)
	- [3.2. 동적 연결 (Dynamic Linking)](#32-동적-연결-dynamic-linking)
	- [3.3. Swapping](#33-swapping)

<!-- /TOC -->

## 1. 메모리 역사

 과거에는 메모리가 매우 비싼 자원으로 용량이 작았기 때문에, 운영체제에서 메모리에 대한 관리가 매우 중요했다.

- 메모리의역사
  - Core memory
  - 진공관 메모리
  - 트랜지스터 메모리
  - 집적회로 메모리: SRAM, DRAM
- 메모리 용량
  - 1970년대: 8-bit PC 64KB
  - 1980년: 16-bit IBM-PC 640KB => 1MB => 4MB
  - 1990년: 수MB => 수십 MB
  - 2000년~: 수백 MB => 수 GB

- 프로그램 변천
  - 기계어/어셈블리어
  - C언어
  - 자바, 객체지향형 언어
  - 숫자 처리 => 문자 처리 => 멀티미디어 처리 => Big data
  - 메모리 용량이 증가해도, 프로그램 크기 또한 증가하기 때문에 메모리의 크기는 언제나 부족하다.
    - 메모리의 낭비를 없애는 방법이 중요하다
    - 가상 메모리(virtual memory)

## 2. 프로그램을 메모리에 올리기

![image](https://user-images.githubusercontent.com/53181778/77520212-c5177080-6e78-11ea-84c5-b7a7f45d7fdf.png)

- 메모리는 주소(address)와 데이터(data)로 구성되어 있다.

  - 각 주소에 데이터가 저장됨

- CPU는 메모리에 address bus를 통해 접근하고, 메모리와 CPU는 데이터를 data bus로 주고 받는다.

  - address bus는 단방향 : CPU → Memory
  - data bus는 양방향 : CPU ↔ Memory

- 프로그램 빌드는 소스 파일, 목적 파일, 실행 파일 순으로 생성 된다.

  - Source file(원천 파일) : 고수준 언어 또는 어셈블리어

  - Object file(목적 파일) : 컴파일 또는 어셈블 결과 (`.o`)

  - Excute file(실행 파일) : 링크 결과

    ![image](https://user-images.githubusercontent.com/53181778/77527978-09107280-6e85-11ea-8438-242bf9f85e83.png)

  - 컴파일 : 컴파일러에 의해 고수준 언어로 작성된 소스파일을 목적파일(기계어)로 변환해 주는 작업
  - 어셈블 : 어셈블러에 의해 어셈블리어로 작성된 파일을 기계어(목적파일)로 변환해 주는 작업
  - 링크 : 링커에 의해 목적파일들과 라이브러리를 링크 시켜 실행파일을 만들어 주는 작업

- 프로그램은 `code`, `data`, `stack` 영역으로 나누어져 있다. 기본적으로 프로그램은 code와 data로 구성 되어있고, 운영체제에 의해 프로그램이 메모리 상으로 올려지면 code와 data영역 이외에 stack 영역을 할당 받게 된다. stack 영역은 지역변수와 함수 호출에 사용된다.

- 실행파일을 메모리에 올리기 위해 운영체제는 프로그램의 메모리 주소를 정해주게 된다.

- 다중 프로그래밍 환경에서는 여러 프로그램이 메모리에 올라가고 내려가고를 반복하기 때문에, 한 프로그램은 고정적인 공간을 사용할 수 없다. 즉, 프로그램이 메모리에 할당될 때 마다 다른 주소공간을 사용하기 때문에 가 별도로 존재한다. 이러한 사항을 해결해주기 위해 `MMU`를 사용한다. MMU내 부에는 `재배치 레지스터(Reloctaion register)`가 존재하는데, 재배치 레지스터를 사용해서 프로그램이 어느 주소를 사용하더라도 실제 메인 메모리에 할당된 주소에 접근 할 수 있도록 **address translation** 동작을 수행한다.

  > 이전에 배웠던 `MMU`(Memory Management Unit)는 메모리 보호를 위해 사용되었다.  `base`와 `limit` 레지스터가 있어 CPU에서 주소에 접근 할 때 해당 주소가 프로그램의 base나 limit 범위를 벗어나면 인터럽트가 발생하여 그 프로그램을 강제로 종료시킨다.

  ![image](https://user-images.githubusercontent.com/53181778/77528951-bc2d9b80-6e86-11ea-8a02-50425011337a.png)

  - 프로그램은 메인 메모리에 해당 주소를 사용할 수 있는지 여부를 생각하지 않고 주소를 사용한다. 해당 프로그램이 사용하는 시작 주소가 0번지라고 할 때, 실제 메인 메모리에서는 할당되는 주소가 유동적이기 때문에 0번지라는 주소를 실제 할당된 주소로 변경해주어야 한다. 이때 재배치 레지스터를 이용한다.

    만약, 프로그램이 메인 메모리 500번지에 할당되어 재배치 레지스터값이 500으로 설정되었다면, CPU에서 프로그램의 0번지를 사용할 때 MMU를 통과하면 재배치 레지스터에 의해 500번지로 변경된다. 그 결과 CPU는 0번지를 사용하는 것으로 알고 있지만, 실제 메모리에서는 MMU에 의해 500번지를 사용하고 있는 것이다.

    CPU에서 다음 접근할 주소를 메모리에서 받을 때 10번지를 받았다면, CPU는 10번지에 접근하지만, MMU의 재배치 레지스터에 의해 실제로는 510번지에 접근하게 된다. (offset : 500)

    즉 , 프로그램의 실제 메모리 주소 공간의 위치를 CPU가 모르더라도 프로그램의 실행에 전혀 문제가 없게 된다.

- 논리 주소와 물리 주소

  MMU에 의해 아래와 같이 주소는 두 가지로 구분된다. CPU에서 사용하는 주소는 **논리 주소(logical address)**라고 하고, 메모리가 사용하는 주소는 **물리 주소(physical address)**라고 한다.

  ![image](https://user-images.githubusercontent.com/53181778/77531071-41667f80-6e8a-11ea-93a1-cf7cc35573bc.png)



## 3. 메모리 낭비 방지

메모리를 효율적으로 사용하기 위해 운영체제는 메모리를 관리한다.

### 3.1. 동적 적재 (Dynamic Loading)

- 프로그램 실행에 반드시 필요한 `루틴/데이터`만 적재하여 메모리 낭비를 줄이는 방법으로, 어떤 부분이 실제 필요한 상황이 되었을 때 해당 부분을 메모리에 올려준다.

  - 프로그램 내의 모든 루틴이 다 사용되는 것이 아니다.

    ex) 오류 처리 : 대부분의 상황에서는 일어나지 않음 → 실제 오류가 발생할 경우 올려주면 된다.

  - 모든 데이터(data)가 다 사용되는 것은 아니다.

    ex) 배열

  - 모든 클래스가 다 사용되는 것은 아니다.

    ex) 자바

> cf) 반대로, 모든 루틴과 데이터를 적재하는 것을 정적 적재(static loading)이라고 한다. 현대 운영체제는 대부분 동적 적재를 사용한다.

### 3.2. 동적 연결 (Dynamic Linking)

- 여러 프로그램에 공통 사용되는 라이브러리

  - 공통 라이브러리 루틴(Library routine)을 메모리에 중복으로 올리는 것은 낭비

  - 라이브러리가 메모리에 바로 적재되는 것을 방지하기 위해, 메모리에 적재 된 후 라이브러리의 링크 작업을 수행한다. 이미 메모리에 적재된 동일한 라이브러리가 있다면, 해당 라이브러리를 메모리에 또 적재하지 않고, 기존에 적재된 라이브러리와 링크된다.
    즉, 오직 하나의 라이브러리 당 하나의 라이브러리 루틴만 메모리에 적재되고, 다른 애플리케이션 실행 시 이 루틴과 연결(link)된다.

    - cf) 정적 연결(static linking) : 처음 부터 라이브러리를 연결하고 모두 메모리에 적재하는 것

  - 이러한 라이브러리를 리눅스에서는 `공유 라이브러리` (Shared library)라 하고,  윈도우에서는 `동적 연결 라이브러리`(Dynamic Linking library : DDL) 이라 한다.

    > 윈도우에서 확장자가 `.DLL`로 되어 있다.
    >
    > 리눅스에서는 확장자가 `.so`로 되어있다. (shared object)

- 예시

  아래의 프로그램1과 프로그램2가 공통으로 `printf`를 사용하고 있다. 두개를 동시에 적재하면 메모리 낭비이기 때문에 하나의 printf를 메모리에 올려 같이 사용하게 된다.

  - 프로그램 1

    ```c
    // P1
    int a = 1;
    int b = 2;
    printf("%d\n", a + b);
    ```

  - 프로그램 2

    ```c
    // P2
    int a = 1;
    int b = 2;
    printf("%d\n", a * b);
    ```

    ![image](https://user-images.githubusercontent.com/53181778/77532895-b38c9380-6e8d-11ea-994e-a87db62eb51d.png)

### 3.3. Swapping

- 메모리에 적재되어 있으나 현재 사용되지 않고 있는 프로세스를 확인하여 메모리에서 내린다.
- 프로세스를 이미지 형태로 만든 후 하드디스크에 위치한 Backing store (= swap device)에 임시 저장다. 메모리에서 Backing store로 가는 것을 **swap-out**, 다시 Backing store에서 메모리로 가는 것을 **swap-in**이라고 한다.

- 프로세스 이미지는 해당 프로그램이 메모리에 적재된 후 실행되면서 데이터를 추가하거나 변경하는 등의 과정을 거쳤기 때문에, 현재 실행중인 데이터의 상태를 가진 프로세스 파일을 이미지라고 부른다.

  > 이미지는 하드디스크에 존재하는 프로그램(실행파일)과는 전혀 다르기 때문에  따로 저장해야한다.

  > swapping 과정으로 인한 프로세스 이미지를 저장하기 위해 하드디스크의 일부분을 분리하여 사용 ( **backing store** 또는 **swap device**)

- Backing store의 크기는 대략 메인 메모리 크기 정도로 예상할 수 있다. 메모리의 모든 프로세스가 쫓겨난다고 해도 메인 메모리 크기를 넘지 않기 때문이다. 메인 메모리 크기가 크지 않은 PC나 스마트폰은 하드디스크의 일부를 backing store로 사용하지만, 메모리 크기가 크다면 따로 하드디스크 자체를 backing store로 사용하는 경우도 있다.

- Swap-out된 프로세스는 다시 swap-in을 할 때, 이전의 메모리 주소 공간이 아닌 `새로운 주소 공간`으로 갈 수도 있다. 이는 해당 프로세스가 backing store에 있는 동안 다른 프로세스가 해당 주소 공간을 사용할 수 있기 때문에다. 하지만 이는 `MMU의 재배치 레지스터`로 인해 어디에 적재되는지 상관없이 정상적으로 수행할 수 있다.

- 현재는 프로세스의 크기가 커지고, 하드디스크는 메인 메모리보다 속도면에서 매우 느리므로 swapping 동작의 오버헤드는 크다고 볼 수 있지만 이로 인해 얻는 이득이 더 많으므로 대부분 운영체제는 이를 사용하고 있고, 속도가 중요한 서버 컴퓨터나 슈퍼 컴퓨터는 backing store를 하드디스크가 아닌 좀 더 빠른 저장 장치를 사용하기도 한다.
