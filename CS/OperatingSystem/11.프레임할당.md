# 11. 프레임 할당 (Allocation of Frames)

> CPU의 사용 효율을 높이기 위해서는, 여러 프로세스에게 프레임을 어떤식으로 할당하는지 정하는 것이 중요한 요소이다. 이번에는 프레임 할당에 대해 학습할 것이다.

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./)

---

<!-- TOC -->

- [1. 쓰레싱 (Thrashing)](#1-쓰레싱-thrashing)
- [2. 동적 할당(Dynamic Allocation)](#2-동적-할당dynamic-allocation)
	- [2.1. Working Set Model](#21-working-set-model)
	- [2.2. Page-Fault Frequency(PFF)](#22-page-fault-frequencypff)
- [3. 페이지 크기 (Page size)](#3-페이지-크기-page-size)
	- [3.1. 페이지 테이블](#31-페이지-테이블)

<!-- /TOC -->

## 1. 쓰레싱 (Thrashing)

일반적으로 메모리에 올라가는 프로세스 개수가 증가할수록 CPU의 이용률은 올라갈 것이라 예상한다. 왜냐하면 프로세스가 많을 수록 CPU의 할 일 역시 증가하기때문이다. 이는 일정 범위까지는 맞는 예상이지만, 그 **범위를 넘어서면 오히려 CPU 이용률이 감소하는 현상**이 나타나는데 이러한 현상을 **쓰레싱** 이라한다.

![image](https://user-images.githubusercontent.com/53181778/77997212-896c2300-731e-11ea-957d-65d6765e4e2f.png)

- CPU utilization (CPU 활용률) vs Degree of multiprogramming  (프로세스의 수)
  - 프로세스 개수 증가 ☞ CPU 이용률 증가
  - 일정 범위를 넘어서면 **CPU 이용률 감소**

- 이유

  프로세스가 많아지게 되면 가상메모리를 사용하게 되면서, page fault가 발생하면서 빈번한 **page in/out**이 발생한다. Disk에 Read/Write(디스크 I/O 작업)를 하는 동안에는 CPU는 놀고 있게 된다.

- 해결 방법

  - Global replacement 보다는 **Local replacement**를 사용하여 해결할 수 있고, 따라서 여러 프로세스들에게 메모리 공간을 어떻게 효율적으로 할당해 주는지가 중요하다. (프로세스당 **충분한/적절한 수의 메모리(프레임) 할당**)

각 프로세스에게 적절한 크기의 메모리를 할당하는 것은 곧 적절한 수의 프레임 할당을 의미하고, 할당 방식은 **동적 할당**과 **정적 할당**으로 나눌수 있다. 하지만, 정적할당은 한계가 존재하기 때문에 **동적할당**을 주로 사용한다.

> 정적 할당(Static Allocation)
>
> - **동일(균등) 할당(Equal Allocation)**: 모든 프로세스에게 똑같은 수의 프레임을 할당한다. 이 방식은 프로세스의 크기가 제 각각이기 때문에 큰 프로세스의 경우에는 매우 비효율적이다.
>
> - **비례 할당(Proportional Allocation)**: 프로세스의 크기에 따라 프레임을 할당한다. 이 방식 역시 단점이 있다. 프로세스 크기가 크더라도 모든 기능을 사용하지 않을 수 있기 때문에 이 방식 또한 비효율적이다.

## 2. 동적 할당(Dynamic Allocation)

동적할당에는 여러가지 방법이 있지만, 대표적으로 두가지 방법이 존재한다.

1. Working set model
2. Page fault frequency

### 2.1.  Working Set Model

어떤 프로세스가 실행 중일 때 CPU가 어느 페이지(프레임)을 사용하는지 확인하면 시간대 별로 **Locality** 성질이 성립한다는 것을 발견할 수 있다.

> 세로 : 메모리 주소
>
> 가로 : 시간

![image](https://user-images.githubusercontent.com/53181778/77998894-55dec800-7321-11ea-8879-a1ea1d7c6543.png)

위 그림은 프로세스가 실행 중일 때 어떤 페이지(프레임)을 사용하는지 표시한 것으로, 특정 시간에는 일정 범위의 페이지를 주로 참조하는 것을 알 수 있다. 이를 통해 특정 시간에 따라 사용하는 페이지의 개수만큼 프레임을 할당해줄 수 있다.

하지만, 이 방법 역시 치명적인 단점이 있다. 프로세스를 미리 수행해봐야 특정 시간대에 어떤 페이지를 사용하는지 알 수 있다는 것이다. 그리고 프로세스를 수행할 때마다 사용하는 기능이 달라질 수 있기 때문에, **Locality**를 이용하는 방법은 비현실적이다.

이를 해결하기 위해 나온 것이 **working set** 이다. working set은 위의 locality의 방식과 유사한데, 미래가 아닌 **과거를 보는 것**이다.

![image](https://user-images.githubusercontent.com/53181778/77998964-6d1db580-7321-11ea-9013-d5e9d3724f6b.png)

위 그림은 working set을 사용하는 모습이다. working set은 **현재 시간에서 일정 시간(△) 이전동안 사용되었던 페이지의 집합**이다. △(델타)는 운영체제 내부에서 정하는 기준에 따라 다르며, 이를 **working set window** 라 한다.

이때, 프로세스에게 working set의 개수만큼 프레임을 할당한다. 만약 현재 시간이 t1이라면 working set = {1, 2, 5, 6, 7}이다. 이 때 working set의 개수는 총 5개이므로 프레임 역시 5개를 할당한다.

### 2.2. Page-Fault Frequency(PFF)

page fault 비율은 프로세스에 할당된 프레임의 수에 **반비례**한다. 즉, 프로세스에 할당된 프레임의 수가 적을수록page fault 비율은 늘어난다.

![image](https://user-images.githubusercontent.com/53181778/77999949-00a3b600-7323-11ea-9bed-6c095f263b77.png)

위 그림의 세로축은 page fault 비율이고, 가로축은 할당된 프레임의 수이다. 여기서 운영체제 내부에서 해당 프로세스의 페이지 부재 횟수를 계속 감시한다. 그러면 위와 같은 그래프처럼 나오게 된다. **상한선(upper bound)과 하한선(lower bound)이 그림과 같이 설정** 되어 있다고 하면, 상한선보다 많은 page fault가 발생하면 프레임을 더 많이 할당해주고, 하한선보다 적게 page fault 가 발생하면 할당된 프레임 개수를 줄여준다.

## 3. 페이지 크기 (Page size)

프로세스를 동일한 크기로 자른 것이 페이지 이다. 현재 페이지의 일반적인 크기는 **4KB ~ 4MB** 이고, 이는 과거에서부터 점점 커져왔고, 현재도 메모리 크기에 따라 증가하고 있다.

페이지 크기에 따라 성능에는 미치는 영향은 다음과 같다.

- **내부단편화**: 페이지 크기가 작을 수록 좋다.
- **Page-in, page-out 시간**: 페이지의 in/out 시간을 결정하는 가장 큰 요인은 하드디스크 기준으로 하드디스크의 헤더가 움직이는 시간이다.(**seek time**) 페이지 크기가 크면 클수록 한 번의 seek time마다 큰 페이지를 읽을 수 있기 때문에, 페이지 부재 빈도가 줄어든다.(데이터를 읽는데 걸리는 시간은  페이지의 크기가 커져도 크게 차이나지 않는다.)
- **페이지 테이블 크기**: 페이지 크기가 클수록 페이지 개수가 줄어들기 때문에 그만큼 페이지 테이블 크기도 줄일 수 있다.
- **Memory resolution(해상도)**: Memory resolution은 페이지 크기 대비 필요한 데이터의 크기이다. 이는 페이지 크기가 작을수록 resolution을 높일 수 있다. 만약 페이지 크기가 크면 다른 필요없는 부분이 있을 확률이 크기 때문이다.
- **Page fault 발생 확률**: Page fault 발생 확률을 줄이려면 페이지 크기가 큰 것이 좋다. 이는 locality 성질과도 관련이 있는데, 대부분 프로세스는 필요한 부분이 일정 범위 이내인 경우가 많으므로 페이지 크기가 클수록 필요한 부분이 있을 확률이 크다.

### 3.1. 페이지 테이블

기본에는 TLB는 별도의 칩에 있었지만, 반도체 기술의 발달로 TLB가 CPU에 내장된 on-chip 형태로 만들어진다.
