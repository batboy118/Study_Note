# 07. 프로세스 동기화

> 프로세스의 동기화 방식에 대한 학습을 한다.

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./)

---

<!-- TOC -->

- 

<!-- /TOC -->

## 1. 프로세스 동기화

- 프로세스 동기화 (=> 현대에는 쓰레드 동기화)

### 1.1. Cooperating process

- **Independent**<두개의 프로세스가 완전히 독립적> `vs` **Cooperating**<두개의 프로세스가 연관이 있음>
  - 메모리에 올라가있는 프로세스 또는 쓰레드가 서로 아무런 관계가 없으면 Independent process
  - 메모리에 올라가있는 프로세스 또는  쓰레드가 서로 관계 있으면 Cooperating process
- `Cooperating process`
  - one that can affect or be affected by other processes executed in the system 
  - 프로세스간 통신: 전자우편, 파일 전송
  - 프로세스간 자원 공유: 메모리 상의 자료들, 데이터베이스 등 
    - 명절 기차표 예약, 대학 온라인 수강신청, 실시간 주식거래 (매표를 하기위해 매표사이트
      (서버)에 접근하여 공통 데이터 베이스에 접근함) 

### 1.2. Process Synchronization (cf. Thread synchronization)

- 어떠한 공유 자원에 동시에 접근하면 데이터 불일치 발생 (Concurrent access to shared data may result in data inconsistency )한다. 이때의 해결책 중 하나가 `Process Synchronizatio`이다.

- Process Synchronization
  - 서로 영향을 주고받는 프로세스간의 `순차적인 실행`으로 데이터의 일관성이 유지되도록 함 (Orderly execution of `cooperating processes` so that data consistency is maintained)

- 예시 : BankAccount Problem (은행계좌문제)
  - 부모님은 은행계좌에 입금하고 자녀는 출금할 경우
  - 입금(deposit)과 출금(withdraw) 은 `독립적`으로 일어난다.
  - 코드 설명
    - main에서 BankAccount클래스의 객체인 b를 생성
    - 부모클래스와 자식클래스에서 동인한 BankAccount b를 이용하여 p와 c 객체를 생성한다. 
    - `p.start()` : 부모 쓰레드를 시작(입금)
    - `c.start()` : 자식 클랙스를 시작(출금)한다.
    - `p.join()` : 부모 쓰레드가 끝날때 멈춰서 기다린다.
    - `c.join()` : 자식 쓰레드가 끝날때 멈춰서 기다린다.

![image](https://user-images.githubusercontent.com/53181778/76824990-94985c80-6810-11ea-8ef3-9eb6b009ed52.png)

- 위 코드의 문제점

  - 입출금 동작이 제대로 이루어 지는지 확인하기 위해, 부모 클래스의 run()함수의 for문이 한번 반복될 때마다 "+"를 출력하도록하고, 자식 클래스의 run()함수의 for문이 한번 반복될 때마다 "-" 출력하게 만들어 준디.

    - 잔액은 0으로 올바르게 출력이 되지만, 쓰레드가 swiching이 되기 때문에 `+`와` -`가 찍히는 타이밍이 실행시킬때 마다 달라져 다를 순서로 찍히게 된다.

    ```java
    // 부모 클래스
    public void run(){
        for(int i = 0, i < 1000; i++)
        {
            System.out.print("+");
    		b.deposit(1000);    
        }
    }
    
    // 자식 클래스
    public void run(){
        for(int i = 0, i < 1000; i++)
        {
            System.out.print("-");
    		b.withdraw(1000);    
        }
    }
    ```

  - 입출금 동작에 시간 지연 추가을 추가하여 현실성을 부여하기 위해, BankAccount 클래스의 입출금 함수에 temp변수를 주고, `+`와 `-`출력도 부모,자식 클래스가 아닌 은행 클래스내부에서 처리해주어 주어 약간의 `지연시간`을 준다.

    - **0원이 출력되지 않고 `잘못된 결과 값`이 나오게 된다.**
  - 이유: **공통변수**(common variable)에 대한 **동시 업데이트**(concurrent update)
      - balance의 값이 update가 완료되지 않은 상황에서, 다른 쓰레드가 실행되고 그 쓰레드에서 balance의 값을 변경해 버렸기 때문에 문제가 발생한다.

      (코드의 줄 단위가 아니라, 컴파일된 어셈블리 레벨에서 context swtich가 일어난다. 즉, 한 줄의 코드 쪼개보면, 여러줄의 어셈블리 단위로 수행이 되는데, 중간에 swich가 돼서 잘못된 결과가 나올 수 있다.)
    
    ```java
    //계좌 클래스
    void deposit(int amount){
        int temp = balance + amount;
        System.out.print("+");
        balance = temp;
    }
    void withdraw(int amount){
        int temp = balance - amount;
        System.out.print("-");
        balance = temp;
}
    ```
    
  - 해결법 : **한번에 한 쓰레드만 업데이트하도록 변경해주어야 함** → `임계구역 문제`

### 1.3. 임계구역 문제 (The Critical-Section Problem)

#### 1.3.1. Critical section(임계 구역)

- In a system consisting of multiple threads, Each thread has a segment of code, called **critical section**, in which the thread may be changing **common** variables, updating a table, writing a file, and so on.

  여러개의 쓰레드로 이루어져 있는 시스템에서, 각각의 쓰레드는 임계 구역이라고 불리는 코드의 영역을 가지고 있다. 임계 구역에서 쓰레드는 공통 변수를 바꾸거나, 테이블을 업데이트하고, 파일을 쓰는 작업을 한다.

  ⇒ 복수의 쓰레드가 `공통자원(변수 등)을 업데이트 하는 부분`이 `임계 구역(Critical Section)`

  ⇒ 은행 계좌 문제에서는 balance에 값을 저장하는 부분이 임계 구역이다.

![image](https://user-images.githubusercontent.com/53181778/76939668-b406b680-68f0-11ea-850b-4fa029d1d155.png)

#### 1.3.2. Critical-Section Problem Solution

- 임계 구역은 아래 3가지를 모두 만족해야 한다.

  1. **Mutual exclusion** (상호배타 조건): 오직 한 쓰레드만 임계 구역에 진입가능하다.

     ex) 은행 계좌 문제에서는 한 쓰레드가 임계 구역(balance를 업데이트 하는 부분)에 들어가 있다면, 다른 쓰레드는 거기에 접근 할 수 없다.

  2. **Progress** (진행 조건): 진입 결정(누가 들어갈지, 지금 들어가도 되는지)은 유한 시간 내에 일어나야 한다.
  3. **Bounded waiting** (유한대기 조건): 임계 구역에 들어가기 위해 대기중인 어떤 쓰레드는 반드시 유효 시간 내에 임계 구역에 들어갈 수 있어야 한다.

- 프로세스/쓰레드 **동기화**
  - OS에서 임계구역 문제 해결해야 한다. 즉, 3가지 임계구역 조건을 만족해야 한다.
  - 프로세스 실행 순서 제어 (프로그래머가 원하는대로 실행순서 제어가 가능해야 한다.)
  - `busy wait` 등 비효율성은 제거

## 2. 동기화 도구(Synchronization Tools)

동기화의 임계구역 문제를 해결하기 위해 아래 도구를 사용한다.

1. Semaphores
2. Monitors

2. Misc

### 2.1. Semaphores (세마포)

- 동기화 문제를 해결하기 위해 만든 도구
  - Semaphores : n. (철도의) 까치발 신호기, 시그널; U (군대의) 수기(手旗) 신호
  - 동기화 문제 해결을 위한 소프트웨어 도구
  - 네덜란드의 Edsger Dijkstra 가 제안

#### 2.1.1. 구조

- `정수형 변수 한개 (value)` + `두 개의 동작 (acquire, **release)`

#### 2.1.2. 동작

- `P` : Proberen (test) → **acquire()**
- `V` : Verhogen (increment) → **release()**

#### 2.1.3. 구조

```java
class Semaphore {
  int value; // number of permits
  Semaphore(int value) {
      ...
  }
  
  void acquire() {
  	value--;
  	if (value < 0) {
  		add this process/thread to list;
  		block;
  	}
  }
  
  void release() {
  	value++;
  	if (value <= 0) {
  		remove a process P from list;
  		wakeup P;
  	}
  }
}
```

- `acquire()` 는 value값을 감소시키고, 만약 value값이 0보다 작으면 이미 해당 `임계구역`에 어느 쓰레드 또는 프로세스가 존재한다는 의미이므로 현재 쓰레드 또는 프로세스를 접근하지 못하도록 막아야한다. `list`라는 `queue`에 추가한 뒤 `block`을 걸어준다.
- `release()` 는 value값을 증가시키고, 만약 value값이 0보다 같거나 작으면 임계구역에 진입하려고 대기하는 프로세스가 `list`에 남아있다는 의미이므로 그 중에서 하나를 꺼내어 임계구역에 접근하게 해주어야 한다.

- Semaphore를 사용하는 CPU의 Queue 구조

  세마포를 그림으로 나타내면 아래와 같다. 

  프로세서에서 프로세스를 처리하다가 프로세스가 임계 구역에 접근하는 경우 `acquire()`함수가 호출 된다. 이때 `value-- `을 해준뒤`value`가 0보다 작은 경우 이미, 임계구역에 접근 중인 프로세스가 있다는 의미 이기 때문에, 현재 프로세스는 세마포 내부에 있는 `큐에 삽입`된 후 블락되어 대기 상태가 된다.  반대로 `value`가 0보다 크면 바로 임계구역에 접근할 수 있기 때문에 큐로 `세마포의 큐`로 가지 않는다.

  임계구역의 접근을 마친 프로세스가 임계구역을 나오면서 `release()`를 호출하게 된다. 이때, `value++`를 해준되 `value`가 0보다 작거나 같으면 `세마포 큐`에 대기중인 프로세스가 있다는 의미이기 때문에, `세마포 큐` 있는 프로세스를 `ready queue`로 보내 서비스를 받게 하여 임계구역에 접근 가능하게 한다.

![image](https://user-images.githubusercontent.com/53181778/76943394-2ed2d000-68f7-11ea-9fd2-9a8afa3e0369.png)

#### 2.1.4. Mutual exclusion

- 일반적으로 세마포는 `상호 배타적 조건`을 만족시키기 위해 사용한다.

- 초기 `value값`은 1이다.

  - sme.value = 1;
  - 1로 해준다면, 가장 초기에 임계 구역에 접근하는 프로세스로 인해 `value = 0`이 될 것이다. 하지만, 0보다 작아지지는 않았기 때문에 최초로 접근한 프로세스는 임계구역에 바로 접근이 가능하고, 그 다음부터 접근되는 프로세스틑 블락된다.

- 임계구역에 접근하기 직접에` acquire()함수`를 호출하고, 접근이 끝나면 `release()함수`를 호출하는 구조로 만들어준다.

  ![image](https://user-images.githubusercontent.com/53181778/76945217-1fa15180-68fa-11ea-8b62-7f41d0d402fc.png)

  1. 어떤 프로세스가 acquire()를 호출하면 `value`는 1에서 0으로 되고, 0 보다 작지 않기 때문에, `세마포 list`에 들어가지 않고 block또한 안된다.

     - 블락이 안되기 때문에 프로세스 진행중 `context switch`가 발생하면 `레디큐`로 들어감

  2. 두번째 프로세스가 임계구역에 접근하여, `acquire()`를 호출하면 `value`가 `-1`이되어 `세마포 list`에 삽입되고 `block`됨

  3. 기존 프로세스가 임계구역 접근을 끝내면, `release()함수`가 호출되면 `value=0`이되고 `list`에서 `block`되어있던 프로세스가 레디큐로 들어감

     ⇒ 크리티컬 섹션은 하나만 접근 가능 다른하나의 접근이 끝나면 그 다음 대기 중인 프로세스/쓰레드가 크리티컬 섹션에 접근 가능

##### 2.1.4.1 예시 (은행 계좌)

- 위에서 보았던, 은행계좌 문제를 세마포를 이용해 해결해 보겠다. 

- 먼저 아래와 같은 구조로 `Parents();`와 `Child();`를 각각 임계 구역으로 설정할 수 있다.

  > sem.acquire();         			   |sem.acquire();
  >
  > Parents (); //크리티컬 섹션   |Child (); //크리티컬 섹션
  >
  > sem.relesase();                      |sem.relesase();

- BankAccount Class

```java
import java.util.concurrent.Semaphore;  // 세마포 사용

class BankAccount {
	int balance;
	Semaphore sem;
    
	BankAccount() {   //BankAccount 객체 생성 시 세마포를 만든다.
		sem = new Semaphore(1);  // value 값을 1로 초기화한다.
	}

	void deposit(int amount) {
		try {
			sem.acquire();   // 임계구역에 들어가기를 요청한다.
		} catch (InterruptedException e) {}
	    // 임계 구역  
		int temp = balance + amount;
		System.out.print("+");
		balance = temp;

		sem.release();   // 임계구역에서 나간다.
	}

	void withdraw(int amount) {
		try {
			sem.acquire();
		} catch (InterruptedException e) {}
	    // 임계 구역 
		int temp = balance - amount;
		System.out.print("-");
		balance = temp;

		sem.release();
	}

	int getBalance() {
		return balance;
	}
}
```

- 이 코드는 임계구역의 문제를 해결하였으므로 몇 번을 수행하여도 같은 결과값이 출력된다.

#### 2.1.5. Ordering

세마포는 `mutual exclusion`뿐 아니라 `ordering`을 하기 위해서도 사용한다. 즉, **프로세스의 실행 순서를 원하는 순서로 설정** 할 수 있다.

- P1이 실행되고 P2가 실행되기를 원한다면, 아래와 같이 만들어 주면된다.

![image](https://user-images.githubusercontent.com/53181778/76949203-1c10c900-6900-11ea-93c4-633eff96183d.png)

- 이 때 `value `의 초기 값은 0이어야 한다.

  - sme.value = 0;

- 실행 순서

  아래를 보면, 실행 순서는 항상 P1이 수행된 후 P2가 수행되는 것을 볼 수 있다.

  - P1이 먼저 실행된 경우

    - 실행이 끝난 뒤, `sem.release()`를 호출하 value를 1로 만들고, `세마포 큐`에 있는 프로세스를 레디큐에 넣어준다. (초기에는 아무것도 없기 때문에 아무런 동작도 하지 않음)
    - P1이 다 끝난 후, P2가 실행되면 `sem.acquire()` 를 만나고 `value`값은 1에서 0이 된다. value = 0이면 block을 하지 않으므로, 그대로 수행된다.

    > 만약, P1이 다 끝나기 전에 P2가 실행이 되어도 `acquire()`함수가 호출되고, `value`는 -1이 되기 때문에 P2는 `세마포 큐`에 들어가 `block`된다.

  - P2가 먼저 실행된 경우
    - `sem.acquire()`함수가 호출되어,  `value`값은 0에서 -1이 된다. value = -1 이기 때문에 `세마포 큐`로 가게되고  `block`된다.
    - P1이 실행되면 Section 1이 바로 수행된다.
    - `sem.release()` 를 만나면` value`값을 0에서 1로 증가시키고, `세마포 큐`에 있는 P2 프로세스를 깨워 `레디큐`로 넣어준다.
    - P2의 Section 2가 수행된다.

# 여기서 부터 시작 ([https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-8.-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-1](https://velog.io/@codemcd/운영체제OS-8.-프로세스-동기화-1))

##### 2.1.5.1 예시 (은행 계좌)

> sem2.acquire();
>
> Parents ();                Child ();        //크리티컬 섹션
>
> sem2.relesase();      sem1.relesase();
>
> sem1.acquire();



항상 입금 먼저 (= Parent 먼저)

입출금 교대로 (P-C-P-C-P-C- …)



### 전통적 동기화 예제

- Producer and Consumer Problem
  - 생산자-소비자 문제
  - 유한버퍼 문제(Bounded Buffer Problem)
- Readers-Writers Problem
  - 공유 데이터베이스 접근
- Dining Philosopher Problem
  - 식사하는 철학자 문제

### Producer-Consumer Problem

- 생산자-소비자 문제

  – 생산자가 데이터를 생산하면 소비자는 그것을 소비

  – 예:

  > 컴파일러 > 어셈블러
  >
  > 파일 서버 > 클라이언트
  >
  > 웹 서버 > 웹 클라이언트

  ![img](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F8cc62aa6-48dc-4563-b162-9531e17909af%2FUntitled.png?table=block&id=8dfeb49c-838d-4d0b-a93a-a23e899ae5e7&width=1290&cache=v2)

  ⇒생산된 결과물을 버퍼에 저장을 하면, 소비자가 버퍼에 저장된 데이터를 빼서 사용함 ⇒ 버퍼 메모리는 유한함(Bounded Buffer)

  

- Bounded Buffer

  – 생산된 데이터는 버퍼에 일단 저장 (속도 차이 등)

  – 현실 시스템에서 버퍼 크기는 유한

  – **생산자는 버퍼가 가득 차면 더 넣을 수 없다.**

  – **소비자는 버퍼가 비면 뺄 수 없다.**

  ![img](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fd6eae59b-c490-4aa4-9479-9c2524cb5237%2FUntitled.png?table=block&id=472b4ed6-7c7b-4167-aa41-8702ae4118fc&width=2730&cache=v2)

  ```java
    //버퍼 클래스
    class Buffer {
    	int[] buf;
    	int size;
    	int count;
    	int in;
    	int out;
    
    	Buffer(int size) {
    			buf = new int[size];
    			this.size = size;
    			count = in = out = 0;
    	}
    
    	////삽입
    	void insert(int item) {
    	/* check if buf is full */
    	while (count == size)
    	;   //아무동작 안함
    	
    	/* buf is not full */
    	buf[in] = item;
    	in = (in+1)%size; //in이 가리키는 위치가 size 만큼되면 다시 0으로
    	count++;
    	}
    	
    	////삭제
    	int remove() {
    	/* check if buf is empty */
    	while (count == 0)
    	;  //아무동작 안함
    	
    	/* buf is not empty */
    	int item = buf[out];
    	out = (out+1)%size;  //out이 가리키는 위치가 size 만큼되면 다시 0으로
    	count--;
    	return item;
    	}
    }
  ```

  ```java
  /****** 생산자 ******/ => 쓰레드
    class Producer extends Thread {
    	Buffer b;
    	int N;
    
    	Producer(Buffer b, int N) {
    		this.b = b; this.N = N;
    	}
    
    	public void run() {
    		for (int i=0; i<N; i++)
    		b.insert(i);
    		}
    }
    
    
    /****** 소비자 ******/ => 쓰레드
    class Consumer extends Thread {
    	Buffer b;
    	int N;
    	Consumer(Buffer b, int N) {
    		this.b = b; this.N = N;
    	}
    	public void run() {
    		int item;
    		for (int i=0; i<N; i++)
    		item = b.remove();
    	}
    }
    
    class Test {
    	public static void main(String[] arg) {
    		Buffer b = new Buffer(100);
    		Producer p = new Producer(b, 10000);
    		Consumer c = new Consumer(b, 10000);
    		p.start();
    		c.start();
    		try {
    			p.join();
    			c.join();
    		} catch (InterruptedException e) {}
    		System.out.println("Number of items in the buf is " + b.count);
    	}
    }
  ```

  ⇒ 잘못된 결과가 나옴

  - 잘못된 결과

    - 실행 불가, 또는 count ≠ 0 (생산된 항목 숫자 ≠ 소비된 항목 숫자)  ← `크리티컬 세션(버퍼의 카운트)에서 동시 업데이트하기 때문`
    - 최종적으로 버퍼 내에는 0 개의 항목이 있어

  - 이유

    - 공통변수 count, buf[] 에 대한 동시 업데이트
    - 공통변수 업데이트 구간(= 임계구역)에 대한 동시 진입

  - 해결법

    - `임계구역에 대한 동시 접근 방지 (상호배타)`

    - 세마포를 사용한 상호배타 (mutual exclusion)

    - 세마포: mutex.value = 1 (# of permit)

      

    ⇒여전히 잘못된 결과

    

  - Busy-wait

    - 생산자: 버퍼가 가득 차면 기다림 = 빈(empty) 공간이 있어야

    - 소비자: 버퍼가 비면 기다림 = 찬(full) 공간이 있어야

      

  - 세마포를 사용한 busy-wait 회피

    - 생산자: empty.acquire() // # of permit = BUF_SIZE

    - 소비자: full.acquire() // # of permit = 0

      ![img](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fc7a0bf87-2180-4e4b-a14b-cdbf60977a8c%2FUntitled.png?table=block&id=58a79ce3-5d64-4b07-bf6f-152d9cc0b3b2&width=970&cache=v2)

  

  ![img](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fcb144e50-7609-4b25-988e-c2791622c5dd%2FUntitled.png?table=block&id=52d28775-2da9-416f-a15f-c42f359f2694&width=2050&cache=v2)

  

  ![img](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F1d38665d-61dd-4ab0-9ae6-80de189f184e%2FUntitled.png?table=block&id=19b9ec8c-9df9-4982-8298-87af6c6f21f6&width=2050&cache=v2)

  

  ![img](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fdf943299-4737-4245-8e96-62c2c2a404b9%2FUntitled.png?table=block&id=75308305-7a58-424d-9573-3b4abb1082ba&width=2050&cache=v2)

![img](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ff19b56ef-3f28-48c8-8ccd-49e93dbda2c3%2FUntitled.png?table=block&id=ddf20b01-cc75-4c05-8dc2-8fda4f099997&width=2050&cache=v2)

![img](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F281739f6-9c7d-430d-97a2-8984abcfedc2%2FUntitled.png?table=block&id=a119da6e-0c9b-4216-bef7-ecfad20b4853&width=2050&cache=v2)