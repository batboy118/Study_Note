# 13. 디스크 스케쥴링 (Disk Scheduling)

> 보조기억장치는 현재 여러 가지 존재하지만 하드 디스크가 아직도 많이 사용된다.

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./README.md)

---

<!-- TOC -->

- [1. 디스크 스케줄링](#1-디스크-스케줄링)
- [2. 디스크 스케줄링 알고리즘](#2-디스크-스케줄링-알고리즘)
	- [2.1. FCFS(First-Come First-Served)](#21-fcfsfirst-come-first-served)
	- [2.2. SSTF(Shortest-Seek-Time-First)](#22-sstfshortest-seek-time-first)
	- [2.3. Scan](#23-scan)
	- [2.4. Scan Variants](#24-scan-variants)
		- [2.4.1. C-Scan](#241-c-scan)
		- [2.4.2. Look](#242-look)
		- [2.4.3. C-Look](#243-c-look)

<!-- /TOC -->

## 1.  디스크 스케줄링

하드 디스크에 접근하는 시간은 **Seek time(탐색 시간)** + rotational delay + transfer time 으로 계산할 수 있는데, 이 중에서 **seek time(head를 움직이는 시간)**이 가장 비중이 크다.

현재 컴퓨터 환경은 대부분 다중 프로그래밍 환경으로, 여러 프로세스가 메인 메모리에서 실행 중인 경우가 많다. 이러한 여러 프로세스들에서 동시에 디스크에 대한 I/O 요청이 생길 수 있다. 그럴 경우 디스크 역시 CPU와 마찬가지로 **디스크 큐(dist queue)**에서 요청들을 줄을 세워 차례대로 이를 처리한다.

디스크를 읽는 시간은 매우 느린 작업이기 때문에, 성능을 최대화 하기 위해 요청들을 효율적인 순서로 처리하여 작업 시간을 줄이는 것이 중요하다. 이러한 방법들을 디스크 스케줄링 알고리즘이라 한다.

## 2.  디스크 스케줄링 알고리즘

### 2.1. FCFS(First-Come First-Served)

스케줄링 알고리즘에서도 존재하는 가장 간단하고 가장 공평한 방법으로, 먼저 요청한 순서대로 서비스를 하는 알고리즘이다.

- 예시

  >`200 cylinder dist` : 0, 1, 2, ..., 199
  >`Disk queue` : 98, 183, 37, 122, 14, 124, 65, 67
  >`현재 헤드가 위치한 실린더(cylinder)`: 53

  ![image](https://user-images.githubusercontent.com/53181778/78218793-e6e2aa00-74ad-11ea-8b5a-6758e34c3bfe.png)

  가로축은 0번부터 199번까지 실린더의 위치를 나타내고, 여기서 파란색 선이 `dist queue`를 FCFS 방법으로 처리할 때 헤드가 이동한 경로를 보여준다. 헤드의 총 이동거리는 아래와 같다.

  > **헤드가 움직인 총 거리** = (98 - 53) + (183 - 98) + (183 - 37) + (122 - 37) + (122 - 14) + (124 - 14) + (124 - 65) + (67 - 65) = **640 cylinders**

  큐에 있는 실린더를 순서대로 접근하게 되면 위치 차이가 많이 발생하는 경우 효율이 떨어지는 것을 확인 할 수 있다.

### 2.2. SSTF(Shortest-Seek-Time-First)

SSTF 스케줄링 알고리즘은 현재의 상태에서 가장 짧은 탐색 시간을 가지는 요청을 먼저 처리하는 것이다. 즉, 현재 헤드가 다음 요청을 처리하기 위해 움직여야 하는 거리가 가장 짧은 것을 선택하는 알고리즘이다.

- 예시

  >`200 cylinder dist` : 0, 1, 2, ..., 199
  >`Disk queue` : 98, 183, 37, 122, 14, 124, 65, 67
  >`현재 헤드가 위치한 실린더(cylinder)`: 53

  ![image](https://user-images.githubusercontent.com/53181778/78218406-42f8fe80-74ad-11ea-8344-d911809fd599.png)

  처음 헤드가 위치한 실린더 53번으로 부터 `dist queue`에 있는 실린더 중 53과 가장 가까운 65번 실린더를 우선 선택한다. 그 다음에는 65번에서는 가장 가까운 67번을 선택한다. 이와 같은 과정을 반복하여 요청들을 처리해 준다.

  > **헤드가 움직인 총 거리** = (65 - 53) + (67 - 65) + (67 - 37) + (37 - 14) + (98 - 14) + (122 - 98) + (124 - 122) + (183 - 124) = **236 cylinders**

  SSTF 스케줄링 알고리즘은 FCFS 스케줄링보다 헤드의 움직임을 최소화 하여 탐색 시간을 줄일 수 있지다.

  하지만, **기아(starvation)**가 발생할 수 있다는 단점이 있다. `dist queue`에는 지속적으로 새로운 프로세스의 요청이 들어오기 때문에 헤드와 멀리 떨어져 있는 실린더에 위치한 데이터에 대한 요청은 서비스를 해주지지 못하는 현상이 발생할 수 있다.

  또한, SSTF 스케줄링이 현재와 가장 가까운 실린더를 선택한다고 해서 **가장 적은 탐색시간을 가지는 최적의 알고리즘은 아니다.** 위 예제에서도 볼 수 있듯이, 처음 53번 실린더에서 65번이 아닌 37번으로 이동한 후 SSTF 알고리즘을 수행하면 **208 cylinders**로 더 효율적인 결과가 나온다.

### 2.3. Scan

Scan 스케줄링은 말그대로 헤드가 한 방향(실린더 번호가 낮아지거나 높아지는)으로 지속적으로 이동하면서 디스크에 접근하는 것이다. 즉, 한방향으로 지속적으로 이동하고, 경계(더이상 이동할 곳이 없는 경우)에 접근하게 되면 다시 반대 방향으로 이동한다.

- 예시

  > `200 cylinder dist` : 0, 1, 2, ..., 199
  > `Disk queue` : 98, 183, 37, 122, 14, 124, 65, 67
  > `현재 헤드가 위치한 실린더(cylinder)`: 53
  >
  > `스캔 방향`: 0번 방향으로 움직임(번호가 작은 실린더 방향)

  ![image](https://user-images.githubusercontent.com/53181778/78219379-ed255600-74ae-11ea-9414-9a7ab9f8054d.png)

  초기 스캔 방향이 0번 실린더 방향이기 때문에, 53번 실린더에서 순차적으로 작은 번호의 실린더로 향한다음 0번 실린더에 도착하게 되면, 반대로 점점 더 큰 번호의 실린더로 움직인다.

  > **헤드가 움직인 총 거리** = (53 - 37) + (37 - 14) + (14 - 0) + (65 - 0) + (67 - 65) + (98 - 67) + (122 - 98) + (124 - 122) + (183 - 124) = **236 cylinders**

  이 방법도 나름 효율적이지만, 일반적으로 프로세스들이 디스크에 요청할 때 그 위치를 살펴보면 실린더에 **골고루 퍼져있다.** 그러므로 Scan 스케줄링 알고리즘처럼 앞뒤로 반복해서 움직이는 것이아니라 처음부터 한 방향으로 끝까지 움직이고 다시 처음 시작점으로 돌아가서 동일한 방향으로 다시 끝까지 움직이는 것이 더욱 효과적이다.

  즉 예를 들면, 바깥 쪽에서 안쪽으로 가면서 서비스 하고, 끝까지 갔으면 다시 가장 바깥으로 한번에 와서 다시 안쪽으로 들어가면서 서비스를 하는 것을 반복한다. 이러한 아이디어에서 나온 것이 **Circular Scan** 스케줄링 알고리즘이다.

### 2.4. Scan Variants

#### 2.4.1. C-Scan

앞서 언급한 Circular Scan 스케줄링 알고리즘이다. 즉 한 방향으로 계속 움직이는 것이 마치 원형으로 움직인 것과 같은 모습 (0 다음에 최대값)이다. 움직이는 거리는 더 길어질 수 있지만 다시 처음 위치로 되돌아갈 때는 데이터를 읽지 않기 때문에 더 빠른 속도로 움직일 수 있다.

![image](https://user-images.githubusercontent.com/53181778/78225234-6a55c880-74b9-11ea-80f1-1fb8d96e4d7b.png)

#### 2.4.2. Look

Scan 알고리즘은 0번 실린더가 존재하지 않지만 0번까지 가게 되지만, 사실 0번 까지 갈 필요가 없는 경우가 많다. 이러한 비효율적인 이동을 없애기 위해 **dist queue에 존재하는 실린더의 최소와 최대 범위**만 움직이는 알고리즘을 Look 스케줄링 알고리즘이라고 한다. 하지만 이 범위를 알기 위해서 미리 큐를 검사해야한다.

#### 2.4.3. C-Look

C-Look은 **Circular Look** 을 말한다. Look은 위에서 Scan 스케줄링이 0번 부터 끝 실린더까지 움직이지 않고 존재하는 실린더의 최소에서 최대 범위를 움직인다고 하였는데, C-Look은 이 범위에서 C-Scan과 같이 한 방향으로만 움직이는 것을 말한다. 즉, 최대 실린더에서 최소 실린더 방향으로 움직인다고 할 때 최소 범위에 도달하면 다시 최대 범위로 되돌아가서 같은 방향으로 움직인다.

> 스캔의 종류
>
> - scan
>
> - c-scan
>
> - look
>
> - c-look

> Elevator Algorithm
>
> Elevator Algorithm은 Scan에서 파생되어 나온 알고리즘(C-scan, Look, C-Look)을 부르는 다른 용어이다. 위 Scan 스케줄링 알고리즘 예제 그림을 90도로 회전하면 엘리베이터의 모습과 유사하여 붙여진 이름이다.
