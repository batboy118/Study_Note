# 08. 프로세스 동기화

> 프로세스의 동기화 방식에 대한 학습을 한다.

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./README.md)

---

<!-- TOC -->

- [1. 프로세스 동기화](#1-프로세스-동기화)
	- [1.1. Cooperating process](#11-cooperating-process)
	- [1.2. Process Synchronization (cf. Thread synchronization)](#12-process-synchronization-cf-thread-synchronization)
	- [1.3. 임계구역 문제 (The Critical-Section Problem)](#13-임계구역-문제-the-critical-section-problem)
		- [1.3.1. Critical section(임계 구역)](#131-critical-section임계-구역)
		- [1.3.2. Critical-Section Problem Solution](#132-critical-section-problem-solution)
- [2. 동기화 도구(Synchronization Tools)](#2-동기화-도구synchronization-tools)
	- [2.1. Semaphores (세마포)](#21-semaphores-세마포)
		- [2.1.1. 구조](#211-구조)
		- [2.1.2. 동작](#212-동작)
		- [2.1.3. 구조](#213-구조)
		- [2.1.4. Mutual exclusion](#214-mutual-exclusion)
			- [2.1.4.1 예시 (은행 계좌)](#2141-예시-은행-계좌)
		- [2.1.5. Ordering](#215-ordering)
			- [2.1.5.1 예시 (은행 계좌)](#2151-예시-은행-계좌)
- [3. 전통적 동기화 예제](#3-전통적-동기화-예제)
	- [3.1. Producer-Consumer Problem](#31-producer-consumer-problem)
		- [3.1.1. Bounded Buffer](#311-bounded-buffer)
		- [3.2.2. Busy-wait](#322-busy-wait)
	- [3.2. Reader-Writers Problem](#32-reader-writers-problem)
	- [3.3. Dining Philosopher Problem](#33-dining-philosopher-problem)
- [4. 교착상태 (Deadlocks)](#4-교착상태-deadlocks)
	- [4.1. 교착상태 필요 조건 (Necessary Conditions)](#41-교착상태-필요-조건-necessary-conditions)
	- [4.2. 자원(Resources)](#42-자원resources)
	- [4.3. 교착상태 처리](#43-교착상태-처리)
		- [4.3.1. 교착상태 방지 (Deadlock Prevention)](#431-교착상태-방지-deadlock-prevention)
		- [4.3.2. 교착상태 회피 (Deadlock Avoidance)](#432-교착상태-회피-deadlock-avoidance)
		- [4.3.3. 교착상태 검출 및 복구 (Deadlock Detection & Recovery)](#433-교착상태-검출-및-복구-deadlock-detection--recovery)
		- [4.3.4. 교착상태 무시](#434-교착상태-무시)
- [5. 모니터 (Monitors)](#5-모니터-monitors)
	- [5.1. 자바 모니터](#51-자바-모니터)
	- [5.2. BankAccount Problem](#52-bankaccount-problem)
		- [5.2.1. Mutual Exclusion](#521-mutual-exclusion)
		- [5.2.2. Ordering](#522-ordering)
	- [5.3. 전통적 동기화 문제](#53-전통적-동기화-문제)
		- [5.3.1. Producer-Consumer Problem](#531-producer-consumer-problem)
		- [5.3.2 The Dining Philosopher Problem](#532-the-dining-philosopher-problem)

<!-- /TOC -->

## 1. 프로세스 동기화

- 프로세스 동기화 (=> 현대에는 쓰레드 동기화)

### 1.1. Cooperating process

- **Independent**<두개의 프로세스가 완전히 독립적> `vs` **Cooperating**<두개의 프로세스가 연관이 있음>
  - 메모리에 올라가있는 프로세스 또는 쓰레드가 서로 아무런 관계가 없으면 Independent process
  - 메모리에 올라가있는 프로세스 또는  쓰레드가 서로 관계 있으면 Cooperating process
- `Cooperating process`
  - one that can affect or be affected by other processes executed in the system
  - 프로세스간 통신: 전자우편, 파일 전송
  - 프로세스간 자원 공유: 메모리 상의 자료들, 데이터베이스 등
    - 명절 기차표 예약, 대학 온라인 수강신청, 실시간 주식거래 (매표를 하기위해 매표사이트
      (서버)에 접근하여 공통 데이터 베이스에 접근함)

### 1.2. Process Synchronization (cf. Thread synchronization)

- 어떠한 공유 자원에 동시에 접근하면 데이터 불일치 발생 (Concurrent access to shared data may result in data inconsistency )한다. 이때의 해결책 중 하나가 `Process Synchronizatio`이다.

- Process Synchronization
  - 서로 영향을 주고받는 프로세스간의 `순차적인 실행`으로 데이터의 일관성이 유지되도록 함 (Orderly execution of `cooperating processes` so that data consistency is maintained)

- 예시 : BankAccount Problem (은행계좌문제)
  - 부모님은 은행계좌에 입금하고 자녀는 출금할 경우
  - 입금(deposit)과 출금(withdraw) 은 `독립적`으로 일어난다.
  - 코드 설명
    - main에서 BankAccount클래스의 객체인 b를 생성
    - 부모클래스와 자식클래스에서 동인한 BankAccount b를 이용하여 p와 c 객체를 생성한다.
    - `p.start()` : 부모 쓰레드를 시작(입금)
    - `c.start()` : 자식 클랙스를 시작(출금)한다.
    - `p.join()` : 부모 쓰레드가 끝날때까지 멈춰서 기다린다.
    - `c.join()` : 자식 쓰레드가 끝날때까지 멈춰서 기다린다.

![image](https://user-images.githubusercontent.com/53181778/76824990-94985c80-6810-11ea-8ef3-9eb6b009ed52.png)

- 위 코드의 문제점

  - 입출금 동작이 제대로 이루어 지는지 확인하기 위해, 부모 클래스의 run()함수의 for문이 한번 반복될 때마다 "+"를 출력하도록하고, 자식 클래스의 run()함수의 for문이 한번 반복될 때마다 "-" 출력하게 만들어 준디.

    - 잔액은 0으로 올바르게 출력이 되지만, 쓰레드가 swiching이 되기 때문에 `+`와` -`가 찍히는 타이밍이 실행시킬때 마다 달라져 다를 순서로 찍히게 된다.

    ```java
    // 부모 클래스
    public void run(){
        for(int i = 0, i < 1000; i++)
        {
            System.out.print("+");
    		b.deposit(1000);
        }
    }

    // 자식 클래스
    public void run(){
        for(int i = 0, i < 1000; i++)
        {
            System.out.print("-");
    		b.withdraw(1000);
        }
    }
    ```

  - 입출금 동작에 시간 지연 추가을 추가하여 현실성을 부여하기 위해, BankAccount 클래스의 입출금 함수에 temp변수를 주고, `+`와 `-`출력도 부모,자식 클래스가 아닌 은행 클래스내부에서 처리해주어 주어 약간의 `지연시간`을 준다.

    - **0원이 출력되지 않고 `잘못된 결과 값`이 나오게 된다.**

  - 이유: **공통변수**(common variable)에 대한 **동시 업데이트**(concurrent update)

    - balance의 값이 update가 완료되지 않은 상황에서, 다른 쓰레드가 실행되고 그 쓰레드에서 balance의 값을 변경해 버렸기 때문에 문제가 발생한다.

    (코드의 줄 단위가 아니라, 컴파일된 어셈블리 레벨에서 context swtich가 일어난다. 즉, 한 줄의 코드 쪼개보면, 여러줄의 어셈블리 단위로 수행이 되는데, 중간에 swich가 돼서 잘못된 결과가 나올 수 있다.)

    ```java
    //계좌 클래스
    void deposit(int amount){
        int temp = balance + amount;
        System.out.print("+");
        balance = temp;
    }
    void withdraw(int amount){
        int temp = balance - amount;
        System.out.print("-");
        balance = temp;
    }
    ```

  - 해결법 : **한번에 한 쓰레드만 업데이트하도록 변경해주어야 함** → `임계구역 문제`

### 1.3. 임계구역 문제 (The Critical-Section Problem)

#### 1.3.1. Critical section(임계 구역)

- In a system consisting of multiple threads, Each thread has a segment of code, called **critical section**, in which the thread may be changing **common** variables, updating a table, writing a file, and so on.

  여러개의 쓰레드로 이루어져 있는 시스템에서, 각각의 쓰레드는 임계 구역이라고 불리는 코드의 영역을 가지고 있다. 임계 구역에서 쓰레드는 공통 변수를 바꾸거나, 테이블을 업데이트하고, 파일을 쓰는 작업을 한다.

  ⇒ 복수의 쓰레드가 `공통자원(변수 등)을 업데이트 하는 부분`이 `임계 구역(Critical Section)`

  ⇒ 은행 계좌 문제에서는 balance에 값을 저장하는 부분이 임계 구역이다.

![image](https://user-images.githubusercontent.com/53181778/76939668-b406b680-68f0-11ea-850b-4fa029d1d155.png)

#### 1.3.2. Critical-Section Problem Solution

- 임계 구역은 아래 3가지를 모두 만족해야 한다.

  1. **Mutual exclusion** (상호배타 조건): 오직 한 쓰레드만 임계 구역에 진입가능하다.

     ex) 은행 계좌 문제에서는 한 쓰레드가 임계 구역(balance를 업데이트 하는 부분)에 들어가 있다면, 다른 쓰레드는 거기에 접근 할 수 없다.

  2. **Progress** (진행 조건): 진입 결정(누가 들어갈지, 지금 들어가도 되는지)은 유한 시간 내에 일어나야 한다.

  3. **Bounded waiting** (유한대기 조건): 임계 구역에 들어가기 위해 대기중인 어떤 쓰레드는 반드시 유효 시간 내에 임계 구역에 들어갈 수 있어야 한다.

- 프로세스/쓰레드 **동기화**

  - OS에서 임계구역 문제 해결해야 한다. 즉, 3가지 임계구역 조건을 만족해야 한다.
  - 프로세스 실행 순서 제어 (프로그래머가 원하는대로 실행순서 제어가 가능해야 한다.)
  - `busy wait` 등 비효율성은 제거

## 2. 동기화 도구(Synchronization Tools)

동기화의 임계구역 문제를 해결하기 위해 아래 도구를 사용한다.

1. Semaphores
2. Monitors

3. Misc

### 2.1. Semaphores (세마포)

- 동기화 문제를 해결하기 위해 만든 도구
  - Semaphores : n. (철도의) 까치발 신호기, 시그널; U (군대의) 수기(手旗) 신호
  - 동기화 문제 해결을 위한 소프트웨어 도구
  - 네덜란드의 Edsger Dijkstra 가 제안

#### 2.1.1. 구조

- `정수형 변수 한개 (value)` + `두 개의 동작 (acquire, **release)`

#### 2.1.2. 동작

- `P` : Proberen (test) → **acquire()**
- `V` : Verhogen (increment) → **release()**

#### 2.1.3. 구조

```java
class Semaphore {
  int value; // number of permits
  Semaphore(int value) {
      ...
  }

  void acquire() {
  	value--;
  	if (value < 0) {
  		add this process/thread to list;
  		block;
  	}
  }

  void release() {
  	value++;
  	if (value <= 0) {
  		remove a process P from list;
  		wakeup P;
  	}
  }
}
```

- `acquire()` 는 value값을 감소시키고, 만약 value값이 0보다 작으면 이미 해당 `임계구역`에 어느 쓰레드 또는 프로세스가 존재한다는 의미이므로 현재 쓰레드 또는 프로세스를 접근하지 못하도록 막아야한다. `list`라는 `queue`에 추가한 뒤 `block`을 걸어준다.

- `release()` 는 value값을 증가시키고, 만약 value값이 0보다 같거나 작으면 임계구역에 진입하려고 대기하는 프로세스가 `list`에 남아있다는 의미이므로 그 중에서 하나를 꺼내어 임계구역에 접근하게 해주어야 한다.

- Semaphore를 사용하는 CPU의 Queue 구조

  세마포를 그림으로 나타내면 아래와 같다.

  프로세서에서 프로세스를 처리하다가 프로세스가 임계 구역에 접근하는 경우 `acquire()`함수가 호출 된다. 이때 `value-- `을 해준뒤`value`가 0보다 작은 경우 이미, 임계구역에 접근 중인 프로세스가 있다는 의미 이기 때문에, 현재 프로세스는 세마포 내부에 있는 `큐에 삽입`된 후 블락되어 대기 상태가 된다.  반대로 `value`가 0보다 크면 바로 임계구역에 접근할 수 있기 때문에 큐로 `세마포의 큐`로 가지 않는다.

  임계구역의 접근을 마친 프로세스가 임계구역을 나오면서 `release()`를 호출하게 된다. 이때, `value++`를 해준되 `value`가 0보다 작거나 같으면 `세마포 큐`에 대기중인 프로세스가 있다는 의미이기 때문에, `세마포 큐` 있는 프로세스를 `ready queue`로 보내 서비스를 받게 하여 임계구역에 접근 가능하게 한다.

![image](https://user-images.githubusercontent.com/53181778/76943394-2ed2d000-68f7-11ea-9fd2-9a8afa3e0369.png)

#### 2.1.4. Mutual exclusion

- 일반적으로 세마포는 `상호 배타적 조건`을 만족시키기 위해 사용한다.

- 초기 `value값`은 1이다.

  - sme.value = 1;
  - 1로 해준다면, 가장 초기에 임계 구역에 접근하는 프로세스로 인해 `value = 0`이 될 것이다. 하지만, 0보다 작아지지는 않았기 때문에 최초로 접근한 프로세스는 임계구역에 바로 접근이 가능하고, 그 다음부터 접근되는 프로세스틑 블락된다.

- 임계구역에 접근하기 직접에` acquire()함수`를 호출하고, 접근이 끝나면 `release()함수`를 호출하는 구조로 만들어준다.

  ![image](https://user-images.githubusercontent.com/53181778/76945217-1fa15180-68fa-11ea-8b62-7f41d0d402fc.png)

  1. 어떤 프로세스가 acquire()를 호출하면 `value`는 1에서 0으로 되고, 0 보다 작지 않기 때문에, `세마포 list`에 들어가지 않고 block또한 안된다.

     - 블락이 안되기 때문에 프로세스 진행중 `context switch`가 발생하면 `레디큐`로 들어감

  2. 두번째 프로세스가 임계구역에 접근하여, `acquire()`를 호출하면 `value`가 `-1`이되어 `세마포 list`에 삽입되고 `block`됨

  3. 기존 프로세스가 임계구역 접근을 끝내면, `release()함수`가 호출되면 `value=0`이되고 `list`에서 `block`되어있던 프로세스가 레디큐로 들어감

     ⇒ 크리티컬 섹션은 하나만 접근 가능 다른하나의 접근이 끝나면 그 다음 대기 중인 프로세스/쓰레드가 크리티컬 섹션에 접근 가능

##### 2.1.4.1 예시 (은행 계좌)

- 위에서 보았던, 은행계좌 문제를 세마포를 이용해 해결해 보겠다.

- 먼저 아래와 같은 구조로 `Parents();`와 `Child();`를 각각 임계 구역으로 설정할 수 있다.

  > sem.acquire();         			   |sem.acquire();
  >
  > Parents (); //크리티컬 섹션   |Child (); //크리티컬 섹션
  >
  > sem.relesase();                      |sem.relesase();

- BankAccount Class

```java
import java.util.concurrent.Semaphore;  // 세마포 사용

class BankAccount {
	int balance;
	Semaphore sem;

	BankAccount() {   //BankAccount 객체 생성 시 세마포를 만든다.
		sem = new Semaphore(1);  // value 값을 1로 초기화한다.
	}

	void deposit(int amount) {
		try {
			sem.acquire();   // 임계구역에 들어가기를 요청한다.
		} catch (InterruptedException e) {}
	    // 임계 구역
		int temp = balance + amount;
		System.out.print("+");
		balance = temp;

		sem.release();   // 임계구역에서 나간다.
	}

	void withdraw(int amount) {
		try {
			sem.acquire();
		} catch (InterruptedException e) {}
	    // 임계 구역
		int temp = balance - amount;
		System.out.print("-");
		balance = temp;

		sem.release();
	}

	int getBalance() {
		return balance;
	}
}
```

- 이 코드는 임계구역의 문제를 해결하였으므로 몇 번을 수행하여도 같은 결과값이 출력된다.

#### 2.1.5. Ordering

세마포는 `mutual exclusion`뿐 아니라 `ordering`을 하기 위해서도 사용한다. 즉, **프로세스의 실행 순서를 원하는 순서로 설정** 할 수 있다.

- P1이 실행되고 P2가 실행되기를 원한다면, 아래와 같이 만들어 주면된다.

![image](https://user-images.githubusercontent.com/53181778/76949203-1c10c900-6900-11ea-93c4-633eff96183d.png)

- 이 때 `value `의 초기 값은 0이어야 한다.

  - sme.value = 0;

- 실행 순서

  아래를 보면, 실행 순서는 항상 P1이 수행된 후 P2가 수행되는 것을 볼 수 있다.

  - P1이 먼저 실행된 경우

    - 실행이 끝난 뒤, `sem.release()`를 호출하 value를 1로 만들고, `세마포 큐`에 있는 프로세스를 레디큐에 넣어준다. (초기에는 아무것도 없기 때문에 아무런 동작도 하지 않음)
    - P1이 다 끝난 후, P2가 실행되면 `sem.acquire()` 를 만나고 `value`값은 1에서 0이 된다. value = 0이면 block을 하지 않으므로, 그대로 수행된다.

    > 만약, P1이 다 끝나기 전에 P2가 실행이 되어도 `acquire()`함수가 호출되고, `value`는 -1이 되기 때문에 P2는 `세마포 큐`에 들어가 `block`된다.

  - P2가 먼저 실행된 경우

    - `sem.acquire()`함수가 호출되어,  `value`값은 0에서 -1이 된다. value = -1 이기 때문에 `세마포 큐`로 가게되고  `block`된다.
    - P1이 실행되면 Section 1이 바로 수행된다.
    - `sem.release()` 를 만나면` value`값을 0에서 1로 증가시키고, `세마포 큐`에 있는 P2 프로세스를 깨워 `레디큐`로 넣어준다.
    - P2의 Section 2가 수행된다.

##### 2.1.5.1 예시 (은행 계좌)

```java
class BankAccount {
	int balance;

	Semaphore sem, semOrder;
	BankAccount() {
		sem = new Semaphore(1);
		semOrder = new Semaphore(0);   // Ordeing 관리 세마포
	}

	void deposit(int amount) {
		try {
			sem.acquire();
		} catch (InterruptedException e) {}
		int temp = balance + amount;
		System.out.print("+");
		balance = temp;
		sem.release();
		semOrder.release();   // block된 출금 프로세스가 있다면 깨움
	}
	void withdraw(int amount) {
		try {
			semOrder.acquire();   // 출금을 먼저하려고 하면 block
			sem.acquire();
		} catch (InterruptedException e) {}
		int temp = balance - amount;
		System.out.print("-");
		balance = temp;
		sem.release();
	}
	int getBalance() {
		return balance;
	}
}
```

+(입금)가 맨 앞에서 실행된다.

만약, 입금, 출금, 입금, 출금, ... 교대로 출력하도록 하려면 세마포를 두 개 사용하여 아래와 같이 구현할 수 있다.

```java
Semaphore sem, semDeposit, semWithraw;
BankAccount() {
	sem = new Semaphore(1);
	semDeposit = new Semaphore(0);
	semWithraw = new Semaphore(0);
}

void deposit(int amount) {
	try {
		sem.acquire();
		int temp = balance + amount;
		System.out.print("+");
		balance = temp;
		sem.release();
		semWithraw.release();
		semDeposit.acquire();   // 입금후에는 반드시 출금을 해야 하므로 자신을 block
	} catch (InterruptedException e) {}
}
void withdraw(int amount) {
	try {
		semWithraw.acquire();  // 입금보다 먼저 수행하는 것을 막음
		sem.acquire();
	} catch (InterruptedException e) {}
	int temp = balance - amount;
	System.out.print("-");
	balance = temp;
	sem.release();
	semDeposit.release();  // 출금 수행이 완료되면 block되었던 입금 프로세스를 깨워줌
}
int getBalance() {
	return balance;
}
```

- 항상 입금 먼저 (= Parent 먼저)

- 입출금 교대로 동작 (P-C-P-C-P-C- …)



## 3. 전통적 동기화 예제

- Producer and Consumer Problem
  - 생산자-소비자 문제
  - 유한버퍼 문제(Bounded Buffer Problem)
- Readers-Writers Problem
  - 공유 데이터베이스 접근
- Dining Philosopher Problem
  - 식사하는 철학자 문제

### 3.1. Producer-Consumer Problem

- 생산자-소비자 문제

  - 생산자가 `데이터를 생산`하면 소비자는 그것을 `소비`

  - 예:

    > 1. 컴파일러 > 어셈블러
    >
    >    컴파일러가 하이레벨 코드를 어셈블리 코드를 번역하여 제공하면, 어셈블러가 어셈블리 코드를 이용하여 기계어로 번역
    >
    > 2. 파일 서버 > 클라이언트
    >
    > 3. 웹 서버 > 웹 클라이언트
    >
    >    서버에서 정보를 제공하면, 클라이언트가 정보를 이용함

  ![image](https://user-images.githubusercontent.com/53181778/77045771-c567c580-69b9-11ea-836a-b0522e1cd111.png)

  - 생산된 결과물을 `버퍼에 저장`하면, 소비자가 버퍼에 저장된 데이터를 빼서 사용함 ⇒ 버퍼 메모리는 `유한`함(`Bounded Buffer`)

#### 3.1.1. Bounded Buffer

– 생산된 데이터는 버퍼에 일단 저장 (속도 차이 등)

– 현실 시스템에서 버퍼 크기는 유한

– **생산자는 버퍼가 가득 차면 더 넣을 수 없다.**

– **소비자는 버퍼가 비어 있으면 뺄 수 없다.**

![image](https://user-images.githubusercontent.com/53181778/77045928-03fd8000-69ba-11ea-992c-4fa3f33aee9a.png)

```java
//버퍼 클래스
class Buffer {
    int[] buf;
    int size;
    int count;
    int in;
    int out;

    Buffer(int size) {
        buf = new int[size];
        this.size = size      //버퍼의 사이즈
        count = in = out = 0;
    }

    void insert(int item) {
        /* check if buf is full */
        while (count == size)
            ;   //버퍼가 가득차면 insert는 루프를 돌면서 가만히 있는다.
        /* buf is not full */
        buf[in] = item;	// in의 위치에 item 저장
        in = (in+1)%size; //in이 가리키는 위치가 size 만큼되면 다시 0으로
        count++;
    }

    int remove() {
        /* check if buf is empty */
        while (count == 0)
            ;  //버퍼가 비어 있으면 remover는 루프를 돌면서 가만히 있는다.
        /* buf is not empty */
        int item = buf[out]; // out의 위치에 있는 값을 빼옴
        out = (out+1)%size;  //out이 가리키는 위치가 size 만큼되면 다시 0으로
        count--;
        return item;
    }
}
```

- 버퍼는 `circular buffer`로 동작한다. () `in = (in+1)%size;`, `out = (out+1)%size;`)

```java
/****** 생산자 (쓰레드) ******/
class Producer extends Thread {
    Buffer b;
    int N;

    Producer(Buffer b, int N) {
        this.b = b; this.N = N;
    }

    public void run() {
        for (int i=0; i<N; i++)
            b.insert(i);
    }
}

/****** 소비자 (쓰레드)******/
class Consumer extends Thread {
    Buffer b;
    int N;

    Consumer(Buffer b, int N) {
        this.b = b; this.N = N;
    }

    public void run() {
        int item;
        for (int i=0; i<N; i++)
            item = b.remove();
    }
}

class Test {
    public static void main(String[] arg) {
        Buffer b = new Buffer(100);
        Producer p = new Producer(b, 10000);
        Consumer c = new Consumer(b, 10000);
        p.start();
        c.start();
        try {
            p.join();
            c.join();
        } catch (InterruptedException e) {}
        System.out.println("Number of items in the buf is " + b.count);
    }
}
```

**⇒ 잘못된 결과가 나옴**

- 잘못된 결과

  - 실행 불가(무한 루프), 또는 `count ≠ 0` (생산된 항목 숫자 ≠ 소비된 항목 숫자)
- 이유
  - 공통변수 `count`, `buf[]` 에 대한 동시 업데이트
  - 공통변수 업데이트 구간(= `임계구역`)에 대한 동시 진입
- 해결법

  - `임계구역에 대한 동시 접근 방지 (상호배타)`
- 세마포를 사용한 상호배타 (mutual exclusion)
  - 세마포: mutex.value = 1 (# of permit)
- 세마포 적용 코드

```java
class Buffer {
    int[] buf;
    int size;
    int count;
    int in;
    int out;
    Semaphore mutex;   // mutex(mutual exclusion)세마포 선언

    Buffer(int size) {
        buf = new int[size];
        this.size = size;
        count = in = out = 0;
        mutex = new Semaphore(1);
    }

    void insert(int item) {
        /* check if buf is full */
        while (count == size)
            ;
        /* buf is not full */
        try {
            mutex.acquire();  // 임계 구역 진입
            buf[in] = item;
            in = (in+1)%size;
            count++;
            mutex.release();  // 임계 구역 탈출
        } catch(InterruptedException e) {}
    }

    int remove() {
        /* check if buf is empty */
        while (count == 0)
            ;
        /* buf is not empty */
        try {
            mutex.acquire();   // 임계 구역 진입
            int item = buf[out];
            out = (out+1)%size;
            count--;
            mutex.release();   // 임계 구역 탈출
            return item;
        } catch(InterruptedException e) {}
        return -1;
    }
}
```

- mutual exclusion을 위해` insert()`, `remove()`에 세마포를 추가해 결과는 제대로 나오게 되었다. 하지만 **busy waiting**의 문제가 발생한다.

#### 3.2.2. Busy-wait

- 특정 조건을 만족하지 않으면 계속해서 대기하는 상태

  - 생산자: 버퍼가 가득 차면 기다림 = 빈(empty) 공간이 있어야 다음 작업을 함
  - 소비자: 버퍼가 비면 기다림 = 찬(full) 공간이 있어야 다음 작업을 함

- 이는 아무일도 하지 않으면서 CPU를 점유 하고 있기 때문에 `비효율적인 방법`이다.

- `세마포`를 사용한 `busy-wait 회피`

  - 반복문 대신, 세마포 큐에서 block된 상태로 두는 방법이다. (실행되지 않음)

  - 생산자: `empty.acquire()` // # of permit = BUF_SIZE

  - 소비자: `full.acquire()` // # of permit = 0

    ![image](https://user-images.githubusercontent.com/53181778/77051352-0c0ded80-69c3-11ea-88c2-016a1a558300.png)

  ```java
  class Buffer {
      int[] buf;
      int size;
      int in;
      int out;
      Semaphore mutex, full, empty;

      Buffer(int size) {
          buf = new int[size];
          this.size = size;
          in = out = 0;
          mutex = new Semaphore(1);
          full = new Semaphore(0);      // 0을 초기 값으로 준다.
          empty = new Semaphore(size);  // 버퍼 사이즈 만큼 초기 값을 준다.
      }

      void insert(int item) {
          try {
              empty.acquire();    //버퍼의 비어있는 공간을 1 감소시킨다.(비어있는 공간이 없으면 block)
              mutex.acquire();
              buf[in] = item;
              in = (in+1)%size;
              mutex.release();
              full.release();    // 버퍼의 찬 공간을 1 증가시키고, 블락된 소비자가 있다면 깨워준다.
          } catch(InterruptedException e) {}
      }

      int remove() {
          try {
              full.acquire();    // 버퍼의 찬 공간을 1 감소시킨다.(버퍼가 모두 비어있으면 block)
              mutex.acquire();
              int item = buf[out];
              out = (out+1)%size;
              mutex.release();
              empty.release();   // 버퍼의 비어있는 공간을 1 증가시키고, 블락된 생산자가 있다면 깨워준다.
              return item;
          } catch(InterruptedException e) {}
          return -1;
      }
  }
  ```

- busy waiting을 없애기 위해 두 개의 세마포를 더 추가해주고, count 변수는 제거해 주었다.

  - `empty`: 버퍼에서 비어있는 공간의 개수(초기값 size)
  - `full`: 버퍼에서 차있는 공간의 개수(초기값 0)

  empty는 초기화할 때 버퍼는 모두 비어있으므로 버퍼의 크기로 초기화하고 full은 초기 버퍼에는 아무런 데이터가 없으므로 0으로 초기화한다.

  데이터를 버퍼에 넣기 전에 비어있는 공간이 있는지 `empty.acquire();`를 호출하여 확인한다. 없다면` empty세마포`의` value값`이 `-1`이 되므로 `block`이 되고, 있다면 임계구역 내부로 진입하여 데이터를 생성한다. 생성이 완료되면 `full.release();`를 호출하여 `full세마포`의 value값을 1 증가시킨다.(소비자는 반대로 동작한다. 코드를 참고하면 쉽게 이해할 수 있을 것이다.)

### 3.2. Reader-Writers Problem

Readers-Writers 문제는 대표적으로 `공통 데이터베이스`에 접근하는 경우가 있다. 하나의 데이터베이스에 `여러 프로세스(readers, writers)`가 접근하고, 이때 데이터베이스를 `임계구역`으로 설정 하면된다. 하지만, 한 번에 한 개의 프로세스만 접근가능하도록 하는 것은매우 비효율적이다.

- 공통 데이터베이스에 접근하는 프로세스
  - Readers : `read data`   (값을 수정하지 않음)
  - Writers : `read data` and `modifiy it` (값을 수정함)
- 상호배타: 한 번에 한 개의 프로세스만 접근 ☞ 비효율적
- 해결법
  - 데이터 베이스에서 읽기와 쓰기 작업은 `임계 구역`에서 발생해야 한다.
  - `Writer`에 대해서 mutual exclusion을 보장해야 한다.
  - 한번에 여러 `Reader`가 데이터 베이스에 접근할 수 있다.
- 우선순위에 따른 경우
  - **The first R/W problem** (`readers`-preference)
    - `reader`프로세스가 우선권을 가지는 방법으로, `reader`프로세스가 데이터베이스에 접근해 있는 동안에는 `Writer`프로세스가 접근하지 못하고 기다린다. 이 때 다른 `reader`프로세스가 데이터 베이스로 접근하게 된다면, 기다리고 있는 `Writer`프로세스를 무시하고, `새로운 reader`프로세스는 데이터베이스에 접근하게 된다. 즉, 두 `reader 프로세스가 데이터 베이스를 읽을 수 있다.
  - **The second R/W problem** (`writers`-preference)
    - 위 방법과 반대로 `write` 프로세스가 기다리는 상황에서 `새로운 reader` 프로세스가 들어온다면, 기존의 `writer` 프로세스 다음 순서로 기다려야한다.
  - **The Third R/W problem**
    - 아무에게도 우선순위를 주지 않는 방법이다.

### 3.3. Dining Philosopher Problem

![image](https://user-images.githubusercontent.com/53181778/77144811-c1ea4200-6a7e-11ea-9560-c906c251328c.png)

- 식사하는 철학자 문제

  - 5명의 철학자, 5개의 포크가 있는 상황

  - 각 철학자는 `생각 → 식사 → 생각 → 식사 …` 를 반복한다.

  - 식사하려면 2개의 포크 필요

    => 옆 사람이 식사를 하고 있다면, 포크를 두개 쓸 수 없기 때문에 식사를 할 수 없다.

- 프로그래밍

  - `포크` : 세마포 (# of permit = 1)
  - 포크와 세마포에 일련번호: 0 ~ 4
  - 왼쪽 포크→ 오른쪽 포크 순으로 `acquire()`와  `release()`를 수행한다.

5개의 포크세마포와 5명의 철학자 쓰레드를 생성한다. 각 철학자 쓰레드에는 무한 반복문으로 왼쪽 포크와 오른쪽 포크를 순서대로 집은 후 식사를 하고(몇 번 철학자가 식사했다는 것을 화면에 출력한다.), 다시 왼쪽 포크, 오른쪽 포크 순으로 내려놓고 생각을 한다.

```java
import java.util.concurrent.Semaphore;

class Philosopher extends Thread {
	int id; // philosopher id
	Semaphore lstick, rstick; // left, right 포크
	Philosopher(int id, Semaphore lstick, Semaphore rstick) {
		this.id = id;
		this.lstick = lstick;
		this.rstick = rstick;
	}

	public void run() {
		try {
			while (true) {
				lstick.acquire();
				rstick.acquire();
				eating();
				lstick.release();
				rstick.release();
				thinking();
			}
		}catch (InterruptedException e) { }
	}

	void eating() {
		System.out.println("[" + id + "] eating");
	}

	void thinking() {
		System.out.println("[" + id + "] thinking");
	}
}

class Test {
	static final int num = 5; // number of philosphers & chopsticks
	public static void main(String[] args) {
        int i;
        /* 포크 */
        Semaphore[] stick = new Semaphore[num];
        for (i=0; i<num; i++)
            stick[i] = new Semaphore(1);
        /* philosophers */
        Philosopher[] phil = new Philosopher[num];
        for (i=0; i<num; i++)
            phil[i] = new Philosopher(i, stick[i], stick[(i+1)%num]);
        /* let philosophers eat and think */
        for (i=0; i<num; i++)
            phil[i].start();
      }
}
```

- 코드를 실행해 보면 돌다가 멈추는 것을 확인 할 수 있다.

- 단순히 코드를 봐서는 문제점이 없어보인다. 이는 대표적인 **starvation** 문제중 하나이다. 모든 철학자가 식사를 하지 못하고 굶어죽는 상황이라고 할 수 있다.

- 예를 들어, 모든 철학자가 동시에 식사를 하려고 왼쪽 포크를 집었다고 하자. 그러면 5명의 철학자가 5개의 왼쪽 포크를 모두 집어든 상황이다. 그 결과, 남아있는 포크는 더 이상없고 모든 철학자가 오른쪽 포크를 들기 위해 기다리고 있다. 하지만 식사할 수 있는 철학자는 없고, 따라서 release를 호출해주는 철학가는 없기 때문에 아무도 포크를 내려놓지 않고 계속 기다리고 있다.

  이러한 상황을 **교착상태(deadlock)** 라고 한다.

## 4. 교착상태 (Deadlocks)

- 프로세스는 실행을 위해 `여러 자원`을 필요로 한다.
  - CPU, 메모리, 파일, 프린터, ……
  - 어떤 자원은 갖고 있으나 다른 자원은 갖지 못할 때 (e.g., 다른 프 로세스가 사용 중) 대기해야 한다.
  - 다른 프로세스 역시 다른 자원을 가지려고 대기할 때 `교착상태` 가능성이 존재한다.

### 4.1. 교착상태 필요 조건 (Necessary Conditions)

아래 `4가지 조건`을 `모두` 만족한 경우에만 교착상태가 발생할 수도 있다. (발생 안할 수도 있음)

- Mutual exclusion (상호배타)
  - 한 프로세스가 자원을 사용하고 있다면, 다른 프로세스는 이 자원을 사용할 수 없다. (포크를 한 철학자가 사용하고 있으면 이  포크는 사용할 수 없으므로 상호배타적이다.)
- Hold and wait (보유 및 대기)
  - 한 프로세스가 자원을 가지고 있는 상태에서 대기한다. (철학자는 왼쪽 포크를 가지고 있는 상태에서 오른쪽 포크를 잡기 위해 대기한다.)
- No Preemption (비선점)
  - 한 프로세스가 자원을 수행하는 중에는 다른 프로세스가 중간에 끼어들 수 없다. (한 철학자가 포크를 잡은 상태에서 다른 철학자가 이 포크를 뺏을 수 없다.)
- Circular wait (환형대기)
  - 프로세스가 요구하는 자원의 방향이 원형을 이룬다. (모든 철학자는 왼쪽 포크부터 집을 수 있다.)

- 한 번 교착상태에 빠지면 프로세스가 무한 루프에 빠져 수행하지 못하고 해당 프로세스가 가지고 있는 자원은 아무도 사용하지 못한다. 이는 전체 컴퓨터 환경에 매우 **치명적**이고, 교착상태에 의한 오류가 발생했을 때 해결하는 것은 매우 힘들다.

### 4.2. 자원(Resources)

- 하드웨어 자원은 여러 개가 존재하고 동일한 형식(type)의 자원이 존재할 수 있다. 예를 들어, 같은 CPU가 2개있는 환경이나 동일 프린터가 3개있는 환경이 있을 수 있다. 이러한 자원 하나하나를 `instance`라고 한다.

- 자원의 사용

  자원은 프로세스가 직접적으로 사용할 수 없고, 운영체제에 **요청(request)**하면 운영체제가 제공해준다. 그 후 프로세스는 이 자원을 **사용(use)**하고 모든 사용이 끝나면 이를 **반납(release)**한다.

  - 요청 (request) → 사용 (use) → 반납 (release)

- **자원 할당도** (Resource Allocation Graph)

  - 어떤 자원이 어떤 프로세스에게 할당되었는가?
  - 어떤 프로세스가 어떤 자원을 할당 받으려고 기다리고 있는가?
  - `자원`: 사각형, `프로세스`: 원, `할당 및 요청`: 화살표, `instance`: 점
  - 아래 그림은, R1은 P1에 할당되어 있는 상태이고, P2는 R1을 사용하기 위해 요청하는 상태(대기 상태)이다.

  ![image](https://user-images.githubusercontent.com/53181778/77147097-7175e300-6a84-11ea-8117-67fe4ab007dc.png)

  - 자원 할당도를 사용하는 이유는 교착상태의 필요조건을 한 눈에 볼 수 있기 때문이다.

  - 자원 할당도를 분석할 때 **mutual exclusion과 no-preemption 조건은 기본으로 적용**되어 있다고 가정한다. **Hold and wait**은 화살표를 통해 한 프로세스가 인스턴스를 할당받았고 다른 자원을 가리키고 있다면, 이 상황은 `Hold and wait`인 상태이다. **Circular wait** 역시 화살표 방향이 원형을 이루고 있다면 이는 환형대기인 상태이다.

  - 아래 이미지는 다른 조건은 다 만족하지만, `Circular wait`은 만족하지 않아 교착상태가 발생할 수 없다.

    ![image](https://user-images.githubusercontent.com/53181778/77147343-e6491d00-6a84-11ea-956a-94147fb5727a.png)

  - 아래 이미지는 식사하는 철학자 문제를 자원 할당도로 표현한 것이다. 그림을 보면 한 눈에 `Circular wait` 조건을 만족한 것을 알 수 있다. 그리고 모든 철학자(프로세스)는 한 포크(자원)를 할당(파란색 화살표)받고, 다른 포크를 요청(검은색 화살표)하고 있으므로 `Hold and wait` 조건 역시 만족한다.

  ![image](https://user-images.githubusercontent.com/53181778/77147672-b5b5b300-6a85-11ea-94af-e892eac26df1.png)

  - 식사하는 철학자 문제를 해결하기 위해서는 위 에서본 4가지 조건 중 하나만 없애주면 된다. 예를 들어,  `Circular wait` 조건을 없애보자. `Circular wait` 조건을 없애기 위해 짝수 번호 철학자는 왼쪽 포크, 오른쪽 포크순서로, 홀수 번호 철학자는 반대 순서인 오른쪽 포크, 왼쪽 포크 순서로 집도록 `run 함수` 코드를 아래와 같이 수정하였다.

    ```java
    // Philosopher Thread run function
    public void run() {
        try {
            while (true) {
                if (id % 2 == 0) {
                    lstick.acquire();
                    rstick.acquire();
                }
                else {
                    rstick.acquire();
                    lstick.acquire();
                }
                eating();
                lstick.release();
                rstick.release();
                thinking();
            }
        }catch (InterruptedException e) { }
    }
    ```

### 4.3. 교착상태 처리

교착 상태를 처리하는 4가지 방법의 있다.

1. 교착상태 방지 (Deadlock Prevention)
2. 교착상태 회피 (Deadlock Avoidance)
3. 교착상태 검출 및 복구(Deadlock Detection & Recovery)
4. 교착상태 무시 (Don't Care)

`교착상태 방지 (Deadlock Prevention)`와 `교착상태 회피 (Deadlock Avoidance)`는 교착상태를 사전에 방지하는 방법이고, `교착상태 검출 및 복구(Deadlock Detection & Recovery)`는 교착상태가 발생할 수는 있으나 발생했을 때 해결하는 방법이다. 마지막으로  `교착상태 무시 (Don't Care)`는 교착상태의 가능성이 너무 적기 때문에 그냥 무시해서 성능향상에 초점을 맞춘 것이다.

#### 4.3.1. 교착상태 방지 (Deadlock Prevention)

교착상태 방지는 위에서 살펴본 `교착상태 필요조건` 네 가지 중 최소 한 가지를 만족시키지 않도록 만드는 것이다.

- 상호배타 (Mutual exclusion)

- 상호배타를 없애기 위해서는 자원을 공유 가능하게 만들어야 한다. 하지만 현실적으로 이러한 방법이 **불가능**한 경우이거나, 임계구역을 동시에 접근하게 되어 오류가 발생하는 경우가 많다.

- 보유 및 대기 (Hold and wait)

- 이 조건을 없애려면 자원을 가지고 있는 상태에서 다른 자원을 기다리지 않도록 만든다. 만약 여러 개의 자원이 필요하다면 필요한 `모든 자원을 얻을 수 있는 경우`에만 해당 자원을 요청한다. 또는 필요한 자원 중 `일부만 가지는 경우 할당받은 자원을 모두 운영체제에 반납`한다. 하지만 이와 같은 방법은 자원의 **활용률을 저하시키고, starvation 현상이 발생할 수 있는 단점**이 있다.

- 비선점 (No preemption)

- 비선점을 없애러면 반대로 강제로 선점이 가능하도록 만들어야 한다. 이 역시 대부분의 자원에게는 **불가능**한 방법이다. CPU는 강제로 스위칭하는 것이 가능한 경우가 있지만, 대부분의 경우에는 불가능하다. 가령 프린터를 수행하는 중간에 다른 프로세스가 이를 선점하는 것은 불가능하다고 볼 수 있다.

- 환형 대기 (Circular wait)

  - 이 조건을 없애는 것은 위 세 가지 조건보다는 할 수 있는 확률이 높다. 대표적인 예는 모든 `자원에 번호를 부여`하여 이 번호에 대한 **오름차순**으로 `자원을 요청`(번호가 낮은 자원부터 요청)하는 것이다. 이 역시 **자원의 활용률을 저하**시키는 단점이 있다.

    > 오름차순으로 자원을 요청하게 되면, 식사하는 철학자 문제에서 P1 ~ P3는 기존과 마찬가지로 왼쪽 포크를 먼저 잡은 뒤 오른쪽 포크를 잡게 되지만, P4는 오른쪽 포크(R0)를 먼저 잡게 된다. (왼쪽 포크는 R4 이기 때문에) 즉, 환형 대기상태를 만족하지 않기 때문에 데드락이 발생하지 않는다.

네 가지 방법을 살펴본 결과 가장 현실적인 방법은 `hold & wait`나 `circular wait` 조건을 없애는 것이다. 하지만 둘 다 자원을 비효율적으로 사용하게 되는 단점을 가지고 있다. 그래서 이와 같이 교착상태를 `사전에 방지`하는 것은 군사, 우주, 의료와 같은 크리티컬한 곳에서 사용하는 것이 좋다.

#### 4.3.2. 교착상태 회피 (Deadlock Avoidance)

교착상태 회피와 방지의 차이점은 교착상태에 대해 다르게 접근한다는 점 이다. 교착상태 회피에서는 교착상태를 `자원 요청에 대한 잘못된 승인`으로 판단한다. 따라서, 교착상태 회피에서는 **안전한 할당(Safe allocation)**과 **불안정한 할당(Unsafe allocation)** 두 가지로 나뉜다.

- 교착상태 = 자원 요청에 대한 잘못된 승인으로 인한 것

- 예금은 받지 않고, 돈만 빌려주는 은행의 파산과 같은 개념

- **안전한 할당** (Safe allocation)

  magnetic tape자원 : 12개

  magnetic tape자원을 요청하는 process : 3개

  | Process | Max needs<br />최대로 필요한 자원 수 | Current needs<br />현재 필요한 자원 수 |
  | ------- | ------------------------------------ | -------------------------------------- |
  | P0      | 10                                   | 5                                      |
  | P1      | 4                                    | 2                                      |
  | P2      | 9                                    | 2                                      |

  3개의 프로세스가 요청하는 magnetic tape의 양은 위 표와 같다. Current needs는 한 프로세스가 한 번 요청을 할 때 요구하는 개수이고, Max needs는 프로세스를 정상적으로 끝내기 위해 필요한 총 개수이다. 운영체제 입장에서 3개의 프로세스가 모두 수행될 때까지 자원을 분배해보면 아래와 같다.

  - P0에게 5개를 할당한다.(5/10) => 현재 magnetic tape 개수: 7
  - P1에게 2개를 할당한다.(2/4) => 현재 magnetic tape 개수: 5
  - P2에게 2개를 할당한다.(2/9) => 현재 magnetic tape 개수: 3
  - 다시 P0가 5개를 요구하지만 현재 magnetic tape 개수는 3개이므로 할당해줄 수 없다.
  - P1에게 2개를 할당한다.(4/4) => 현재 magnetic tape 개수: 1
  - P1은 필요한 4개의 magnetic tape을 받았으므로, 정상적으로 프로세스를 종료하고 사용한 자원을 반납한다. => 현재 magnetic tape 개수: 5
  - 대기하고 있던 P0에게 5개를 할당한다.(10/10) => 현재 magnetic tape 개수: 0
  - P0 역시 필요한 자원을 모두 할당받았으므로, 종료 후 자원을 반납한다. => 현재 magnetic tape 개수: 10
  - P2는 현재 필요한 magnetic tape 개수가 7개이고, 현재 남아있는 magnetic tape 개수 10개이므로 정상적으로 수행가능하다.

  이 예제에서는 3개의 프로세스가 모두 정상적으로 자원을 할당받고 종료할 수 있었다. 이를 안전한 할당이라 한다.

- **불안전한 할당** (Unsafe allocation)

  magnetic tape자원 : 12개

  magnetic tape자원을 요청하는 process : 3개

  | Process | Max needs<br />최대로 필요한 자원 수 | Current needs<br />현재 필요한 자원 수 |
  | ------- | ------------------------------------ | -------------------------------------- |
  | P0      | 10                                   | 5                                      |
  | P1      | 4                                    | 2                                      |
  | P2      | 9                                    | 3  (!)                                 |

  - P0에게 5개를 할당한다.(5/10) => 현재 magnetic tape 개수: 7
  - P1에게 2개를 할당한다.(2/4) => 현재 magnetic tape 개수: 5
  - P2에게 3개를 할당한다.(3/9) => 현재 magnetic tape 개수: 2
  - 다시 P0가 5개를 요구하지만 현재 magnetic tape 개수는 2개이므로 할당해줄 수 없다.
  - P1에게 2개를 할당한다.(4/4) => 현재 magnetic tape 개수: 0
  - P1은 필요한 자원을 모두 할당받았으므로, 정상적으로 프로세스를 종료하고 사용한 자원을 반납한다. => 현재 magnetic tape 개수: 4
  - 대기하고 있던 P0는 아직 할당받을 수 없다.
  - P2에게 3개를 할당한다.(6/9) => 현재 magnetic tape 개수: 1
  - 현재 남아있는 magnetic tape 개수는 1개이고, P0가 요구하는 개수는 5개, P2는 3개이므로 두 프로세스 모두 할당받을 수 없다.

  이 예제에서 남은 magnetic tape 개수가 요구하는 개수보다 적으므로 자원을 할당해줄 수 없다. 그러므로 P0, P2 프로세스는 자원을 하염없이 기다리게 된다. 이를 **불안전한 할당이라 하고, 그 결과 교착상태에 빠지게 된다.**

  교착상태 회피는 마치 대출전문 은행과 유사하게 동작하므로, 해결 방법을 **Banker's Algorithm**이라 한다.

#### 4.3.3. 교착상태 검출 및 복구 (Deadlock Detection & Recovery)

앞에 두 방법은 교착상태를 일어나지 않도록 하는 방법이지만, 교착상태 검출 및 복구 방법은 교착상태가 일어나는 것을 허용한다. 그 대신, 교착상태가 일어났을 때 이를 인지하고 복구를 해야 한다.

- 주기적 검사를 통해 교착상태 발생 시 복구
- 검출
  - 검사에 따른 추가 부담 (overhead): 계산, 메모리
- 복구
  - 프로세스 일부 강제 종료
  - 자원 선점하여 일부 프로세스에게 할당

교착상태가 일어나는 것을 감지하기 위해 운영체제 내부에서 **주기적으로 교착상태가 발생하였는지 검사**해야한다. 그 주기의 길이가 짧으면 그 만큼 오버헤드가 크고, 주기가 길면 오버헤드는 줄일 수 있지만 교착상태를 빠르게 처리하기 어려워 진다.

복구하는 방법은 교착상태가 발생하는지 주기적으로 검사하듯이 **메모리의 상태**를 주기적으로 **메모리에 저장**해놓고 만약 교착상태가 발생하면 **그 이전 상태로 되돌리는 방법**이 있다. 그 외에도 일부 프로세스를 강제로 종료하거나 자원을 강제로 선점하여 프로세스에게 할당해주는 방법 등이 있다.

#### 4.3.4. 교착상태 무시

교착상태의 필요조건 네 가지를 모두 만족하더라도 교착상태가 반드시 일어나는 것이 아니다. 즉, 교착상태는 매우 드문 상황이고 이를 위해 오버헤드를 감수하는 것이 `비효율적인 환경`도 존재한다. 그렇기 때문에 교착상태에 대한 아무런 조치를 하지 않는 것도 한가지 방법이다.

## 5. 모니터 (Monitors)

세마포는 실제로 매우 오래된 동기화 도구이다. 현재에는 모니터(monitor)라는 동기화 도구를 주로 사용하며, 이는 좀 더 고수준의 동기화 기능을 제공한다.

- 모니터 (Monitor)
  - 세마포 이후 프로세스 동기화 도구
  - 세마포 보다 고수준 개념

- 구조

  ![image](https://user-images.githubusercontent.com/53181778/77218022-e8f85080-6b1e-11ea-96a5-acc7a20e9beb.png)

  - 공유자원 + 공유자원 접근함수
  - 2개의 queues: 배타동기 + 조건동기
  - 공유자원 접근함수에는 최대 1개의 쓰레드만 진입
  - 진입 쓰레드가 조건동기로 블록되면 새 쓰레드가 공유자원으로 접근가능
  - 새 쓰레드는 조건동기로 블록된 쓰레드를 깨울 수 있다.
  - 깨워진 쓰레드는 현재 쓰레드가 나가면 재진입할 수 있다.

### 5.1. 자바 모니터

- 자바의 모든 객체는 모니터가 될 수 있다.

  - 배타동기: `synchronized` 키워드 사용하여 지정
    - 아래 코드에서 함수 foo와 bar만 배타동기 (즉, 해당 함수에서 공통변수를 업데이트(임계구역) 한다는 의미이고, 해당 함수에는 하나의 쓰레드만 접근 가능하다.)
    - 또한, foo와 bar는 같은 임계구역을 공유한다는 의미이다. 즉, foo에 어떠한 쓰레드가 접근해 있으면, 다른 쓰레드가 foo 뿐만아니라 bar에도 접근이 불가능하다.
    - h 함수는 `synchronized` 를 사용하지 않아 어떠한 쓰레드도 동시에 접근가능하다. 이 의미는 공통 변수를 업데이트 하지 않는다는 의미로 해석된다.
  - 조건동기: `wait()`, `notify()`, `notifyAll()` 메소드 사용
    - 현재 공유자원에 접근중인 쓰레드가 공유자원이 또 필요한 경우 `wait()`함수를 호출하여 조건 동기 큐로 들어간다.
    - 다른 쓰레드가 공유자원을 다 사용하면 `notify()`함수를 호출하여 조건 동기 큐에서 대기중인 하나의 쓰레드를 깨워 공유자원에 접근하게 한다.
    - `notify() `는 하나의 쓰레드만 깨운다면, `notifyAll() `은 여러개의 쓰레드를 모두 깨우는 것이다.

  ```java
  class C {
      private int value, ...;     // 공통 변수
      synchronized void foo() {   // 배타동기
          // ...
      }
      synchronized void bar() {
          // ...
      }
      void h() {
          // ...
      }
  }
  ```

- 일반적인 사용 1 : Mutual exclusion

  - 세마포와는 다르게, 함수 앞에 `synchronized` 만 붙여주면 된다.

    ![image](https://user-images.githubusercontent.com/53181778/77218274-86ed1a80-6b21-11ea-82ea-d5dbdb70e168.png)

- 일반적 사용 2 : Ordering

  ![image](https://user-images.githubusercontent.com/53181778/77218292-b1d76e80-6b21-11ea-8c8d-d6cbce1dfbfd.png)

### 5.2. BankAccount Problem

세마포에서 살펴본 은행계좌 문제를 세마포 대신 모니터를 사용해서 Mutual exclusion, Ordering을 구현해보겠다.

#### 5.2.1. Mutual Exclusion

```java
class Test {
    public static void main(String[] args)
        throws InterruptedException {
        BankAccount b = new
            BankAccount();
        Parent p = new Parent(b);
        Child c = new Child(b);
        p.start();
        c.start();
        p.join();
        c.join();
        System.out.println( "\nbalance = " + b.getBalance());
    }
}

class BankAccount {
    int balance;
    synchronized void deposit(int amt) {
        int temp = balance + amt;
        System.out.print("+");
        balance = temp;
    }
    synchronized void withdraw(int amt) {
        int temp = balance - amt;
        System.out.print("-");
        balance = temp;
    }
    int getBalance() {
        return balance;
    }
}

class Parent extends Thread {
    BankAccount b;
    Parent(BankAccount b) {
        this.b = b;
    }
    public void run() {
        for (int i=0; i<100; i++)
            b.deposit(1000);
    }
}

class Child extends Thread {
    BankAccount b;
    Child(BankAccount b) {
        this.b = b;
    }
    public void run() {
        for (int i=0; i<100; i++)
            b.withdraw(1000);
    }
}
```

위 코드에서 볼 수 있듯이, 세마포를 선언하고 `number of permit` 값을 설정하는 대신, `deposit`과 `withdraw` 앞에 `synchronized` 키워드를 하나 추가한 것으로 훨씬 간편해진 것을 볼 수 있다.

#### 5.2.2. Ordering

`wait()`과 `notify()` 함수를 이용하여 Ordering을 할 수 있다.

| P1        | P2        |
| --------- | --------- |
|           | wait()    |
| Section 1 | Section 2 |
| notify()  |           |

- 위 구조는 프로세스를 P1 다음 P2 순서로 실행하는 경우이며, 이는 세마포와 매우 유사하다.
- 은행 문제를 아래와 같이 3가지 경우로 나누어 구현해 보겠다.
  1. 입금 우선
  2. 출금 우선
  3. 입금 출금 반복

- 입금 우선 코드

  ```java
  class BankAccount {
      int balance;
      synchronized void deposit(int amt) {
          int temp = balance + amt;
          System.out.print("+");
          balance = temp;
          notify();    //notify
      }
      synchronized void withdraw(int amt) {
          while (balance <= 0)  //초기 0원
              try {
                  wait();  //wait
              } catch (InterruptedException e) {}
          int temp = balance - amt;
          System.out.print("-");
          balance = temp;
      }
      int getBalance() {
          return balance;
      }
  }
  ```

- 출금 우선 코드

  ```java
  class BankAccount {
      int balance;
      synchronized void deposit(int amt) {
          while (balance == 0) //초기 0원
              try {
                  wait(); //wait
              } catch (InterruptedException e) {}
          int temp = balance + amt;
          System.out.print("+");
          balance = temp;
      }
      synchronized void withdraw(int amt) {
          int temp = balance - amt;
          System.out.print("-");
          balance = temp;
          notify();  //notify
      }
      int getBalance() {
          return balance;
      }
  }
  ```

- 입금 출금 반복 코드

  ```java
  class BankAccount {
      int balance;
      boolean p_turn = true;   //처음 부모의 차례
      synchronized void deposit(int amt) {
          int temp = balance + amt;
          System.out.print("+");
          balance = temp;
          notify();
          p_turn = false; //자식 차례로 변경
          try {
              wait();	//한번 끝나고 슬립
          } catch (InterruptedException e) {}
      }
      synchronized void withdraw(int amt) {
          while (p_turn)	// 부모차례면 슬립
              try {
                  wait();
              } catch (InterruptedException e) {}
          int temp = balance - amt;
          System.out.print("-");
          balance = temp;
          notify();	//부모를 깨워줌 변경
          p_turn = true;	//부모  차례로 변경
      }
      int getBalance() {
          return balance;
      }
  }
  ```

### 5.3. 전통적 동기화 문제

#### 5.3.1. Producer-Consumer Problem

```java
class Buffer {
    int[] buf;
    int size, count, in, out;
    Buffer(int size) {
        buf = new int[size];
        this.size = size;
        count = in = out = 0;
    }

    synchronized void insert(int item) {
        while (count == size)
            try {
                wait();
            } catch (InterruptedException e) {}
        buf[in] = item;
        in = (in+1)%size;
        notify();
        count++;
    }

    synchronized int remove() {
        while (count == 0)
            try {
                wait();
            } catch (InterruptedException e) {}
        int item = buf[out];
        out = (out+1)%size;
        count--;
        notify();
        return item;
    }
}

class Producer extends Thread {
    Buffer b;
    int N;
    Producer(Buffer b, int N) {
        this.b = b; this.N = N;
    }
    public void run() {
        for (int i=0; i<N; i++)
            b.insert(i);
    }
}

class Consumer extends Thread {
    Buffer b;
    int N;
    Consumer(Buffer b, int N) {
        this.b = b; this.N = N;
    }
    public void run() {
        int item;
        for (int i=0; i<N; i++)
            item = b.remove();
    }
}

class Test {
    public static void main(String[] arg) {
        Buffer b = new Buffer(100);
        Producer p = new Producer(b, 10000);
        Consumer c = new Consumer(b, 10000);
        p.start();
        c.start();
        try {
            p.join();
            c.join();
        } catch (InterruptedException e) {}
        System.out.println("Number of items in the buf is " + b.count);
    }
}
Number of items in the buf is 0
```

#### 5.3.2 The Dining Philosopher Problem

아래 코드는 Deadlock은 해결되지 않은 코드이다.

```java
class Philosopher extends Thread {
    int id; // philosopher id
    Chopstick lstick, rstick;
    Philosopher(int id, Chopstick lstick, Chopstick rstick) {
        this.id = id;
        this.lstick = lstick;
        this.rstick = rstick;
    }

    public void run() {
        try {
            while (true) {
                lstick.acquire();
                rstick.acquire();
                eating();
                lstick.release();
                rstick.release();
                thinking();
            }
        }catch (InterruptedException e) { }
    }

    void eating() {
        System.out.println("[" + id + "] eating");
    }
    void thinking() {
        System.out.println("[" + id + "] thinking");
    }
}

class Chopstick {	// 모니터로 젓가락(임계구역) 구현
    private boolean inUse = false;  //초기
    synchronized void acquire() throws InterruptedException {
        while (inUse)
            wait();
        inUse = true;
    }
    synchronized void release() {
        inUse = false;
        notify();
    }
}

class Test {
    static final int num = 5; // number of philosphers & chopsticks
    public static void main(String[] args) {
        int i;
        /* chopsticks */
        Chopstick[] stick = new Chopstick[num];
        for (i=0; i<num; i++)
            stick[i] = new Chopstick();
        /* philosophers */
        Philosopher[] phil = new Philosopher[num];
        for (i=0; i<num; i++)
            phil[i] = new Philosopher(i, stick[i], stick[(i+1)%num]);
        /* let philosophers eat and think */
        for (i=0; i<num; i++)
            phil[i].start();
    }
}
```

