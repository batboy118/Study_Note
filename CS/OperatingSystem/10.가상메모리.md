# 10. 가상 메모리 (Virtual Memory)

> 가상 메모리는 물리 메모리 크기의 한계를 극복하기 위해 나온 기술이다. 즉, 물리 메모리보다 큰 프로세스를 수행하기 위해 가상 메모리를 사용한다.

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./)

---

<!-- TOC -->

- 

<!-- /TOC -->

## 1. 가상 메모리

- 물리 메모리의 크기보다 더 큰 메모리를 실행하기 위해서 사용하는 개념으로 현대의 컴퓨터는 모두 가상 메모리를 사용하고 있다.

  > 100MB 메인 메모리에서 200MB 크기의 프로세스 실행

- 프로세스 전체를 메인 메모리에 올리지 않고, 현재 실행에 필요한 부분만 메모리에 올리는 방법을 사용한다.

  - 오류 처리 제외, 배열 일부 제외, 워드프로세스에서 정렬, 표 등의 사용하지 않는 기능 제외
  - 동적 적재 (dynamic loading)과 비슷한 개념

- 메모리에 올리거나 올리지 않을 `프로세스의 일부분`은 페이지 단위일 수도 있고, 세그먼트 단위일 수도 있지만 현재 대부분은 `페이지 단위`를 사용
- 현재 필요한(요구되어지는) 페이지만 메모리에 올리는 것을 **Demanding Paging(요구 페이징)** 이라고 한다.

### 1.1. 요구 페이징 (Demanding Paging)

![image](https://user-images.githubusercontent.com/53181778/77733505-e2764700-6ffe-11ea-84c5-c2c4bd3975a2.png)

- 위 그림은 요구 페이징의 모습이다. P1과 P2 프로세스 이미지는 Disk의 backing store (= swap device)에 저장되어 있다.
- 두 프로세스 P1, P2는 각각 필요한 페이지만 메모리에 할당하였다. 여기서 위 그림의 테이블은 `P1의 페이지 테이블`이다. 현재 사용되어 지는 부분만 메모리에 올라가 페이지 테이블에 올라가게 된다.
- 기존의 페이지 테이블과 다른 점은 **valid bit** 이다. 현재 메모리에 페이지가 있는지 없는지를 체크하는 비트로, 현재 페이지가 메모리에 있다면 1, 없다면 0값을 갖는다.

- 만약, CPU에서 P1의 2번째 페이지에 접근하는데, valid bit값이 0이다. 그렇기 때문에 2번째 페이지에 해당하는 내용을 메모리에 올려야한다. 즉, **CPU에 인터럽트 신호를 발생하여 운영체제 내부의 ISR로 점프**하여 디스크 내부의 프로세스 P1에 있는 2번째 페이지를 메모리에 할당하는 작업을 처리한다.

  ![image](https://user-images.githubusercontent.com/53181778/77734145-10a85680-7000-11ea-9ba1-8c25ae62b9f6.png)

- 가상 메모리를 만드는 방법은 대표적으로 두 가지가 존재하지만, 대부분의 경우 **요구 페이징을 사용**이 일반적이이 때문에, 가상 메모리와 요구 페이징을 같은 용어로 사용하는 경우가 많다.

- swapping vs demand paging

  Swappingr과 Demanding Paging의 공통점은 둘 다 메모리와 backing store 사이를 서로 오고 가는 기능을 수행하지만, **Swapping은 전체 프로세스 단위**로 이동하고 **Demanding Paging은 페이지 단위**로 이동하는 차이점이 있다.

### 1.2. 페이지 결함 (Page Fault)

-  **CPU가 접근하려는 페이지가 메모리에 할당되지 않아 페이지 테이블에서 찾을 수 없는 경우(valid bit = 0)** 페이지 결함 또는 페이지 부재라고 한다.

- page fault가 감지되면, 운영체제는 CPU에 전기적 신호를 보내어 `Page Fault Routine`시작한다.

  ![image](https://user-images.githubusercontent.com/53181778/77734482-ae9c2100-7000-11ea-8740-098ee9f0a251.png)

- Page Fault Routine
  1. 해당 페이지가 메모리에 있는지 valid bit를 확인한다.
  2. valid bit가 0이라면 CPU에 인터럽트 신호를 보내어 운영체제 내부 해당 ISR로 점프한다.
  3. 해당 ISR에서 backing store(디스크)를 탐색하여 해당 프로세스의 페이지를 찾는다.
  4. 해당 페이지를 비어있는 프레임(메모리)에 할당한다.
  5. 페이지 테이블을 갱신한다.(프레임 번호 설정, valid bit 1로 변경)
  6. 다시 명령어로 돌아가서 실행한다.

### 1.3. Pure Demanding Paging vs Prepaging

- Pure Demanding Paging

  **프로세스가 최초로 실행될 때는 어떤 페이지가 필요한지 알 수 없으므로, 아무 페이지도 올리지 않는다.** 그러므로 프로그램을 실행하자마자 **page fault가 발생**한다. 즉, 순수하게 필요한 페이지만 올리는 것을 말한다. Pure Demanding Paging의 장점은 메모리를 최대한 효율적으로 사용할 수 있다. 하지만 시작부터 page fault가 발생하므로 속도면에서 느리다.

- Prepaging

  pure demanding paging과 반대대는 개념이다. 프로그램을 실행할 때 **필요할 것이라 판단되는 페이지를 미리 올리는 것**이다. 이것의 장점은 page fault가 발생할 확률이 적으므로 속도면에서 빠르지만, 단점으로 미리 올라간 페이지를 사용하지 않는다면 메모리가 낭비된다.

### 

