# 12. 파일할당 File Allocation

> 컴퓨터 시스템 자원 중 CPU에 대해서는 CPU 스케줄링, 프로세스 동기화 등에 대해서 학습했고, 주기억장치인 메인 메모리 관리에 대해서 페이징, 가상 메모리(요구 페이징) 등을 학습하였다. 지금 부터는 컴퓨터 시스템 자원 중 하드디스크와 같은 보조기억장치에 대해 학습하겠다.

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./README.md)

---

<!-- TOC -->

- [1. 파일 시스템과 보조 기억 장치](#1-파일-시스템과-보조-기억-장치)
- [2. 파일 할당](#2-파일-할당)
	- [2.1. 연속 할당 (Contiguous Allocation)](#21-연속-할당-contiguous-allocation)
	- [2.2. 연결 할당 (Linked Allocation)](#22-연결-할당-linked-allocation)
	- [2.3. 색인 할당 (Indexed Allocation)](#23-색인-할당-indexed-allocation)

<!-- /TOC -->

## 1. 파일 시스템과 보조 기억 장치

 보조기억장치가 데이터를 관리하는 방식을 **파일 시스템**이라 한다. 파일 시스템은 보조 기억 장치에 파일을 할당하는 방법과 긴밀한 관계를 가지고 있다. 보통 디렉토리를 이용하여 파일을 트리 구조로 관리하게 된다.

대표적인 보조기억 장치로는 **하드 디스크**가 있다. 하드 디스크는 아래와 같은 구조로 되어 있다.

![image](https://user-images.githubusercontent.com/53181778/78108301-a409cf00-73e6-11ea-9ee3-40d3f7438a36.png)

- **platter**: 실제 데이터를 기록하는 자성을 가진 원판이다. platter는 그림과 같이 여러 개가 존재할 수 있고 또 앞뒤로 사용할 수 있다.
- **track**: platter 내부의 동심원을 이루는 하나의 영역으로, 하나의 platter는 여러개의 track으로 나누어진다.
- **sector**: 하나의 track을 여러 개로 나눈 영역을 sector라 한다. sector size는 일반적으로 512 bytes이며 주로 여러 개를 묶어서 사용한다.
- **cylinder**: 한 cylinder는 모든 platter에서 같은 track 위치의 집합을 말한다.

sector를 여러 개로 묶은 단위를 block이라 하고, 데이터를 **블록 단위로 읽고 쓰기** 때문에 하드디스크를 block device 라고 불리기도 한다.

> cf) character device : 문자 단위로 입출력을 하는 디바이스 (예. 키보드)

메모장 프로그램에서 알파벳 a만을 적고 저장해보면 1byte가 아닌 4KB(하나의 block size)가 할당되는 것을 확인할 수 있다. 이때, 블락의 크기는 운영체제마다 다르다.

즉, 초기의 디스크는 비어 있는 블록(free block)들의 집합( pool of free blocks)이라고 볼 수 있다. 운영체제가 각각의 파일에 대해 **free block**을 할당하는 방법에 대해 알아보자.

## 2. 파일 할당

![image](https://user-images.githubusercontent.com/53181778/78109185-49717280-73e8-11ea-9219-55ec323e76b4.png)

pool of free blocks를 논리적인 그림으로 나타낸 그림이다. 블록들이 위와 같이 있을 때 파일을 할당하는 방법은 **연속 할당**, **연결 할당**, **색인 할당** 세 가지가 존재한다.

### 2.1. 연속 할당 (Contiguous Allocation)

연속 할당은 **연속된 블록에 파일을 할당** 하는 것이다. 즉, 블록 크기가 1KB이고, 할당할 파일이 f1, f2, f3 3개가 있을때, 각각의 크기가 5KB, 3KB, 4KB인 경우 아래와 같이 할당하는 것이다.

![image](https://user-images.githubusercontent.com/53181778/78110073-ef71ac80-73e9-11ea-8130-e766b2aa29fd.png)

이러한 방식의 장점으로는 Read/Write 작업 시 하드디스크의 헤더의 이동을 최소화 할 수 있어 효율을 높일 수 있다. 이 방식은 예전의 IBM에서 사용하던 방법이다.

연속 할당에는 **두 가지 특징**이 있다.

- **순차 접근(Sequential Access)**
  순서대로 파일을 읽을 수 있다는 의미이다. 그렇기 때문에 주로 동영상, 음악, VOD 등의 연속성이 필요한 파일에 적합하다.

- **직접 접근(Direct Access)**
  운영체제는 파일의 정보를 **디렉토리(directory)** 라는 **테이블**에 저장하여 파일을 관리한다. 디렉토리에 사용자가 접근가능한 정보는 해당 파일의 **이름, 크기, 날짜** 등이 있다. 그 외에 운영체제가 이용하는 정보는해당 **파일의 시작 블록 번호**와 같은 것이 있다. 예를 들어, 위 예제의 f2 파일의 디렉토리 정보는 아래와 같이 표현된다.

  ```
  file name: f2
  file size: 3 KB
  ...
  -----------------
  block number: 5
  ```

연속 할당은 순차적으로 저장되어 있으므로 운영체제는 디렉토리에서 얻은 시작 블록 번호로 원하는 블록에 **바로 접근**할 수 있다.

예를 들어, 위 예제에서 f1 파일의 3번째 블록에 접근하고 싶다면, 운영체제는 f1의 시작 블록 번호가 0번인 것을 알고 있기 때문에 offset을 주어 2번 블록에 접근하면 f1의 3번째 블록에 접근하는 것이다.

연속할당은 큰 단점으로인해 현재는 거의 사용하지 않는다. 단점은 바로 **외부 단편**화 문제이다. 파일을 할당하고 지우고를 반복하다보면 중간 중간에 빈 공간(hole)이 생기게 되는데, 파일을 연속으로 할당해야 하는 연속할당의 경우 빈공간을 채우지 못하는 경우가 발생한다. 즉, 이전 메인 메모리 할당에서 살펴본 것과 같이 **외부 단편화** 문제가 발생한다.

메모리 할당에서 외부 단편화로 인해 메모리의 약 1/3을 낭비되는데, 디스크의 연속 할당도 같은 낭비가 발생한다.

- Contiguous Allocation

  또 다른 문제점으로 파일의 용량이 커지거나 감소하는 경우이다. 계속해서 사용하는 파일의 경우 **크기가 계속 증가** 할 수 있고, 그렇게 되면 다음 영역까지 침범하게 되어 연속적으로 메모리를 할당할 수 없게 된다.

### 2.2. 연결 할당 (Linked Allocation)

연결 할당은 연속 할당의 문제점을 해결하기 위해 나온 방법으로, 파일 블럭을 연속적으로 할당하는 것이 아니라 **링크드 리스트(linked list)** 와 같은 방식으로 파일을 할당한다.

![image](https://user-images.githubusercontent.com/53181778/78112110-41680180-73ed-11ea-8910-667878bd9440.png)

위 그림은 연결할당을 이용하여 block 크기가 1 KB, 파일 f1의 크기가 5 KB 일 때 연결 할당한 모습이다. 각 블록의 마지막에 **다음 블럭의 주소를 저장하는 포인터 공간(4bytes)**이 존재한다. 마지막 블록의 **포인터 공간**에는 파일의 끝을 나타내는 값이 저장된다.

이러한 파일을 **linked list of data blocks** 라고 하며, f1의 파일 디렉토리 정보는 아래와 같다.

```null
file name: f1
file size: 5 KB
...
-----------------
block number: 6
```

연결 할당을 사용해서 새로운 파일을 할당할 때는 비어있는 블록을 첫 블록으로 선택한다.

만약 파일의 용량이 커지는 경우 다른 비어있는 블록을 할당해서 기존의 블록과 연결해주면 되기 때문에 **외부 단편화 문제**가 없어지게 되어 디스크의 낭비도 없어진다.

하지만, 연결 할당도 문제점을 가지고 있다.

- 순차 접근은 가능하지만 **직접 접근은 불가능**

  파일의 블록들은 모두 흩어져 있으므로 시작 블록 번호를 가지고는 원하는 위치의 블록에 바로 접근할 수는 없다. (랜덤 access 불가능)

- 포인터를 저장하는 포인터 공간에서 디스크 용량의 손해가 발생

- **낮은 신뢰성** : 중간 블록의 포인터가 사라지면 그 이후의 모든 블록에 접근하지 못함

- **느린 속도** : 블록이 모두 흩어져 있으므로 블럭을 이동할 때 마다 디스크 헤더의 움직임이 많아져 효율이 떨어짐

위 문제점을 개선하기 위해 나온 것이 마이크로 소프트에서 만든 **FAT(File Allocation Table) 시스템**이다. FAT 시스템 또한 연속 할당을 이용했으며, **다음 블록으르 가리키는 포인터들을 따로 모아 하나의 테이블(FAT)**을 만들어 한 블록에 저장하여 사용하는 방식이다.

![image](https://user-images.githubusercontent.com/53181778/78113051-aa9c4480-73ee-11ea-8567-f54325ee1b4a.png)

위 그림은 0번지에 FAT를 저장하여 사용하고 있다. FAT를 보면 테이블의 인덱스는 전체 디스크의 블록 번호이며, **각 인덱스마다 다음 블록 번호를 저장**하고 있다.

FAT 시스템을 사용하면 기존의 연결 할당의 문제점 대부분을 해결할 수 있다.

- FAT를 한 번만 읽으면 **직접 접근이 가능**

- FAT만 문제가 없다면 중간 블록에 문제가 생겨도 FAT를 통해 그 다음 블록은 여전히 읽을 수 있다.

- FAT는 일반적으로 **메모리 캐싱**을 사용하여 블록 번호를 찾는것은 빠르다.

  > 하지만, 실제 디스크 헤더가 움직는 것은 블록으로 이동이 필요하기 때문에 여전히 느리다.

FAT는 매우 중요한 정보이므로 **손실 시 복구를 위해 FAT를 이중 저장** 한다.

FAT의 각 인덱스 크기는 전체 블록의 개수를 저장할 만큼의 크기를 가지고 있어야 한다. 현재는 일반적으로 32bit 크기를 사용하고 이를 FAT32라고 부른다.(이전에는 FAT16, FAT12 등이 있었다.)

### 2.3. 색인 할당 (Indexed Allocation)

색인 할당 역시 연결 할당과 비슷하게 데이터를 랜덤한 블록 번호에 할당한다. 하지만, 색인 할당은 연결 할당과는 다르게, 한 파일의 블록들의 주소(인덱스)들을 하나의 블록에 따로 저장한다. 이 블록을 **인덱스 블록**이라고 부르며, 파일 당 하나의 인덱스 블록이 존재한다.

- 예제
  block size = 1 KB, f1 = 5 KB, f2 = 2 KB

![image](https://user-images.githubusercontent.com/53181778/78216220-dbd94b00-74a8-11ea-831d-69c836009fe6.png)

- 색인 할당은 디렉토리 정보가 다른 할당과 다르다. 시작 블록 번호를 저장하는 것이 아니라 **인덱스 블록 번호를 저장**한다.

```null
file name: f1
file size: 5 KB
...
-----------------
index block number: 11
```

```
file name: f2
file size: 2 KB
...
-----------------
index block number: 27
```

색인 할당은 인덱스 블록에 할당된 블록을 순서대로 저장하기 때문에 **직접 접근**(random access)가 가능하고 연속적으로 할당할 필요가 없기 때문에 외부 단편화 문제가 발생하지 않는다. 색인 할당은 **Unix/Linux**에서 주로 사용한다.

- 색인 할당의 **단점**

  작은 크기의 파일인 경우에도 **하나의 블록을 인덱스 블록으로 사용**하기 때문에 저장 공간이 손실이 발생한다.

  또한, 하나의 인덱스 블록을 가지고는 크기가 큰 파일을 저장할 수 없는 경우도 있다. 예를 들어, 하나의 블록 크기가 512 bytes인 블록은 최대 저장할 수 있는 블록 인덱스 개수는 **512 / 4 bytes(포인터 크기) = 128**개이다. 즉 파일의 최대 크기는 **128 \*512bytes = 64KB**로 아주 작은 크기이다. 블록 크기가 1KB이라 하더라도 최대 인덱스 개수는 **256개**(1000/4)이고 최대 파일의 크기는 **256KB(256\*1KB)**이다.

색인 할당의 단점을 극복하기 위해서 아래와 같은 방법들을 사용한다.

- **Linked**: 이 방식은 인덱스 블록을 여러 개 만들어 인덱스 블록들을 **연결 할당**을 하는 것과 같다. 즉, 각 인덱스 블록의 마지막에 다음 인덱스 블록을 가리키는 포인터가 저장되어 있다.

![image](https://user-images.githubusercontent.com/53181778/78216262-f7445600-74a8-11ea-991e-ebc95b1e4068.png)

- **Multilevel index**: 이 방식은 계층을 두는 방법이다. 하나의 인덱스 블록은 다른 인덱스 블럭의 주소(위치)를 가지고 있어 계층적인 구조가 된다. 만약 인덱스의 공간이 부족해지면 추가적으로 계층을 더 만든다.

![image](https://user-images.githubusercontent.com/53181778/78216273-fd3a3700-74a8-11ea-8ef3-3db719f90db6.png)

- **Combined**: 이 방식은 **Linked**와 **Multilevel index**를 합친 방법이다. 한 인덱스 블록의 포인터들은 **데이터 블록**과 **또 다른 인덱스 블록** 둘 다 가리킬 수 있다.
  - 리눅스는 combined 방식을 사용한다.
