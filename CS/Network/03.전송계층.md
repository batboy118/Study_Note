# 02. 전송 계층

> 네트워크의 전송 계층에 대해서 학습한다.

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./README.md)

---

<!-- TOC -->

- 

<!-- /TOC -->

## 1. 전송 계층

- 목적 : 두 단말 간에 신뢰성 있는 통신을 보장
  - Reliable Networking(End-to-End) 

  - 현실에서는 신뢰성 있는 통신을 보장하는 것은 매우 복잡하다. 

- 두 단말간 통신의 문제점

  - 두 단말간 무한한 패킷의 흐름이 전달되지 않는다.
  - 패킷 유실이 생길 수 있다.
  - 패킷의 순서가 바뀔 수 있다.
  - 패킷의 변조가 발생할 수 있다.

### 1.1. 성능 향상 및 신뢰성 확보

- 순서 보장
  패킷에 번호를 붙여 순서를 보장한다. 양방향 모두 (클라이언트 -> 서버, 서버 -> 클라이언트) 동일한 번호를 붙여 송수신을 확인한다. 이때, 패킷 번호를 몇번까지 설정할지는 보내려는 데이터의 크기에 따라 너무 유동적이다. 그렇기 때문에 일정한 한계치를 정해놓고 한계치에 도달하면 다시 0번으로 돌려 순환식으로 사용하는 방법을 사용한다.

- 파이프라이닝 (Pipelining)

  - 연속된 대량의 작업이 순차성을 갖고 있으나 앞의 일이 종료하지 않고도 다음일을 시작할 수있는 병렬성을 가지는 경우 성능향상 기법
  - 파이프라이닝 기법 2가지
    - Go-back-N
    - Selective Repeat

- Go-back-N : 최대 N개의 패킷을 병렬적으로 처리

  - 송신측에서는N개의 패킷을 버퍼링한다. (재전송하기 위해서)
  - 수신측에서는 순차적으로 잘 수신된 패킷에 대하여 Ack을 송신하고 패킷의 페이로드(payload : 패킷내의 실제 내용 )를 응용계층으로 올려보낸다.
    - 수신측에서 잘 받았다는 의미로 보낸 N번 째 Ack 패킷이 손실되어도, 다음 번호인N+1 Ack메세지를 송신측에서 받으면 N번째 패킷을 수신측에서 잘 받았다고 판단할 수 있다. 
  - 송신측에서는 buffer에 여유가 생기면 (Ack을 받아서) 그만큼 추가로 Pipelining을 한다.
  - 수신측에서 순서에 맞지 않는 (이빨이 빠진) 패킷을 받은 경우
    - 두 가지 방법
      1. 조용히 있는다.
      2. 잘받은 마지막 패킷에 대한 Ack을 전송
         - 송신측에 k번째 Ack이 반복적으로 올 경우 k+1 패킷이 제대로 전달되지 않음을 뜻한다.

  - GBN에서 재전송 정책
    - 각 패킷 전송시에 패킷을 위한 타이머 설정
    - 순서에 맞는 Ack을 받으면 타이머 소멸(초기화)
    - 또는, 3번정도 동일한 k번째 패킷에대한 Ack이 오면  k+1번 째 패킷을 재전송하기도 한다.

  ![image](https://user-images.githubusercontent.com/53181778/79042674-a533cb00-7c34-11ea-807b-d83ae7c1ccc9.png)

  - GBN의 장점

    - 단순하다. (특히, 수신측)

    - 간편하게 시스템의 상태가 추상화 된다.

  - GBN의 단점

    - 패킷 유실에 대한 복구비용이 크다. (수신측에서 잘 받은 패킷들도 이전 패킷에서 유실이 발생했다면 다시 송수신해야한다. )

- Selective Repeat

  - GBN과는 다르게 수신측에서 받지 못한 패킷만 재전송 하도록 만든 방법이다.
  - 수신측에도 버퍼를 만들어 특정 패킷을 수신하지 못했을 때 그 뒤쪽의 잘 도착한 패킷들을 버퍼에 임시 저장했다가 수신했던 패킷이 다시오면 조각을 맞추어 순자적으로 응용계층으로 전달한다.

  ![image](https://user-images.githubusercontent.com/53181778/79042876-47a07e00-7c36-11ea-8653-36742e8a5f36.png)

  - GBN과는 다르게 예를들어 2번패킷이 누락되고, 3번 패킷에 대한 Ack을 송신측에서 받았다고해도, 2번패킷이 도착헀다는 것을 보장하지 않는다.

  - 송신측에서는 이전의 패킷에 대한 Ack을 받지 못하면 다른 패킷에 대한 Ack을 받았다고 하더라도 버퍼를 사용할 수 없다.

  - 장점
    - 실패한 패킷만 재전송하면 된다. (성능 향상)
  - 단점
    - 시스템 추상화가 복잡하다.
    - 수신측에도 버퍼가 필요하다.

## 2. TCP와 UDP 

|             | TCP                                                          | UDP                                                          |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 신뢰성 제공 | 내용의 유실 X<br />순서를 보장한다.(연속성을 제공)<br />즉,이빨 빠진 내용을 윗 계층에 전달하지 않음) | 내용 유실 O<br />데이터의 순서를 보장하지 않음               |
| 속도        | 고의적 지연이 존재<br />  - 패킷 수신 순서<br />  - 혼잡 제어 | 고의적 지연이 없음                                           |
| 전송 단위   | 바이트(Byte)<br />  - 특정 단위(크기)를 정해놓지 않고 보낸다.<br />  - 데이터 손실이 되지 않기 때문에 데이터의 단위를 기억할 필요가 없다.<br />  - send()로 보낸 크기와 receive()함수로 받는 패킷의 단위가 다르다. (여러번 send해도 한번만 receive할 수 있다.) | 패킷 (데이터그램)<br />  - send()함수 호출 단위<br />  - 특정 크기 만큼 끊어서 보낸다.<br />  - send()와 recieve()험수의 단위가 같다. (n번 send 했으면 n번 receive해야 함) |

> TCP는 양방향 파이프라이닝 UDP는 양방향 공 던지기 느낌이다.
>
> - UDP는 공을 받을 수 있지만, 못 받을 수도있고, 속도 또한 빠르게 던지면 앞 패킷보다 빠르게 도착할 수 도 있다.

### 2.1. TCP

- 신뢰성있는 네트워크(reliable network)
- 고의적이지 않은 내용변조 탐지
  - 잡음 또는 기계적 영향으로 인한 패킷 변조를 탐지할 수 있다. 

- 혼잡제어
- 흐름제어
  - 수신측 버퍼가 가득차서 넘칠 수 있는 상황이면, 수신측에서 송신측에 더 이상 보내지 말라고 메시지를 보낼 수 있다.

#### 2.1.1. 데이터 Encapsulation



![image](https://user-images.githubusercontent.com/53181778/79044304-4e7fbe80-7c3f-11ea-8d7a-3edf73af229c.png)

- 5계층 : 응용(HTTP) - 전송(TCP) - 네트워크(IP) - 링크(이더넷, 와이파이) - 물리

  - 응용 : HTTP 헤더를 붙인다. [HTML(표현) → HTTP(세션)]
  - 전송 : TCP 헤더를 붙인다.
  - 네트워크 : IP 헤더를 붙인다.
  - 링크 : 이더넷 헤더를 붙인다.

  ![image](https://user-images.githubusercontent.com/53181778/79044339-81c24d80-7c3f-11ea-8ac0-726f7754cf8e.png)

#### 2.2.2. TCP 헤더의 구성

![image](https://user-images.githubusercontent.com/53181778/79044440-22187200-7c40-11ea-9db0-97167071d622.png)

- 헤더는 32bit 길이로 최대 60바이트까지 가능하지만, 옵션(최대 40byte)를 빼면 기본 20byte(160bit)로 이루어져 있다.

- **source port & Dest Port**

  - port 번호는 응용을 구분해 준다. 즉, 클라이언트가 크롬을 통해 웹서버에 접근할 경우, 소스 포트번호는 임의의 포트번호가 될 것(아래 그림에서는 1234번)이고, 웹 서버의 경우 일반적으로 80번 포트이기 떄문에 dest port번호는 80으로 설정 될 것이다.

  > 소켓과 포트의 차이점
  >
  > - 소켓은 서로 다른 응용에 대해서 생성되어 통신을 할 수 있게 하는 것이고, 포트는 하나의 응용을 위한 통로로 사용이 된다.
  >
  > - 소켓여러개가 하나의 포트번호에 맵핑 될 수 있다.
  >
  >   - 하나의 웹 서버에 여러개의 클라이언트와 소켓 통신을 할 수 있다. 이때 클라이언트마다 따로 포트를 사용하는것이 아니라, 하나의 포트로 여러개의 소켓을 사용할 수 있다.
  >
  >   ![image](https://user-images.githubusercontent.com/53181778/79044956-635e5100-7c43-11ea-8b94-fcdc35827e7e.png)
  >
  >   서버에서는 IP와 포트번호의 조합을 보고 클라이언트를 판별한다. (각각 다른조합에 대해서 소켓을 생성함)
  >
  >   위 그림에서 USER의 IP주소는 같지만 PORT번호가 다르기 때문에 웹 서버에서 각각의 응용에 대해서 PORT번호를 보고 다른 서비스를 해줄 수 있다.

- **Seq Num & AcK Num**

  - 신뢰성 있는 통신을 제공함

  - Go-back-N 또는 Selective Repeat를 제공함

  - TCP에는 같은 패킷에 Seq와 Ack이 동시에 존재한다.

  - TCP는 **Go-Back-N 기법을 기반**으로 작동한다.

  - TCP에서 Seq와 Ack는 패킷번호가 아니라, **바이트의 번호**이다.(몇 번째 바이트인지)

  - TCP는 의미있는 데이터의 단위가 아닌 바이트의 단위로 통신을 한다. 그렇기 때문에 패킷이라고 부르는 것 보다는 세그먼트라고 부르는 것이 적절하다.

    > 패킷 : 자체로 특정한 의미를 가지고 있는 단위
    >
    > 세그먼트 : 자체로 특정한 의미를 가지고 있지 않은 단위

    1. 송신측에서 seq = 42, ack = 77, "Hello"를 보낸다.

       - seq = 42 : Hello를 42번째 바이트부터 보내고 있다. (H가 42번째 바이트)

       - ack = 77 : 77번 바이트를 받을 차례이다.

    2. 수신측에서 seq = 77, ack = 47, "hi"

       - ack = 47 : Hello를 잘 수신하여 47번째 바이트를 받을 차례이다.

       - seq= 77 : 77번째 바이트를 전송했다. Hi (H가 77번째 바이트)

    3.  송신측에서 seq=47, ack = 79, "" (아무런 내용을 보내지 않음)
       - seq=47 : 47번 째 바이트를 보내고 있다. (하지만 아무런 데이터가 없다)
       - ack = 79 : 79번째 바이트를 받을 차례이다.

  - 수신측 TCP에서는 응용계층에게 송신측에게서 받은 데이터를 전달하고 0.5 초 정도 기다리고 응용계층에서 보낼 메세지가 있다면 Ack메세지와 함께 보낸다. (응용 계층에서 보낼 정보가 있는지 확인하기 위해 기다리는 시간) 만약 아무런 응답이 업다면, 그냥 내용 없이 Ack만 보낸다.

- **헤더길이 정보 (4bit) & 플래그들 & Window Size** 

  - 헤더 길이 : 총 헤더이 길이를 알려주어서 헤더와 헤더 이외의 데이터를 구분하기 위함

  - 플래그 : 특수 목적을 위한 세그먼트인지 확인 (TCP 연결 등의 목적)
  - Window Size : 현재 사용가능한 버퍼의 사이즈를 보내서 데이터를 얼마나 받을 수 있는지 송신측에 알려주어 데이터의 송신을 제어함 (받을수 없는 상황이면 보내지 않음)

- **Check Sum**

  - 내용 변조 탐지를 위해 존재하는 기법 (TCP와 UDP에 모두 존재)

  - TCP 헤더와 페이로드 내용이 변경되었는지 확인하기 위해 사용

  - 16bit 단위로 헤더와 페이로드를 전부 check sum(캐리가 없는 덧셈 : XOR) 해준 후 1의 보수(반전)를 취한것이 Check sum 이다.

    >  TCP 세그먼트 : TCP 헤더 + Payload( TCP Body )

#### 2.2.3. 혼잡제어

병목현상이 발생하면 버퍼에서 오버플로우가 발생할 가능성이 높아진다. 그렇게 되면 수신측은 받지못한 패킷을 송신측에게 계속 재전송 요청을 하게 될 것이고, 이는 결국 병목현상을 더욱 악화시키게 될 것이다. 이러한 현상을 방지하기 위해서 혼잡제어가 필요하다.

- 혼잡 인지

  1. 패킷 유실

     - 패킷의 유실이 발생하면 혼잡 상황을 인식한다.
     - 패킷이 유실하지 않으면 비혼잡 상황으로 인식한다.

  2. Ack 신호가 Timeout내에 오지 않음

     - Timeout은 너무 길거나(재송신 지연) 짧아서(false alarm 가능성)는 안된다.

       - RTT (Round Trip Time) : 요청해서 응답을 받기까지 걸리는 시간

       - RTO(Retransmission Time-out) = max(RTT의 평균 + 4*RTT의 표준편차, 1초)
         - 1초보다는 더 작을 수 없다.

     - RTT평균 구하기

       - Weighted moving average : 현재와가까운 RTT의 값의 가중치를 더 높게 둔 평균

         - RTTn = RTT의 n번째 측정 값

         - avg(RTTn) = n번째 후 RTT의 평균

         - avg(RTT1) = RTT1

         - avg(RTTn) = (1-a) * avg(RTTn-1) + a * RTTn (a는 가중치 : 약 0.25)

           = a * RTTn + (1-a) * a * RTTn-1 +  (1-a)^2 * a * RTTn-2 + ...

- 혼잡 제어

  - AIMD(Additive Increase Muliplicative Decrease) : 증가할 때는 덧셈으로 증가시키고, 줄일떄는 배수로 감소시킨다.

    =>패킷 전송 전송률을 줄인다. (보통 현재 전송률의 **절반**으로 줄인다.)

    =>패킷 전송률을 높인다. (보통 현재 전송률 + 상수)