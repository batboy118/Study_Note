# 02. 응용 계층

> 네트워크의 응용계층에 대해서 학습한다.

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./README.md)

---

<!-- TOC -->

- 

<!-- /TOC -->

## 1. 응용 계층의 예시

- 인터넷 브라우저 상의 응용
  - 구글 검색, 웹툰, 신문, 블로그, 카페, 금융, 쇼핑몰 등
- 이메일
- 게임
  - 스타크래프트, LOL 등
- 토렌트
- 파일 저장 서비스
- 스트리밍 서비스
- 지도 서비스
- SNS 서비스
- 예매 서비스

## 2. 네트워크 응용의 구조

- Client - Server 구조
  - 예 : 웹 검색
- Peer-to-Peer(P2P) 구조
  - 예 :  토렌트
- 하이브리드 구조
  - 클라이언트 - 서버 구조와 P2P 구조 동시 사용
  - 서버가 모든것을 개입하게 되면 부하가 심하기 때문에, 서버의 역할은 최소한으로 하고, 서버가 필요없는 기능은 P2P로 한다.
  - 예 : 스타크래프트, 스카이프(연결해주는 것은 서버로 해주지만 연결 후에는 P2P로 한다)

## 3. 프로세스간 통신

- 응용

  - 네트워크로 연결된 컴퓨터들이 협력하여 제공하는 서비스

    예) 구글 검색 (클라이언트는 서버에 서비스를 요청하고, 여러개의 서버 단말이 협력하여 서비스를 제공)

- 프로세스

  - 하나의 컴퓨터에서 독립된 메모리 공간을 가지고 수행되고 있는 프로그램의 단위

    예) 클라이언트 - 서버 : 클라이언트 프로세스 = 웹브라우저, 서버 프로세스 = 웹서버

    예) P2P : Peer 프로세스 = 토렌트

## 4.  프로세스 주소

어떻게 프로세스를 찾을 것인가?

- 기계 주소 : IP (32bit)
- 포트 번호 : TCP(16bit) / UDP(16bit)
  - 하나의 컴퓨터에서 제공하는 내부 주소
  - 주로 TCP 포트를 사용한다.
  - 웹서버 포트번호는 80으로 정해져 있다.
  - 웹 브라우저의 포트번호는 정해져 있지 않다.
  - 일반적으로 클라이언트에서 서버에 먼저 접속하기 때문에, 클라이언트가 패킷을 보낼때 클라이언트의 IP주소와 포트 번호를 둘다 보낸어 웹브라우저의 포트번호를 웹서버에서 알 수 있게 된다.

## 5. 소켓 통신

초기 통신 후 어떤 두 대상(클라이언트 - 서버 등)간의 통신을 Private Channel을 통해 할 수 있게 소켓을 이용할 수 있다.

소켓을 이용하면 서로 누군지 기억할 필요 없이 통신할 수 있다. 즉, 주소 없이 통신을 할 수 있다.

- 클라이언트 소켓 코드

```python
import socket

clientSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #클라이언트 소켓 생성
clientSocket.connect(("203.253.146.138",9999)) #상대팡 IP와 포트번호

clinetSocket.send("Hello. Server.")
str = clinetSocket.recv(100) 
print str

ClientSocket.close()
```

- 서버 소켓 코드

```python
import socket

serverSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  #서버 소켓 생성
serverSocket.bind(("",9999))  #9999번 포트를 연다.
serverSocket.listen(1)  #클라이언트가 접속할 때까지 기다리겠다.

(sock, addr) = serverSocket.accept()  #클라이언트가 접속을하면, accept해준다.
									#이때 특정 대상과 통신을 위한 sock 소켓 객체를 생성한다.
sock.send("Hello. Client.")
str = sock.recv(100)   # 100바이트를 받음
print str

sock.close()
serverSocket.close()
```

> 서버 실행 후 클라이언트 실행 하면 서버에서 Hello. Server.를 출력되고, 클라이언트에서는 Hello. Client. 가 출력됨

- 세션 계층(응용계층)과 전송계층을 연결해주는 것이 소켓이다.

  `참고)인터넷 전송 계층의 서비스 TCP와 UDP`

  > TCP
  >
  > - 연결 기반 전송계층
  >
  > - 연결에 대한 관리
  >   - 데이터 유실 복구
  >
  > - 데이터 순서 보장
  >
  > - 혼잡에 민감한 패킷 전송률 조정

  > UDP
  >
  > - 무 연결 전송계층
  > - 데이터 유실 가능
  > - 데이터 순서 보장하지 않음
  > - 최대한의 성능으로 패킷 전송

## 6. 세션 계층(FTP와 HTTP)

세션 계층에서 대표적인 두 가지 프로토콜 FTP와 HTTP에 대해서 살펴보자.

### 6.1. FTP (File Transfer Protocol)

- 목적 : 원격 host에 있는 파일을 가져오거나, 원격 host에 파일을 보내기 위한 Protocol

- 가정

  1. 클라이언트는 서버의 파일을 읽을 수 있는 권한의 계정이 있다.
  2. 계정이 없는 경우도 접근 가능하도록 할 수 있다.

- 특징

  1. 세션 로그인과 종료가 존재한다.

  2. 로그인을 통하여 권한 획득

  3. 로그인 정보를 서버가 관리

  4. Stateful Protocol (상태정보를 사용하는 프로토콜)

     > cf ) FTP는 상태관리를 세션 레이어에서 하지만, HTTP는 상태관리를 하지 않고, 응용 계층에게 맞긴다.
     >
     > 세션 레이어에서 많은 것을 건드리는 것보다 윗단인 응용 계층에서 관리하는 것을 선호하기 때문이다. (세션 레이어는 어느정도 규약이 정해져 있어 거의 건드리지 않는다.)

- `wireshark` : 컴퓨터가 통신하는 모든 패킷을 다 보여주는 응용프로그램

  ftp를 이용해 원격 호스트에 접속하게 되면 wireshark를 통해 ftp의 통신 패킷을 볼 수 있다. 통신을 살펴보면, 주고받는 모든 패킷이 사용자 화면에 보이는 것이 아니라는 것을 알 수 있다. FTP 통신에서 주고받는 패킷의 일부의 내용만 화면에 보이게 되는데 이는 프레젠테이션(표현) 레이어로 연결된 패킷이라고 볼 수 있다. 반대로 화면에 보이지 않는 내용은 세션계층에서만 수행되는 통신이라고 볼 수 있다.

### 6.2. HTTP

- FTP에 비해 단순한 프로토콜이다.
- 세션 계층 (WWW을 위한)

- HTML을 기본 프레젠테이션 레이어로 사용함

- 목적 : 전세계 인터넷에 있는 정보를 탐색
- 동작
  - web자료를 가져와서 보여주기 위해 사용(GET)
  - web에 자료를 posting 하기 위해 사용(POST)

- URL (Universal Resource Locator)

  - 전 세계에 하나 밖에 없는 위치

  - `http://github.com/batboy118/Study_Note`

    1. `http:` : 프로토콜 이름

       > cf)참고
       >
       > `file:`  : 로컬 컴퓨터내의 파일에 접근 예) `file:///D:/`
       >
       > `ftp:`  : 해당 주소가 ftp를 지원한다면, ftp 프로토콜을 이용해 접근하는 것도 가능하다.

    2. `//` : url의 시작을 알려줌

    3. `github.com` : 호스트 이름 (ip대신에 사용하는 주소)

    4. `/batboy118/Study_Note` : 서버 컴퓨터에서 특정 자원의 상대 위치