# 02. Linux에서 C 사용하기


> Linux환경에서 C를 사용할 때 알아야 할 사항들을 정리하였습니다.
>
> 참고자료 : [링크1](https://www.joinc.co.kr/w/Site/C/Documents/CprogramingForLinuxEnv)

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./)

---

<!-- TOC -->

<!-- /TOC -->

## 1. 필요한 요소

개발환경을 위해서는 최소한 아래의 툴들이 필요하다. 아래의 툴들은 완전히 공개되었으며 GPL을 따르는 소프트웨어들이다.

1. 에디터 : 코드를 짤려면 당연히 에디터가 준비되어 있어야 한다.
2. 컴파일러 : C언어에 의해서 짜여진 코드는 **인간**이 쉽게 이해할 수 있는 코드이다. 기계는 이 코드를 이해할 수 없으므로, 기계가 이해할 수 있는 **기계어**로 변경해줘야 한다. 컴파일러는 인간이 인지할 수 있는 C로 작성된 코드를 컴퓨터가 인지 **기계어**된 실행파일로 만들어준다. 번역기라고 생각하면 된다.

기본적으로 위의 2개의 툴만 설치되면 C언어를 배우는데, 전혀 문제가 없다. 그러나 C언어를 이용해서 그럴듯한 프로그램을 만들려면 몇가지 툴들이 더 갖추어진 환경을 만들 필요가 있다.

1. 디버거 : C언어가 아무리 인간이 이해하기 쉽도록 만들어졌다고는 하지만, 여전히 기계(컴퓨터)의 입장에서 생각을 해야 한다. 그러다 보니 많은 실수가 생길 수 밖에 없다. 어떤 실수는 쉽게 찾아낼 수 있지만 어떤 실수는 찾아내기 매우 어렵다. 디버거를 이용하면, 잘못된 부분을 좀더 쉽게 찾아서 수정할 수 있다.
2. Make툴 : 아주 작은 프로그램이 아닌 이상, 관리나 유지보수의 목적으로 여러개의 코드파일로 구성이 된다. make를 이용하면 이들 코드를 좀더 쉽게 유지할 수 있다. 프로젝트 관리를 위한 툴이라고 보면된다.
3. 형상관리도구 : cvs, svn등으로 공동작업을 할때, 코드 파일이 꼬이지 않도록 도와주며, 버젼을 관리할 수 있도록 해준다. 여기에서는 형상관리툴에 대해서는 다루지 않을 것이다. 아마도 꽤 큰 규모의 프로젝트를 하기전엔 필요없긴 하겠지만, 관심이 있다면 링크를 따라가서 읽어보기 바란다.

> 1. 에디터 : vim
>
> 2. 컴파일러 :gcc

## 2. C 프로그램 빌드 과정

인간이 이해하기 쉬운 C언어를 이용해서 **프로그램**을 만들었다면, 이를 컴퓨터가 이해할 수 있는 기계어 파일로 번역해서 컴퓨터가 실행할 수 있는 **실행파일**의 형태로 만들어야 한다. 이러한 일을 하는 프로그램을 **컴파일러**라고 한다. 이미 우리는 hello world 프로그램 예제를 통해서, **컴파일러**를 이용해서 실행파일을 만들고 이를 실행시키는 방법에 대해서 알아보았다. 여기에서는 어떠한 과정을 거쳐서 실행파일이 만들어지는지에 대해서 알아보도록 하겠다.

1. **소스 코드 생성**

   인간이 이해할 수 있는 언어로 프로그램을 작성한다. 이것을 소스코드라고 하는데, 여기에는 컴퓨터에게 내릴 명령들이 포함되어 있다. 소스코드는 인간이 쉽게 이해할 수 있지만, 컴퓨터는 이해할 수 없기 때문에 컴퓨터가 이해할 수 있도록 번역하는 과정이 필요하다.

2. **Preprocessor**

   컴파일러를 실행시키면 가장 먼저 **precompile**를 수행한다. 프로그래머가 생성한 소스코드는 인간이 보다 쉽게 읽을 수 있도록 하기 위해서 include나 **매크로**등을 이용해서 코드가 축약되어 있다. precompile는 축약된 내용을 컴파일러가 쉽게 해석할 수 있도록 풀어쓰는 과정이다.

3. **Assembly 코드의 생성**

   이제 풀어쓴 코드를 가장 원시적인 언어의 형태인 Assembly코드로 만들어준다. 어셈블리코드는 기계어와 1:1로 대응되기 때문에 일단 어셈블리코드로 성공적으로 만들어낸다면 쉽게 기계어형태로 변환할 수 있다.

4. **Object 파일의 생성**

   Assembly 코드가 만들어졌다면, 이제 이걸 기계어로 변환한다. 이렇게 해서 만들어진 파일을 object파일이라고 한다.

5. **linker**

   그러나 object파일이 생겼다고 바로 실행될 수 있는게 아니다. 프로그램으로써 실행하기 위해서는 운영체제가 제공하는 다른 여러가지 객체(기능)들과 연결(link)되어야 한다. link과정을 거치면 비로서 실행가능한 완전한 프로그램이 만들어지게 된다.

## 3. int main

함수의 리턴값이 자기를 호출한 함수에게 결과값을 넘겨주기 위해서 필요하다는 것을 이해했을 것이다. 그렇다면 main 함수의 리턴값은 어떻게 설명해야 할까. main은 가장 상위에 있는 함수인데, int main 이라면 누구에게 값을 넘겨줄 건지가 궁금할 것이다.

main의 리턴값은 자신을 실행시킨 프로세스에게 넘겨진다. 보통은 shell에서 프로그램을 실행시킬테니, 실행 shell로 값이 리턴된다. bash:::shell을 사용하고 있다면 다음과 같이 리턴값을 확인해 볼 수 있다.

main 함수의 리턴값이 정말 전달되는지 확인해보자. 아래와 같은 간단한 코드를 만들고 main_return.c 로 저장한 후 컴파일 해보자.

main 함수의 리턴값이 정말 전달되는지 확인해보자. 아래와 같은 간단한 코드를 만들고 main_return.c 로 저장한 후 컴파일 해보자.

```c
int main(int argc, char **argv)
{
  return 2;
}
```

이제 실행시키면, main 함수의 리턴값 2가 출력되는걸 확인할 수 있을 것이다. main 함수의 리턴값은 프로그램이 종료될때 되돌려지는 값이므로, 리턴값 이란 용어대신 **종료값**이란 용어를 사용한다. 앞으로는 **종료값**이란 용어를 사용하도록 하겠다.

```bash
# ./main_return
# echo $?
2
```

$? 는 bash:::shell에서 최근실행 시킨 프로그램의 종료값을 저장하고 있는 특수변수다.

## 4. 헤더파일의 경로

우리는 #include 키워드를 이용해서, 포함시킬 헤더파일을 지정할 수 있다. 이때 헤더파일의 완전한 경로를 포함시켜 줘야 한다. 만약 따움표를 사용했다면, 이는 현재 디렉토리에서 헤더파일을 찾겠다는 것을 의미한다. 그렇지 않고 **<>** 를 사용했다면, **표준 Include 디렉토리**와 컴파일러 옵션을 통해서 **지정된 디렉토리**에서 찾게된다. 유닉스 시스템의 경우 /usr/include 가 표준 Include 파일이 된다.

헤더파일을 찾을 경로의 지정은 **-I**옵션을 이용하면 된다. 예를 들어 /home/yundream/include 에서 찾도록 하길 원한다면

```
# gcc -I/home/yundream/include -o sum sum.c
```

와 같이 하면 된다.

만약 /home/yundream/include 를 헤더파일 찾기 경로로 지정하고 싶다면, 다음과 같이 하면 된다.

```
#include "/home/yundream/include"
```

## 5. 모듈별 분할 컴파일

그럼 덧셈 함수를 가진 계산기 프로그램을 만들어서, 모듈별로 작성하고 이것들을 object 파일로 만들어서 link 시켜서 실행파일을 만드는 방법에 대해서 알아보도록 하겠다.

1. sum 함수의 선언이 들어 있는 include 파일
2. sum 함수를 사용할 main 함수가 있는 C 파일
3. sum 함수가 정의되어 있는 C 파일

include 파일은 아주 간단하게 만들 수 있다. include 파일의 이름은 sum.h 로 하겠다.

```
int sum(int a, int b);
```

이제 sum 함수가 정의되어 있는 C 코드를 만들어보자. 역시 간단하다. 파일이름은 sum.c로 하겠다.

```
int sum(int a, int b)
{
    return a + b;
}
```

마지막으로 main 함수를 만들어 보자. 파일이름은 calc.c 로 하겠다.

```
#include "sum.h"
#include <stdio.h>

int main()
{
    int value;
    value = sum(130, 199);
    printf("%d\n", value);
}
```

자 이제 sum.h, sum,c, calc,c 3개의 파일이 만들어졌다. 이 3개의 파일을 컴파일해서 실행가능한 프로그램을 만들어보자.

위에서 언급되었듯이 가장 먼저 해야할일은 sum.c 와 calc.c 를 기계어가 해석가능한 object 코드로 만드는 일이다. 오브젝트 코드는 gcc에 -c 옵션을 이용해서 만들어낼 수 있다.

```
# gcc -c sum.c calc.c
```

이제 sum.o 와 calc.o 라는 파일이 만들어진걸 확인할 수 있을 것이다. 확장자 **.o**는 이 파일이 오브젝트 파일이라는 것을 알려준다. 이제 두개의 object 파일을 링크시켜서 실행파일을 만들면 된다. -o 옵션을 이용하면, 만들어진 오브젝트 파일들을 합쳐줄 수 있다.

```
# gcc -o calc sum.o calc.o
```

이제 실행파일인 **calc**가 만들어졌다.

이렇게 만들어진 object 파일은 **기계어**로 만들어져 있기 때문에, 이후에 사용할때는 sum.c를 다시 object 파일로 컴파일할 필요가 없다. 그냥 sum.o 프로그램에 링크시켜주기만 하면 된다. 다음과 같은 프로그램을 만들어보자. 프로그램의 이름은 mycal.c로 하자.

```
#include "sum.h"
#include <stdio.h>

int main(int argc, char **argv)
{
  int value;
  int a;
  int b;
  if (argc != 3)
  {
    printf("Usage : %s num1 num2\n", argv[0]);
    return 1;
  }

  a = atoi(argv[1]);
  b = atoi(argv[2]);
  value = sum(a, b);
  printf("%d + %d = %d\n", a, b, value);
  return 0;
}
```

이 프로그램은 첫번째 프로그램보다 더 진보된 프로그램으로, 프로그램의 명령행 인자로 받아들인 숫자를 더할 수 있도록 되어 있다. atoi(3)는 문자열을 int형 숫자로 변환해주는 함수다. sum 함수는 이미 컴파일 되어서 object 파일로 만들어져 있으므로, 별도로 컴파일할 필요가 없다. 다음과 같은방법으로 실행파일을 만들 수 있다.

## 6. 라이브러리

단위 함수를 별개의 소스코드와 헤더파일로 나누어서 관리하게 되면, object 혹은 단위 소스코드 파일을 재활용할 수 있다는 장점을 가진다. 그러나 여전히 불편한 점이 있다. 함수가 많아지면, 자칫 수십개의 오브젝트 파일이 생성될 수 있을건데, 이들을 관리하는건 매우 귀찮은 일이기 때문이다.

그렇다면 4개의 object 파일을 하나로 묶을 수만 있다면, 함수들을 더 편리하게 관리할 수 있을 것이다. 이렇게 오브젝트들을 하나의 파일로 다시 묶은 것을 라이브러리(library)라고 한다.

라이브러리는 다시 **정적 라이브러리**와 **공유 라이브러리**로 나뉜다. 정적라이브러리는 실행파일에 완전히 포함되어버리는 형식의 라이브러리를 말한다. 반면 공유 라이브러리는 실행파일에 포함되지 않고, 실행될때 해당 라이브러리를 불러오는 형식의 라이브러리를 말한다.

### 6.1. 정적라이브러리

**static library**라고 부르기도 한다. 이 라이브러리는 단순한 오브젝트의 모음일 뿐이다. 정적라이브러리는 **ar**이라는 프로그램을 통해서 만들 수 있다. 그럼 ar을 이용해서 위의 사칙연산을 위한 4개의 오브젝트를 모아서 **libmycalc.a**라는 이름의 정적라이브러리를 생성해보도록 하자. **rc** 옵션을 이용하면, 정적라이브러리를 만들 수 있다.

**r**은 정적라이브러리를 만들겠다는 옵션이고, **c**는 새로 생성을 하겠다는 옵션이다.

```
# ar rc libmycalc.a sum.o sub.o mul.o div.o
```

libmycalc.a 라는 파일이 생성된걸 확인할 수 있을 것이다. **t** 옵션을 이용하면, 해당 라이브러리가 어떤 오브젝트를 포함하고 있는지도 확인할 수 있다. **t** 옵션을 사용하면 된다. 참고로 정적 라이브러리의 이름은 **lib[NAME].a**의 형식을 따라야 한다.

```
# ar t libmycalc.a
div.o
mul.o
sum.o
sub.o
```

그럼 정적라이브러리를 이용해서 실행파일을 만들어 보도록 하자. 이전에는 4개의 오브젝트 파일을 모두 링크시켜줘야 했지만, 이제는 libmycalc.a 만 링크시켜주면 된다.

라이브러리의 링크방식은 오브젝트를 링크하는 것과는 약간 차이가 있다. library의 위치를 명확히 명시해 주어야 한다. **-L** 옵션을 이용해서 라이브러리가 있는 디렉토리의 위치를 명시해주고, **-l**옵션을 이용해서, 라이브러리 파일의 이름을 정해줘야 한다. 다음은 simplecalc.c 를 정적라이브러리를 이용해서 컴파일하는 방법을 보여준다.

```
# gcc -o simplecalc simplecalc.c -L./ -lmycalc
```

**-L./**은 현재 디렉토리를 라이브러리 찾기 디렉토리로 하겠다는 의미가 된다. **-l** 옵션뒤에 붙이는 라이브러리 파일의 이름에 주목할 필요가 있다. 라이브러리 이름은 **lib**와 **.a**를 제외한 이름을 사용한다.

### 6.2. 공유 라이브러리

공유 라이브러리는 **함께 사용하는 라이브러리**라는 의미다. 즉 정적 라이브러리 처럼 실행파일에 붙는 것이 아니고, 시스템의 특정디렉토리에 위치하면서, 다른 모든 프로그램들이 **공유**해서 사용할 수 있게끔 제작된 라이브러리다. 그러므로 공유 라이브러리를 사용하도록 제작된 프로그램은 실행시에 사용할 라이브러리를 **호출**하는 과정을 거치게 된다.

공유 라이브러리역시 **오브젝트**를 이용해서 만든다는 점에서는 정적라이브러리와 비슷하지만, 호출시에 링크하기 위한 부가적인 정보를 필요로 하므로, 정적라이브러리와는 전혀 다른 형태로 만들어 진다. 정적라이브러리와 이름이 헛갈릴 수 있으니, 라이브러리 이름은 mycalcso 로 하겠다.

```
# gcc -fPIC -c sum.c sub.c mul.c div.c
# gcc -shared -W1,-soname,libmycalcso.so.1 -o libmycalcso.so.1.0.1 sum.o sub.o mul.o div.o
```

1. 오브젝트 파일을 만들때 부터 차이가 있는데, -fPIC 옵션을 줘서 컴파일 한다.
2. 그다음 -shared 옵션을 이용해서 공유라이브러리 파일을 생성한다.

위의 과정을 끝내고 나면, libmycalcso.so.1.0.1 이라는 파일이 생성이 된다. 이 라이브러리는 프로그램을 컴파일할때와 실행시킬때 호출이 되는데, 호출될때는 libmycalcso.so 를 찾는다. 그러므로 ln 명령을 이용해서 libmycalcso.so 링크파일을 생성하도록 하자.

```
# ln -s libmycalcso.so.1.0.1 libmycalcso.so
```

이렇게 링크를 만들게 되면, 여러가지 버전의 라이브러리 파일을 이용할 수 있으므로 관리상 이점을 가질 수 있다. 새로운 버전의 라이브러리가 나올 경우, 오래된 버전의 라이브러리를 쓰는 프로그램은 실행시 문제가 발생할 수 있는데, 이런 문제를 해결할 수 있기 때문이다.

이제 링크하는 과정이 남았다. 링크과정은 정적 라이브러리를 사용할때와 동일하다.

```
# gcc -o simplecalcso simplecalc.c -L./ -lmycalcso
```

이제 프로그램을 실행시켜 보도록 하자. 아마 다음과 같은 에러메시지를 만나게 될 것이다.

```
# ./simplecalcso
./simplecalcso: error while loading shared libraries: libmycalc.so: 
cannot open shared object file: No such file or directory
```

이러한 에러가 발생하는 원인에 대해서 알아보도록 하자. 정적라이브러리는 실행파일에 라이브러리가 붙여지므로, 일단 실행파일이 만들어지면, 독자적으로 실행이 가능하다. 그러나 공유라이브러리는 라이브러리가 붙여지는 방식이 아니고, 라이브러리를 호출해서 해당 함수코드를 실행하는 방식이다. 그러므로 공유라이브러리 형식으로 작성된 프로그램의 경우 **호출할 라이브러리의 위치**를 알고 있어야만 한다.

위의 simplecalcso 프로그램을 실행시키면, 이 프로그램은 libmycal.so 파일을 찾을 것이다. 이때 파일을 찾는 디렉토리는 **/etc/ld.so.conf**에 정의 되어 있다.

```
# cat /etc/ld.so.conf
/usr/lib
/usr/local/lib
```

만약 위에서 처럼되어 있다면, 프로그램은 /usr/lib 와 /usr/local/lib 밑에서 libmycal.so 를 찾게 될 것이다. 그런데 libmycal.so 가 없으니, 위에서와 같은 에러가 발생하는 것이다.

가장 간단한 방법은 라이브러리 파일을 ld.so.conf에 등록된 디렉토리중 하나로 복사하는 방법이 될 것이다. 혹은 환경변수를 이용해서, 새로운 라이브러리 찾기 경로를 추가할 수도 있다. 이때 사용되는 환경변수는 LD_LIBRARY_PATH 다.

```
# export LD_LIBRARY_PATH=./:/home/myhome/lib
```

이제 프로그램을 실행시키면 LD_LIBRARY_PATH 에 등록된 디렉토리에서 먼저 검색하게 되고, 프로그램은 무사히 실행 될 것이다.

### 6.3. 공유라이브러리와 정적라이브러리의 장단점

이들 2가지 라이브러리의 장단점에 대해서 알아보도록 하자. 장단점을 알게되면 어떤 상황에서 이들 라이브러리를 선택할 수 있을지 알 수 있을 것이다.

정적라이브러리의 장점은 간단한 배포방식에 있다. 라이브러리의 코드가 실행코드에 직접 붙어버리는 형식이기 때문에, 일단 실행파일이 만들어지면 간단하게 복사하는 정도로 다른 컴퓨터 시스템에서 실행시킬 수 있기 때문이다. 반면 동적라이브러리는 프로그램이 실행될때 호출하는 방식이므로, 라이브러리까지 함께 배포해야 한다. 라이브러리의 호출 경로등의 환경변수까지 덤으로 신경써줘야 하는 귀찮음이 따른다.

일반적으로 정적라이브러리는 동적라이브러리에 비해서 실행속도가 빠르다. 동적라이브러리 방식의 프로그램은 라이브러리를 호출하는 부가적인 과정이 필요하기 때문이다.

정적라이브러리는 실행파일 크기가 커진다는 단점이 있다. 해봐야 얼마나 되겠느냐 싶겠지만, 해당 라이브러리를 사용하는 프로그램이 많으면 많을 수록 **X 프로그램수**만큼 디스크 용량을 차지하게 된다. 반면 공유라이브러리를 사용할 경우, 라이브러리를 사용하는 프로그램이 10개건 100개건 간에, 하나의 라이브러리 복사본만 있으면 되기 때문에, 그만큼 시스템자원을 아끼게 된다.

마지막으로 버전 관리와 관련된 장단점이 있다. 소프트웨어 개발 세계의 불문율이라면 **버그 없는 프로그램은 없다**이다. 어떠한 프로그램이라도 크고작은 버그가 있을 수 있으며, 라이브러리도 예외가 아니다.

여기 산술계산을 위한 라이브러리가 있다. 그리고 정적 라이브러리 형태로 프로그램에 링크되었어서 사용되고 있다고 가정해보자. 그런데 산술계산 라이브러리에 심각한 버그가 발견되었다. 이 경우 산술계산 라이브러리를 포함한 A 프로그램을 완전히 새로 컴파일 해서 배포해야만한다. 문제는 이 라이브러리가 A 뿐만 아니라 B, C, D 등의 프로그램에 사용될 수 있다는 점이다. 결국 B, C, D 프로그램 모두를 새로 컴파일 해서 배포해야 하게 된다. 더 큰 문제는 어떤 프로그램이 버그가 있는 산술계산 라이브러리를 포함하고 있는지 알아내기가 힘들다는 점이다.

공유라이브러리 형태로 작성하게 될경우에는 라이브러리만 새로 컴파일 한다음 바꿔주면된다. 그러면 해당 라이브러리를 사용하는 프로그램이 몇개이던간에 깔끔하게 문제가 해결된다.

실제 이런 문제가 발생한 적이 있었다. zlib 라이브러리는 압축을 위한 라이브러리로 브라우저, 웹서버, 압축관리 프로그램등에 널리 사용된다. 많은 프로그램들이 이 zlib를 정적라이브러리 형태로 포함해서 배포가 되었는데, 심각한 보안문제가 발견되었다. 결국 zlib를 포함한 모든 프로그램을 새로 컴파일해서 재 설치해야 하는 번거로운 과정을 거치게 되었다. 공유라이브러리였다면 문제가 없을 것이다.

이상 정적라이브러리와 공유라이브러리를 비교 설명했다. 그렇다면 선택의 문제가 발생할 것인데, 자신의 컴퓨터나 한정된 영역에서 사용할 프로그램을 제작하지 않는한은 공유라이브러리 형태로 프로그램을 작성하길 바란다. 특히 인터넷을 통해서 배포할 목적으로 작성할 프로그램이라면, 공유라이브러리 형태로 작성하는게 정신건강학적으로나 프로그래밍 유지차원에서나 좋을 것이다.

## 7. 모든 입출력은 파일로 처리한다

대표적인 입력장치는 **키보드, 마우스, 터치패드, 카메라**등이 될 것이다. 출력장치는 **모니터, 프린터, 사운드 카드**를 예로 들 수 있다.

유닉스 운영체제는 모든 입출력과 관련된 장치는 **파일**과 동일하게 보고 처리를 한다. 하드디스크의 경우 **C:**, **D:**와 같이 다루어지는 것과는 달리, 유닉스는 **장치파일**이라는 특수한 파일 형태로 다른다. 뿐만 아니라 프린트, 사운드카드 까지도 파일의 형태로 다룬다. 이러한 장치파일들은 **/dev** 디렉토리 밑에 존재한다. 예를들어 윈도우즈에서 말하는 C: 드라이브는 /dev/hda1 과 같은 파일이름으로, 프린터기는 /dev/lp0 이라는 파일이름으로 존재한다.

컴퓨터에 사용되는 장치를 **파일**의 개념으로 놓고 본다는 것은 윈도우즈환경을 주로 사용했던 유저에게는 그리 익숙하지 않을 것이다. 그러나 조금만 생각해 보면 **적어도 개발자**입장에서는 매우 합리적인 개념임을 알 수 있을 것이다. 파일과 마찬가지로 **읽고, 쓴다**라는 개념이 그대로 적용되며, 일반 파일에 사용되는 방법과 동일한 방식으로 다양한 종류의 장치를 다룰 수 있기 때문이다. 물론 각 장치들은 읽고 쓰기 위한 **전용의 프로토콜**을 사용하기 때문에 프로토콜에 대한 학습이 필요하긴 하지만 사용되는 함수등은 일반 파일을 다룰때와 동일하다고 보면 된다.

이렇게 모든걸 파일로 다루게 됨으로써, 장치에 대한 별도의 학습없이도 일관성있게 프로그램을 작성할 수 있게 된다.

하지만 여기에서는 다른 장치들에 대한 입출력을 다루지는 않을 것이다. 가장 기본이 되는 **파일**에 대한 입출력 만을 다룰 것이다.

## 3. file description

"abc.txt" 라는 파일을 읽거나 쓰기 위해서는 파일을 **open**하는 과정을 거친다. 그러면, 운영체제는 파일을 쉽게 다룰 수 있도록 int 형의 숫자를 넘겨준다. 이후에 파일에 쓰거나 읽는 작업은 파일이름이 아닌 이 **숫자**를 통해서 이루어지게 된다. 이 숫자를 **file description**이라고 한다. 혹은 **파일지시자**라고 부르기도한다.

## 5. 파일 입출력

그러면 유닉스 프로그래밍에 있어서 가장 중요한 **파일 입출력**에 대해서 알아보도록 하겠다. 기본적으로는 표준입력/출력/에러를 다루는 방식과 동일 하다.

다른점이 있다면, 표준입력 등은 운영체제가 알아서 열어주지만, 다른 파일들은 프로그래머가 함수를 이용해서 파일을 직접 열어주어야 한다는 점이다.

해서 파일 입출력에는 read(2)와 write(2)외에 파일을 열기 위한 open(2)과 닫기 위한 close(2)가 사용된다. 원칙적으로는 이 네가지의 함수만 있으면 거의 대부분의 파일과 관련된 작업을 할 수 있다.

이들 함수에 대한 자세한 설명은 링크로 연결되는 man page를 참고하기 바란다.

