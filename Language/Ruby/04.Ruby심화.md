# 04. Ruby ì‹¬í™” ê°œë…

>

[ğŸ Home](https://github.com/batboy118/Study_Note)

[â—€Previous page ](./README.md)

---

<!-- TOC -->

- [1. ì‹¬ë³¼](#1-ì‹¬ë³¼)
- [2. í”„ë¡, ë¸”ë¡, ëŒë‹¤](#2-í”„ë¡-ë¸”ë¡-ëŒë‹¤)
	- [2.1. í”„ë¡](#21-í”„ë¡)
	- [2.2. ëŒë‹¤](#22-ëŒë‹¤)
- [3. !ì™€ ?](#3-ì™€-)
- [4. unlessì™€ until](#4-unlessì™€-until)
- [5. loop do, break ifì™€ next if](#5-loop-do-break-ifì™€-next-if)
- [6. ê°€ë³€ì¸ì *](#6-ê°€ë³€ì¸ì-)
- [7. ê²°í•©ëœ ë¹„êµì—°ì‚°ì <=>](#7-ê²°í•©ëœ-ë¹„êµì—°ì‚°ì-)
- [8. select ë©”ì†Œë“œ](#8-select-ë©”ì†Œë“œ)
- [10. eachkey, eachvalue ë©”ì†Œë“œ](#10-eachkey-eachvalue-ë©”ì†Œë“œ)
- [11. caseë¬¸](#11-caseë¬¸)
- [12. ifë¬¸ ë³€í˜•](#12-ifë¬¸-ë³€í˜•)
- [13. ||= ì—°ì‚°ì (Conditional Assignment)](#13--ì—°ì‚°ì-conditional-assignment)
- [14. upto](#14-upto)
- [15. Call and Response](#15-call-and-response)
- [16. << ì—°ì‚°ì](#16--ì—°ì‚°ì)
- [17. í´ë˜ìŠ¤ì™€ ì¸ìŠ¤í„´ìŠ¤ ì‹¬í™”](#17-í´ë˜ìŠ¤ì™€-ì¸ìŠ¤í„´ìŠ¤-ì‹¬í™”)
	- [17.1 ë³€ìˆ˜ì˜ ìŠ¤ì½”í”„](#171-ë³€ìˆ˜ì˜-ìŠ¤ì½”í”„)
	- [17.2 public / private](#172-public--private)
	- [17.3 attrreader ì‹¬ë³¼, attrwriter ì‹¬ë³¼, attraccessor ì‹¬ë³¼](#173-attrreader-ì‹¬ë³¼-attrwriter-ì‹¬ë³¼-attraccessor-ì‹¬ë³¼)
- [18. ëª¨ë“ˆ ì‹¬í™”](#18-ëª¨ë“ˆ-ì‹¬í™”)
	- [18.1 namespacing](#181-namespacing)
- [18.2 require](#182-require)
	- [18.3 include](#183-include)
	- [18.4 extend](#184-extend)

<!-- /TOC -->

## 1. ì‹¬ë³¼

ë£¨ë¹„ì—ëŠ” symbolì´ë¼ëŠ” ê°ì²´ë„ ì¡´ì¬í•œë‹¤. `String` ê°ì²´ì™€ëŠ” ë‹¤ë¥´ê²Œ ê°™ì€ ì´ë¦„ì˜ ì‹¬ë³¼ì€ í•˜ë‚˜ì˜ ë£¨ë¹„ ì„¸ì…˜ ë™ì•ˆ ë‹¨ í•œë²ˆë§Œ ì´ˆê¸°í™”ë˜ë©° ë©”ëª¨ë¦¬ì— ì¡´ì¬í•œë‹¤. ì‹¬ë³¼ì€ ë¹„ê°€ë³€ì ì´ë©°, ëŸ°íƒ€ì„ ë™ì•ˆ ë³€ê²½í•  ìˆ˜ ì—†ë‹¤ ë£¨ë¹„ ì¸í„°í”„ë¦¬í„°ëŠ” ì‹¬ë³¼ í…Œì´ë¸”ì— ì‹¬ë³¼ì— í•´ë‹¹í•˜ëŠ” ëª¨ë“  í´ë˜ìŠ¤, ë§¤ì„œë“œ, ë³€ìˆ˜ë¥¼ ì €ì¥í•œë‹¤. ì‹¬ë³¼ì€ ì´ë¦„ ì•ì— ì½œë¡ `:`ì„ ë¶™ì—¬ ë§Œë“ ë‹¤.

```ruby
> puts :name.object_id # => yields 20488
> puts :name.object_id # => yields 20488
> puts "name".object_id # => yields 2168472820
> puts "name".object_id # => yields 2168484060
```

ë¬¸ìì—´ ë‚´ë¶€ì˜ ì»¨í…ì¸ ë¥¼ ë‹¤ë£°ë•ŒëŠ” ë¬¸ìì—´ì„ ì‚¬ìš©í•˜ê³ , ê°ì²´ì˜ ì•„ì´ë´í‹°í‹°ê°€ ì¤‘ìš”í•œ ê²½ìš°(ex>í•´ì‹œì˜ í‚¤)ëŠ” ì‹¬ë³¼ì„ ì‚¬ìš©í•˜ë¼.

```ruby
symbol_hash = {
  :one => 1,
  :two => 2,    # Fill in these two blanks!
  :three => 3,
}
```

í•´ì‹œì—ì„œ ì‹¬ë³¼ì„ í‚¤ë¡œ ì‚¬ìš©í•  ë•Œ ì‹¬ë³¼ì˜ `:`ë¥¼ ë’¤ë¡œ ì“°ê²Œë˜ë©´ keyê°’ì„ ë” í¸í•˜ê²Œ í‘œí˜„í•  ìˆ˜ ìˆë‹¤.

```ruby
movies = {
  one: "Godo",
  two: "123"
}
puts movies
```

ì‹¬ë³¼ê³¼ ìŠ¤íŠ¸ë§ì„ ì„œë¡œ ë³€í™˜í•  ìˆ˜ ìˆë‹¤.

```ruby
:sasquatch.to_s
# ==> "sasquatch"
"sasquatch".to_sym
# ==> :sasquatch

#Besides using .to_sym, you can also use .intern. This will internalize the string into a symbol and works just like .to_sym:
"hello".intern
# ==> :hello
```

ìŠ¤íŠ¸ë§ê³¼ ì‹¬ë³¼ì˜ ì†ë„ ë¹„êµ

```ruby
require 'benchmark'

string_AZ = Hash[("a".."z").to_a.zip((1..26).to_a)]
symbol_AZ = Hash[(:a..:z).to_a.zip((1..26).to_a)]

string_time = Benchmark.realtime do
  100_000.times { string_AZ["r"] }
end
symbol_time = Benchmark.realtime do
  100_000.times { symbol_AZ[:r] }
end

puts "String time: #{string_time} seconds."
puts "Symbol time: #{symbol_time} seconds."

#String time: 0.006994454997766297 seconds.
#Symbol time: 0.00474227200174937 seconds.
```

## 2. í”„ë¡, ë¸”ë¡, ëŒë‹¤

ë¸”ë¡ì—ë„ íŒŒë¼ë¯¸ì²˜ë¥¼ ì „ë‹¬í•  ìˆ˜ ìˆë‹¤.

```ruby
def yield_name(name)
  puts "In the method! Let's yield."
  yield("Kim")
  puts "In between the yields!"
  yield(name)
  puts "Block complete! Back in the method."
end

yield_name("Eric") { |n| puts "My name is #{n}." }
yield_name("Jaon") { |n| puts "My name is #{n}." }
# Now call the method with your name!
```

### 2.1. í”„ë¡

í”„ë¡ì´ë€ ë¸”ë¡ì„ ì¬í™œìš© ê°€ëŠ¥í•˜ê²Œ ë§Œë“  ê°ì²´ì´ë‹¤. ë£¨ë¹„ì—ì„œ ëŒ€ë¶€ë¶„ì€ ì˜¤ë¸Œì íŠ¸ì´ì§€ë§Œ, ë¸”ë¡ì€ ì˜¤ë¸Œì íŠ¸ê°€ ì•„ë‹ˆë‹¤. ë¸”ë¡ì´ ì˜¤ë¸Œì íŠ¸ê°€ ì•„ë‹ˆê¸° ë•Œë¬¸ì— ì €ì¥í•˜ëŠ” ê²ƒì´ ë¶ˆê°€ëŠ¥í•œë°, í”„ë¡ìœ¼ë¡œ ì´ëŸ° ê²ƒì„ í•´ê²°í•˜ì˜€ë‹¤.

```ruby
cube = Proc.new { |x| x ** 3 }
```

`&í”„ë¡`ì€ ë¸”ë¡ê³¼ ë§ˆì°¬ê°€ì§€ë¡œ ë™ì‘ì„ í•˜ê²Œëœë‹¤.

```ruby
[1, 2, 3].collect!(&cube)
# ==> [1, 8, 27]
[4, 5, 6].map!(&cube)
# ==> [64, 125, 216]
```

í”„ë¡ì€ í•¨ìˆ˜ì˜ ì¸ìë¡œ ì „ë‹¬í•˜ëŠ”ê²ƒê³¼ ë¸”ë¡ì„ í•¨ìˆ˜ì˜ ì¸ìë¡œ ì „ë‹¬í•˜ëŠ”ê²ƒì€ ì°¨ì´ê°€ ìˆë‹¤. í•˜ì§€ë§Œ, ë¸”ë¡ì„ í•¨ìˆ˜ì˜ ì¸ìë¡œ ì „ë‹¬í•  ë•Œ í•¨ìˆ˜ë‚´ë¶€ì—ì„œ ê·¸ ë¸”ëŸ­ì€ í”„ë¡ì²˜ëŸ¼ ì‚¬ìš©ì´ ëœë‹¤.

```ruby
#1
def greeter (&a)
  a.call
end
phrase = Proc.new {puts "Hello there!"}
greeter &phrase

#2
def greeter (a)
  a.call
end
phrase = Proc.new {puts "Hello there!"}
greeter phrase
```

1ê³¼ 2ëŠ” ë™ì¼í•˜ê²Œ ë™ì‘í•˜ê³  í•¨ìˆ˜ë‚´ë¶€ì—ì„œì˜ aëŠ” **ëª¨ë‘ í”„ë¡**ì´ë‹¤. í•˜ì§€ë§Œ, 1ì€ ë¸”ë¡ì„ ë§¤ê°œë³€ìˆ˜ë¡œ ì „ë‹¬í•˜ëŠ” ê²ƒì´ê³ , 2ëŠ” í”„ë¡ì„ ë§¤ê°œë³€ìˆ˜ë¡œ ì „ë‹¬í•˜ëŠ” ê²ƒì´ì—¬ì„œ ì „ë‹¬ ë°©ì‹ì—ì„œì˜ ì°¨ì´ëŠ” ì¡´ì¬í•œë‹¤.

ë§Œì•½ ì•„ë˜ì™€ ê°™ì´ ì‘ì„±í•˜ë©´ 1, 2ëŠ” trueë¥¼ 3ì€ falseë¥¼ ì¶œë ¥í•  ê²ƒì´ë‹¤.

```ruby
#1
def greeter (&a)
  puts block_given?
end
phrase = Proc.new {puts "Hello there!"}
greeter &phrase

#2
def greeter
  puts block_given?
end
phrase = Proc.new {puts "Hello there!"}
greeter &phrase

#3
def greeter (blck)
  puts block_given?
end
phrase = Proc.new {puts "Hello there!"}
greeter phrase
```

í”„ë¡ì„ ë‹¨ë…ìœ¼ë¡œ ì‹¤í–‰ì‹œí‚¬ ìˆ˜ë„ ìˆë‹¤. (`call`)

```ruby
hi = Proc.new {puts "Hello!"}
hi.call
```

ë˜ëŠ” ë¸”ëŸ­ì´ yieldë¥¼ ëŒ€ì¹˜í•˜ëŠ” ê²ƒ ì²˜ëŸ¼ í”„ë¡ì„ ì´ìš©í•˜ì—¬ ëŒ€ì¹˜í•  ìˆ˜ìˆë‹¤.

```ruby
def greeter
  yield
end
phrase = Proc.new {puts "Hello there!"}
greeter(&phrase)
```

**ì‹¬ë³¼ì„ í”„ë¡ìœ¼ë¡œ ë³€í™˜í•˜ì—¬ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.**

```ruby
strings = ["1", "2", "3"]
nums = strings.map(&:to_i)
# ==> [1, 2, 3]
```

```ruby
numbers_array = [1, 2.1, 3.9, 4, 5, 6, 7, 8.3, 9, 10]
strings_array = numbers_array.map(&:floor)
puts strings_array
```

### 2.2. ëŒë‹¤

ëŒë‹¤ì™€ í”„ë¡ì€ ê±°ì˜ ê°™ë‹¤.

```ruby
lambda { puts "Hello!" }
Proc.new { puts "Hello!" }
```

í•˜ì§€ë§Œ ë‘ê°€ì§€ ì°¨ì´ì ì´ ì¡´ì¬í•œë‹¤.

ëŒë‹¤ëŠ” ì•„ê·œë¨¼íŠ¸ì˜ ìˆ˜ë¥¼ ì²´í¬í•˜ê³  í”„ë¡ì€ ê·¸ë ‡ì§€ ì•Šë‹¤. ì´ê²ƒì€ ëŒë‹¤ê°€ ì˜ëª»ëœ ìˆ˜ì˜ ì•„ê·œë¨¼íŠ¸ë¥¼ ì „ë‹¬í•˜ë©´ ì—ëŸ¬ë¥¼ ë„ìš´ë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•˜ê³  í”„ë¡ì€ ë¬´ì‹œí•œë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤. ì´ë•Œ í”„ë¡ì€ ì˜ˆìƒë˜ì§€ì•Šì€ ì•„ê·œë¨¼íŠ¸ëŠ” `nil` ë¡œ ì²˜ë¦¬í•œë‹¤.

ë‘ë²ˆì§¸ë¡œëŠ” ëŒë‹¤ ë‚´ë¶€ì—ì„œ ë¦¬í„´ì„ ì“°ëŠ” ê²ƒì€ í˜¸ì¶œëœê³³ìœ¼ë¡œ ëŒì•„ê°€ëŠ” ê²ƒì„ ì˜ë¯¸í•˜ê³ , í”„ë¡ì—ì„œ ë¦¬í„´ì„ í•œë‹¤ëŠ” ê²ƒì€ ì‹¤ì œ ë¦¬í„´ì´ í˜¸ì¶œëœ ì¥ì†Œì—ì„œ ì‹¤í–‰ì´ ëœë‹¤. ë§ë¡œëŠ” ë¬´ìŠ¨ë§ì¸ì§€ ì´í•´í•˜ê¸° ì–´ë ¤ìš°ë‹ˆ ì½”ë“œë¥¼ ë³´ê³  ì´í•´í•˜ê¸° ë°”ë€ë‹¤.

```ruby
def batman_ironman_proc
  victor = Proc.new { return "Batman will win!" }
  victor.call
  "Iron Man will win!"
end

puts batman_ironman_proc

def batman_ironman_lambda
  victor = lambda { return "Batman will win!" }
  victor.call
  "Iron Man will win!"
end

puts batman_ironman_lambda

#Batman will win!
#Iron Man will win!
```

## 3. !ì™€ ?

`!`ëŠ” ë³€ìˆ˜ ìê¸°ìì‹ ì„ ì—…ë°ì´íŠ¸ í•  ë•Œ ì‚¬ìš©í•œë‹¤. (! ì•„ë‹ˆë©´ ë³´í†µ ë¦¬í„´)

`?`ëŠ” ë³´í†µ false / trueë¥¼ ë¦¬í„´í•œë‹¤.

`user_input.capitalize!`

`user_input.downcase! `

`user_input.include?"s"`

```ruby
if user_input.include?"s"
 user_input.gsub!(/s/, "th")
end
```

## 4. unlessì™€ until

`unless`ëŠ” `if`ì™€ ë°˜ëŒ€ë¡œ falseì¼ë•Œ ë™ì‘í•œë‹¤.

```ruby
unless true
	puts "A"
else
	puts "B"
end
#=> B
```

`until`ì€ `while`ê³¼ ë°˜ëŒ€ë¡œ falseì¼ë•Œ ë™ì‘í•œë‹¤.

```ruby
counter = 1
until counter > 10
  puts counter
  counter += 1
end
```

## 5. loop do, break ifì™€ next if

loop doë¥¼ ì‹¤í–‰ì‹œí‚¤ë©´ ë¬´í•œë£¨í”„ë¥¼ ëŒê²Œë˜ê³ , break ifë¬¸ì— ë§Œì¡±í•˜ë©´ loopë¥¼ ëë‚¸ë‹¤.

next ifëŠ” cì–¸ì˜ continueë¼ê³  ìƒê°í•˜ë©´ ëœë‹¤.

```ruby
i = 20
loop do
  i -= 1
  next if i % 2 == 1
  print "#{i} "
  break if i <= 0
end
```

> 18 16 14 12 10 8 6 4 2 0

## 6. ê°€ë³€ì¸ì *

```ruby
def what_up(greeting, *friends)
  friends.each { |friend| puts "#{greeting}, #{friend}!" }
end
what_up("What up", "Ian", "Zoe", "Zenas", "Eleanor")
```

## 7. ê²°í•©ëœ ë¹„êµì—°ì‚°ì <=>

`<=> `ì„ ì´ìš©í•˜ì—¬ ë‘ ë³€ìˆ˜ì‚¬ì´ì˜ ëŒ€ì†Œ ê´€ê³„ë¥¼ 0, 1, -1ë¡œ ë°”ë¡œ ì•Œì•„ë³¼ ìˆ˜ ìˆë‹¤.

ì¢Œì¸¡ ë³€ìˆ˜ì˜ ê°’ì´ ë” í¬ë‹¤ë©´ 1, ê°™ë‹¤ë©´ 0, ì‘ë‹¤ë©´ -1ì„ ë¦¬í„´í•œë‹¤.

`1<=>2` ëŠ” -1ì„ ë¦¬í„´í•œë‹¤.

## 8. select ë©”ì†Œë“œ

select ë©”ì†Œë“œë¥¼ ì´ìš©í•˜ì—¬ í•´ì‹œì—ì„œ íŠ¹ì •í•œ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ê°’ë§Œ ì„ íƒí•  ìˆ˜ ìˆë‹¤.

```ruby
grades = { alice: 100,
  bob: 92,
  chris: 95,
  dave: 97
}

grades.select { |name, grade| grade <  97 }
# ==> { :bob => 92, :chris => 95 }

grades.select { |k, v| k == :alice }
# ==> { :alice => 100 }
```

## 10. each_key, each_value ë©”ì†Œë“œ

í•´ì‹œì—ì„œ í‚¤ê°’ ë˜ëŠ” ë°¸ë¥˜ê°’ë§Œì„ ê°€ì ¸ì˜¤ê³  ì‹¶ì„ ë•Œ ì‚¬ìš©

```ruby
my_hash = { one: 1, two: 2, three: 3 }

my_hash.each_key { |k| print k, " " }
# ==> one two
threemy_hash.each_value { |v| print v, " " }
# ==> 1 2 3
```

## 11. caseë¬¸

```ruby
case language
  when "JS"
    puts "Websites!"
  when "Python"
    puts "Science!"
  when "Ruby"
    puts "Web apps!"
  else
    puts "I don't know!"
end
```

when ~ then ~ ì„ ì´ìš©í•˜ì—¬ í•œì¤„ë¡œ í‘œí˜„ ê°€ëŠ¥

```ruby
case language
  when "JS" then puts "Websites!"
  when "Python" then puts "Science!"
  when "Ruby" then puts "Web apps!"
  else puts "I don't know!"
end
```

## 12. ifë¬¸ ë³€í˜•

`expression if boolean` í˜•ì‹ìœ¼ë¡œ ì‚¬ìš©ê°€ëŠ¥

```ruby
puts "It's true!" if true
```

ì´ë ‡ê²Œ ì“°ë©´ ifë¬¸ì— endë¥¼ ë¶™ì´ì§€ ì•Šì•„ë„ ëœë‹¤. unlessë„ ë§ˆì°¬ê°€ì§€ë¡œ ì‚¬ìš©ì´ ê°€ëŠ¥í•˜ë‹¤.

3í•­ì—°ì‚°ì (ternary contional expression)

```ruby
puts 3 < 4 ? "3 is less than 4!" : "3 is not less than 4."
```

## 13. ||= ì—°ì‚°ì (Conditional Assignment)

`||=`ì—°ì‚°ìëŠ” ì¢Œì¸¡ í”¼ì—°ì‚°ìê°€ nilì¼ ê²½ìš°ì— ì˜¤ë¥¸ìª½ ê°’ì„ ëŒ€ì…í•˜ê³  ë‹¤ë¥¸ ê°’ì´ ìˆë‹¤ë©´ ì•„ë¬´ ì‘ì—…ë„ ìˆ˜í–‰í•˜ì§€ ì•ŠëŠ”ë‹¤.

```ruby
favorite_book = nil
puts favorite_book
favorite_book ||= "Cat's Cradle"

puts favorite_book
favorite_book ||= "Why's (Poignant) Guide to Ruby"

puts favorite_book
favorite_book = "Why's (Poignant) Guide to Ruby"

puts favorite_book

#Cat's Cradle
#Cat's Cradle
#Why's (Poignant) Guide to Ruby
```

## 14. upto

`A.upto(B)` ëŠ” Aì—ì„œ Bê¹Œì§€ ê°€ë©´ì„œ í•˜ë‚˜ì”© ì¦ê°€í•œë‹¤.

```ruby
95.upto(100) { |num| print num, " " }
# Prints 95 96 97 98 99 100
```

## 15. Call and Response

`.respond_to?`í•¨ìˆ˜ëŠ” ì‹¬ë³¼ì„ ì¸ìë¡œ ë°›ê³ , ì‹¬ë³¼ì— í•´ë‹¹í•˜ëŠ” ë©”ì†Œë“œê°€ í•´ë‹¹ ê°ì²´ì— ì‚¬ìš©ì´ ê°€ëŠ¥í•œ ë©”ì†Œë“œë¼ë©´ trueë¥¼ ì•„ë‹ˆë¼ë©´ falseë¥¼ ë°˜í™˜í•œë‹¤.

```ruby
[1, 2, 3].respond_to?(:push)
```

would return `true`, since you can call `.push` on an array object. However,

```ruby
[1, 2, 3].respond_to?(:to_sym)
```

would return `false`, since you canâ€™t turn an array into a symbol.

## 16. << ì—°ì‚°ì

ë°°ì—´ì—ì„œ `<<`ì—°ì‚°ìëŠ” pushë¥¼ ì˜ë¯¸í•œë‹¤.

```ruby
[1, 2, 3] << 4
# ==> [1, 2, 3, 4]
```

ìŠ¤íŠ¸ë§ì—ì„œëŠ” `+`ë¥¼ ì˜ë¯¸í•œë‹¤.

```ruby
"Yukihiro " << "Matsumoto"
# ==> "Yukihiro Matsumoto"
```

## 17. í´ë˜ìŠ¤ì™€ ì¸ìŠ¤í„´ìŠ¤ ì‹¬í™”

### 17.1 ë³€ìˆ˜ì˜ ìŠ¤ì½”í”„

- `@` : ì¸ìŠ¤í„´ìŠ¤ ë ˆë²¨ì˜ ë³€ìˆ˜ => ë™ì¼í•œ ì¸ìŠ¤í„´ìŠ¤ì—ì„œ ê³µìœ í•˜ëŠ” ë³€ìˆ˜
- @@ : í´ë˜ìŠ¤ ë ˆë²¨ì˜ ë³€ìˆ˜ => ì¸ìŠ¤í„´ìŠ¤ì™€ ë¬´ê´€í•˜ê²Œ í´ë˜ìŠ¤ ìì²´ì—ì„œ ê³µìœ í•˜ëŠ” ë³€ìˆ˜
- $ : ì „ì—­ ë³€ìˆ˜
  - ì „ì—­ë³€ìˆ˜ë¥¼ ì„ ì–¸í•˜ëŠ” ë°©ë²•ì€ ë‘ê°€ì§€ê°€ ìˆë‹¤.
    1. ë©”ì†Œë“œë‚˜ í´ë˜ìŠ¤ ë°–ì—ì„œ ì„ ì–¸í•˜ëŠ” ê²ƒ
    2. $ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒ

```ruby
class MyClass
  $my_variable = "Hello!"
end
puts $my_variable
```

```ruby
class Person
  @@people_count = 0
  def initialize(name)
    @name = name
    # Increment your class variable on line 8
    @@people_count += 1
  end
  def self.number_of_instances
    # Return your class variable on line 13
    @@people_count
  end
end

#puts "Number of Person instances: #{Person.number_of_instances}"
matz = Person.new("Yukihiro")

#puts "Number of Person instances: #{Person.number_of_instances}"
dhh = Person.new("David")

puts "Number of Person instances: #{Person.number_of_instances}"
```

### 17.2 public / private

```ruby
class ClassName
  # Some class stuff

  public
  # Public methods go here
  def public_method; end

  private
  # Private methods go here
  def private_method; end
end
```

- í”„ë¼ì´ë¹—ì˜ ë©”ì†Œë“œë‚˜ ë³€ìˆ˜ëŠ” ì¸ìŠ¤í„´ìŠ¤ ì™¸ë¶€ì—ì„œ ì‚¬ìš©(í˜¸ì¶œ)ì´ ë¶ˆê°€ëŠ¥í•˜ë‹¤. ì¦‰ ì¸ìŠ¤í„´ìŠ¤ ë‚´ë¶€ì—ì„œë§Œ ì‚¬ìš©ì´ ê°€ëŠ¥í•˜ë‹¤.

### 17.3 attr_reader ì‹¬ë³¼, attr_writer ì‹¬ë³¼, attr_accessor ì‹¬ë³¼

ì–´ë– í•œ ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ì™€ ë©”ì†Œë“œ ëª…ì„ ë™ì¼í•˜ê²Œ ì‚¬ìš©í•˜ì—¬ ì½ê¸°, ì“°ê¸° ê¸°ëŠ¥ì„  ê°„ë‹¨í•œ ë¬¸ë²•ì„ í†µí•´ ì“¸ ìˆ˜ ìˆë‹¤.

`attr_reader :symbol_name` : symbol_nameì— í•´ë‹¹í•˜ëŠ” ë³€ìˆ˜ë¥¼ ë¦¬í„´

`attr_writer :symbol_name` : symbol_nameì— í•´ë‹¹í•˜ëŠ” ë³€ìˆ˜ì— ê°’ì„ ì”€

`attr_accessor :symbol_name` : symbol_nameì— í•´ë‹¹í•˜ëŠ” ë³€ìˆ˜ì— ê°’ì„ ì“°ê³ , ì½ì„ ìˆ˜ ìˆìŒ

```ruby
class Person
  attr_reader :name
  attr_writer :name

  def initialize(name)
    @name = name
  end

end
```

ìœ„ í´ë˜ìŠ¤ëŠ” ì•„ë˜ì™€ ë™ì¼í•˜ê²Œ ë™ì‘í•œë‹¤.

```ruby
class Person

  def initialize(name)
    @name = name
  end

  def name
      @name
  end

  def name=(value)
     @name = value
  end

end
#(That name= might look funny, but youâ€™re allowed to put an = sign in a method name. Thatâ€™s just a Ruby convention saying, â€œhey, this method sets a value!â€)
```

## 18. ëª¨ë“ˆ ì‹¬í™”

### 18.1 namespacing

ëª¨ë“ˆì˜ ì£¼ëœ ëª©ì ì¤‘í•˜ë‚˜ëŠ” ë„¤ì„ìŠ¤í˜ì´ìŠ¤ë¥¼ êµ¬ë¶„í•˜ëŠ” ê²ƒì´ë‹¤. ì´ê²ƒì„ namespacingì´ë¼í•œë‹¤.

(itâ€™s how Ruby doesnâ€™t confuse `Math::PI` and `Circle::PI`.)

`::`ì„ **scope resolution operator ë¼ í•œë‹¤.**

## 18.2 require

Mathì™€ ê°™ì€ ëª¨ë“ˆì€ ì´ë¯¸ ì¸í„°í”„ë¦¬í„°ì— ìœ„ì¹˜í•´ìˆë‹¤. ê¸°ë³¸ì ìœ¼ë¡œ ì—†ëŠ” ëª¨ë“ˆì€ `require`ì„ ì´ìš©í•´ ë¶ˆëŸ¬ì™€ì•¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

### 18.3 include

`include`ë¥¼ ì´ìš©í•˜ì—¬ í´ë˜ìŠ¤ì—ì„œ íŠ¹ì •í•œ ëª¨ë“ˆì˜ ê¸°ëŠ¥ë“¤ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

í´ë˜ìŠ¤ì™€ ëª¨ë“ˆì˜ í–‰ë™ê³¼ ì •ë„ë¥¼ì„ í•˜ë‚˜ë¡œ ì„ì„ ê²ƒì„ ë¯¹ìŠ¤ì¸ì´ë¼ í•œë‹¤.

ëª¨ë“ˆì´ í´ë˜ìŠ¤ì— includeë˜ì–´ ì¶”ê°€ì ì¸ í–‰ë™ê³¼ ì •ë³´ê°€ í´ë˜ìŠ¤ ë‚´ë¶€ì— ì¶”ê°€ë˜ëŠ” ê²ƒì´ë‹¤.

```ruby
module Action
  def jump
    @distance = rand(4) + 2
    puts "I jumped forward #{@distance} feet!"
  end
end

class Rabbit
  include Action
  attr_reader :name
  def initialize(name)
    @name = name
  end
end

class Cricket
  include Action
  attr_reader :name
  def initialize(name)
    @name = name
  end
end

peter = Rabbit.new("Peter")
jiminy = Cricket.new("Jiminy")

peter.jump
jiminy.jump
```

ì•¡ì…˜ ëª¨ë“ˆì„ includeí•œ í´ë˜ìŠ¤ ë‘ê°œì—ì„œ jump ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆë‹¤.

### 18.4 extend

ì¸í´ë£¨ë“œëŠ” ì¸ìŠ¤í„´ìŠ¤ ë ˆë²¨ì—ì„œì˜ ì„ì´ëŠ” ì‘ì—…ì´ë¼ë©´, ìµìŠ¤í…ë“œëŠ” í´ë˜ìŠ¤ ë ˆë²¨ì—ì„œ ë¯¹ìŠ¤í•˜ëŠ” ì‘ì—…ì´ë‹¤. ì¦‰, ì¸ìŠ¤í„´ìŠ¤ì˜ ìƒì„±ì—†ì´ ë°”ë¡œ í´ë˜ìŠ¤.ë©”ì†Œë“œ ë¡œ í•¨ìˆ˜ í˜¸ì¶œì´ ê°€ëŠ¥í•˜ë‹¤.

```ruby
module Action
  def greeting
    puts "HELLO!"
  end
end

class Greet
  extend Action
end

Greet.greeting
#=> "HELLO!"
```
