# 04. Ruby 심화 개념

>

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./README.md)

---

<!-- TOC -->



<!-- /TOC -->

## 1. 심볼

루비에는 symbol이라는 객체도 존재한다. `String` 객체와는 다르게 같은 이름의 심볼은 하나의 루비 세션 동안 단 한번만 초기화되며 메모리에 존재한다. 심볼은 비가변적이며, 런타임 동안 변경할 수 없다 루비 인터프리터는 심볼 테이블에 심볼에 해당하는 모든 클래스, 매서드, 변수를 저장한다. 심볼은 이름 앞에 콜론`:`을 붙여 만든다.

```ruby
> puts :name.object_id # => yields 20488 
> puts :name.object_id # => yields 20488 
> puts "name".object_id # => yields 2168472820 
> puts "name".object_id # => yields 2168484060 
```

문자열 내부의 컨텐츠를 다룰때는 문자열을 사용하고, 객체의 아이덴티티가 중요한 경우(ex>해시의 키)는 심볼을 사용하라.

```ruby
symbol_hash = {
  :one => 1,
  :two => 2,    # Fill in these two blanks!
  :three => 3,
}
```

해시에서 심볼을 키로 사용할 때 심볼의 `:`를 뒤로 쓰게되면 key값을 더 편하게 표현할 수 있다.

```ruby
movies = {
  one: "Godo",
  two: "123"
}
puts movies
```

심볼과 스트링을 서로 변환할 수 있다.

```ruby
:sasquatch.to_s
# ==> "sasquatch"
"sasquatch".to_sym
# ==> :sasquatch

#Besides using .to_sym, you can also use .intern. This will internalize the string into a symbol and works just like .to_sym:
"hello".intern
# ==> :hello
```

스트링과 심볼의 속도 비교

```ruby
require 'benchmark'

string_AZ = Hash[("a".."z").to_a.zip((1..26).to_a)]
symbol_AZ = Hash[(:a..:z).to_a.zip((1..26).to_a)]

string_time = Benchmark.realtime do
  100_000.times { string_AZ["r"] }
end
symbol_time = Benchmark.realtime do
  100_000.times { symbol_AZ[:r] }
end

puts "String time: #{string_time} seconds."
puts "Symbol time: #{symbol_time} seconds."
    
#String time: 0.006994454997766297 seconds.
#Symbol time: 0.00474227200174937 seconds.
```

## 2. 프록, 블록, 람다

## 3. !와 ?

`!`는 변수 자기자신을 업데이트 할 때 사용한다. (! 아니면 보통 리턴)

`?`는 보통 false / true를 리턴한다.

`user_input.capitalize!`

`user_input.downcase! `

`user_input.include?"s"`

```ruby
if user_input.include?"s"
 user_input.gsub!(/s/, "th")
end
```

## 4. unless와 until

`unless`는 `if`와 반대로 false일때 동작한다.

```ruby
unless true
	puts "A"
else
	puts "B"
end
#=> B
```

`until`은 `while`과 반대로 false일때 동작한다.

```ruby
counter = 1
until counter > 10
  puts counter
  counter += 1
end
```

## 5. loop do, break if와 next if

loop do를 실행시키면 무한루프를 돌게되고, break if문에 만족하면 loop를 끝낸다.

next if는 c언의 continue라고 생각하면 된다.

```ruby
i = 20
loop do
  i -= 1
  next if i % 2 == 1
  print "#{i} "
  break if i <= 0
end
```

> 18 16 14 12 10 8 6 4 2 0

## 6. 가변인자 *

```ruby
def what_up(greeting, *friends)
  friends.each { |friend| puts "#{greeting}, #{friend}!" }
end
what_up("What up", "Ian", "Zoe", "Zenas", "Eleanor")
```

## 7. 결합된 비교연산자 <=> 

`<=> `을 이용하여 두 변수사이의 대소 관계를 0, 1, -1로 바로 알아볼 수 있다.

좌측 변수의 값이 더 크다면 1, 같다면 0, 작다면 -1을 리턴한다.

`1<=>2` 는 -1을 리턴한다.

## 8. select 메소드

select 메소드를 이용하여 해시에서 특정한 조건을 만족하는 값만 선택할 수 있다.

```ruby
grades = { alice: 100,
  bob: 92,
  chris: 95,
  dave: 97
}

grades.select { |name, grade| grade <  97 }
# ==> { :bob => 92, :chris => 95 }

grades.select { |k, v| k == :alice }
# ==> { :alice => 100 }
```

## 10. each_key, each_value 메소드

해시에서 키값 또는 밸류값만을 가져오고 싶을 때 사용

```ruby
my_hash = { one: 1, two: 2, three: 3 }

my_hash.each_key { |k| print k, " " }
# ==> one two 
threemy_hash.each_value { |v| print v, " " }
# ==> 1 2 3
```

## 11. case문

```ruby
case language
  when "JS"
    puts "Websites!"
  when "Python"
    puts "Science!"
  when "Ruby"
    puts "Web apps!"
  else
    puts "I don't know!"
end
```

when ~ then ~ 을 이용하여 한줄로 표현 가능

```ruby
case language
  when "JS" then puts "Websites!"
  when "Python" then puts "Science!"
  when "Ruby" then puts "Web apps!"
  else puts "I don't know!"
end
```

## 12. if문 변형

`expression if boolean` 형식으로 사용가능

```ruby
puts "It's true!" if true
```

이렇게 쓰면 if문에 end를 붙이지 않아도 된다. unless도 마찬가지로 사용이 가능하다.

3항연산자 (ternary contional expression)

```ruby
puts 3 < 4 ? "3 is less than 4!" : "3 is not less than 4."
```

## 13. ||= 연산자 (Conditional Assignment)

`||=`연산자는 좌측 피연산자가 nil일 경우에 오른쪽 값을 대입하고 다른 값이 있다면 아무 작업도 수행하지 않는다.

```ruby
favorite_book = nil
puts favorite_book
favorite_book ||= "Cat's Cradle"

puts favorite_book
favorite_book ||= "Why's (Poignant) Guide to Ruby"

puts favorite_book
favorite_book = "Why's (Poignant) Guide to Ruby"

puts favorite_book

#Cat's Cradle
#Cat's Cradle
#Why's (Poignant) Guide to Ruby
```

## 14. upto

`A.upto(B)` 는 A에서 B까지 가면서 하나씩 증가한다.

```ruby
95.upto(100) { |num| print num, " " }
# Prints 95 96 97 98 99 100
```

## 15. Call and Response

`.respond_to?`함수는 심볼을 인자로 받고, 심볼에 해당하는 메소드가 해당 객체에 사용이 가능한 메소드라면 true를 아니라면 false를 반환한다.

```ruby
[1, 2, 3].respond_to?(:push)
```

would return `true`, since you can call `.push` on an array object. However,

```ruby
[1, 2, 3].respond_to?(:to_sym)
```

would return `false`, since you can’t turn an array into a symbol.

## 16. << 연산자

배열에서 `<<`연산자는 push를 의미한다.

```ruby
[1, 2, 3] << 4
# ==> [1, 2, 3, 4]
```

스트링에서는 `+`를 의미한다.

```ruby
"Yukihiro " << "Matsumoto"
# ==> "Yukihiro Matsumoto"
```

## 정규식

