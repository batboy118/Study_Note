# 99. PRACTICAL OBJECT-ORIENTED DESIGN IN RUBY

>PRACTICAL OBJECT-ORIENTED DESIGN IN RUBY 책을 읽고 내용을 정리합니다.

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./README.md)

---

<!-- TOC -->

<!-- /TOC -->

## 1. Object-Oriented Design

세상은 절차적이다. 시간의 흐름대로 사건이 흘러간다. 또한, 세계는 객체지향적이다. 객체들의 행동은 자연스럽게 섞이기 때문에 예상치 못한 행동들의 조합이 나타날 수 있다.

절차적 프로그램은 예상치 못한 행동들의 조합을 프로그래밍하기 어려운 경우가 많다. 이를 해결하기 위해 객체지향 설계가 등장해다. 객체지향 디자인은 이미 정해진 절차들을 묶음으로 생각하지 않고, 객체가 서로 주고받는 메세지들의 연속으로 파악해야 한다. 그렇게 때문에 프로그래머는 객체들의 연관성을 잘 정의해준다면 모든 사건의 조합을 만들어낼 필요가 없다.

객체지향 설계에 실패하는 것은 관점이 제대로 확립되지 않아서이다. 객체지향적 관점을 확실히 가지게 되면 실패할 수 없다.

객체지향 어플리케이션은 상호작용하는 여러 객체로 구성되어 있고 상호작용하는 방석은 서로 메세지를 주고받는 것이다. 여기서 송신하고 수신하는 객체가 두 객체 사이의 의존성을 만들어 내고, 이러한 의존성으로 인해 객체를 수정하는 것이 어려워진다.

객체 지향 설계는 의존성 관리에 관한 것이다. 객체들이 변화를 용인할 수 있도록 의존성을 잘 관리하는 것이 객체 지향 디자인이다. 제대로된 설계가 되지 않으면 객체들이 서로에 대해 너무 많이 알기 떄문에 관리되지 않는 의존성은 큰 혼란을 초래한다.

모든 어플리케이션은 코드의 집합이고, 코드를 어떻게 배열하는 것이 바로 설계이다. 설계를 할 때 고려해야 할 것이 두가지가 있다. 먼저 현재의 기능을 충실히 구현할 수 있어야한다는 것이다. 두번째는 나중에 변경될 수 있는 것을 고려해서 코드를 작성해야 한다는 것이다.

디자인은 나중에 디자인할 수 있는 여지를 남겨 놓기 위한 것이고, 그 최종 목표는 변화의 비용을 최소화하는 것이다.

### 1.1 객체 지향 디자인의 원칙과 디자인 패턴

`SOLID`는 마이클 플레즈가 만들고 로버트 마틴이 대중화한 객체 지향 설계의 5가지 원리이다.

1. Sngle Responsibility - 단일 책임
2. Open-Closed - 개방-폐쇄
3. Liskov Substitution - 리스코프 치환
4. Interface Segregation - 인터페이스 분리
5. Dependency Inversion - 의존성 역전

다른 디자인 원칙으로는 앤디 헌트와 데이브 토머스의 `DRY`(Don't Retape Yourself)와 노스이스트 대학교의 데메터 프로젝트의 `Law of Demeter`(LoD)가 있다. 이러한 설계 원칙들을 이 책을 통해서 다룬다.

또한, 객체지향 디자인의 원칙 외에도 디자인 패턴을 이해하는 것이 중요하다. <GoF의 디자인 패턴>은 패턴이란 객체지향 소프트웨어 디자인에서 명확한 문제를 처리하는 간단하고도 우아한 해결책이라고 말한다. 디자인 패턴은 **동일한 문제를 같은 방식으로 해결할 수 있는 방법**에 이름을 부여한 것을 말한다. 디자인 패턴은 프로그래머들이 서로 소통하고 협업할 수 있는 방법을 제공해 주었다.

디자인은 **반복적인 피드백**과 함께하는 **점진적인 발견**의 과정이다. 그리고 디자인은 지속적인 자기조절 능력을 갖추고, 자연스럽게 발전하는 것이 가장 좋다. 때문에 반복과 점진적인 발전을 중시하는 애자일 소프트웨어 개발은 잘 디자인된 애플리케이션을 만드는 데 매우 적합하다. 좋은 애플리케이션을 위해서는 **초기에 큰 디자인을 구상하지 않고 계속해서 디자인을 변경해주는 게 좋다**.

### 1.2 객체 지향 언어

 일반적인 절차지향적인 언어와 다르게 루비와 같은 객체지향 언어는 데이터와 행동(함수)를 완전히 분리하지 않고 하나의 객체에 결합하여 넣는다. 즉, 객체는 행동과 데이터를 포함하고, 객체만이 제어할 수 있는 데이터를 포함한다. 객체는 서로 메세지를 보내면서 서로의 행동을 불러 일으킨다.

루비는 문자열 데이터 타입 대신 문자열 객체를 가지고 있다. 문자열로 작동하는 연산은 언어의 문법대신에 문자열 객체에 내장되어 있다. 각각의 문자열 객체는 고유한 개인 데이터 문자열을 포함한다는 점에서 다르지만, 모든 문자열 객체는 동일한 동작을 한다는 점에서 유사하다고 볼 수 있다.

문자열 객체가 자체적으로 알맞은 행동을 제공해 주기때문에 문자열 데이터의 타입에 대해서 특별히 신경쓸 필요가 없다. 프로그래머는 객체가 메세지를 보내는 일반적인 방법만 알면 된다. 

루비와 같은 클래스 기반의 객체 지향 언어는 유사한 객체의 구성에 대한 청사진을 제공하는 클래스를 정의 할 수 있다. 클래스는 메서드와 프로퍼티를 정의한다. 메서드는 메세지에 응답하여 호출된다. 동일한 메서드 이름은 다른 오브젝트에서도 정의될 수 있다. 전송된 메세지에 대한 올바른 오브젝트의 메서드를 찾고 호출하는 것은 루비의 역할이다.

클래스는 단순한 데이터 이상의 유형을 정의한다. 물체의 유형을 알면 물체가 어떻게 행동할지 예상할 수 있다. 절차지향 언어에서 변수는 단일 데이터 타입을 가진다. 이 데이터 타입에 대한 지식은 어떤 연산이 유효한지에 대한 예상하게 한다. 루비에서는 하나의 객체는 많은 타입을 가질 수 있다. 객체의 타입을 아는 것은 객체가 응답하는 메세지의 대한 예상을 할수 있게 한다.

루비에는 미리 정의된 클래스가 많이 있다. 가장 즉시 알아차릴수 있는 클래스는, 절차지향에서 쓰이는 데이터 타입과 중복되는 것들이다. 예를들면 스트링 클래스나, 정수를 표현하기 위한 Fixnum클래스 등이 있다. 보통은 모든 데이터 타입을 위한 미리정의된 클래스가 있다.

하지만, 객체지향 언어는 그 자체로 객체를 이용하여 만들어지고 이 점이 흥미로운 부분이다. 스트링 클래스 (새로운 문자열 객체를 위한 청사진)은 그 자체로 객체이다. 즉, String 클래스 또한 Class 클래스의 인스턴스이다. 모든 스트링 객체가 데이터가 구체화된 String 클래스의 객체라면, 모든 클래스 객체(String Fixnum ..)는 구체화된 데이터를 가지는 Class클래스의 인스턴스인 것이다. String 클래스가 새로운 문자열들은 만든다면, Class 클래스는 새로운 클래스들을 만든다.

