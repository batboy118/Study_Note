# 99. PRACTICAL OBJECT-ORIENTED DESIGN IN RUBY

>PRACTICAL OBJECT-ORIENTED DESIGN IN RUBY 책을 읽고 내용을 정리합니다.

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./README.md)

---

<!-- TOC -->

- [1. Object-Oriented Design](#1-object-oriented-design)
	- [1.1 객체 지향 디자인의 원칙과 디자인 패턴](#11-객체-지향-디자인의-원칙과-디자인-패턴)
	- [1.2 객체 지향 언어](#12-객체-지향-언어)

<!-- /TOC -->

## 1. Object-Oriented Design

세상은 절차적이다. 시간의 흐름대로 사건이 흘러간다. 또한, 세계는 객체지향적이다. 객체들의 행동은 자연스럽게 섞이기 때문에 예상치 못한 행동들의 조합이 나타날 수 있다.

절차적 프로그램은 예상치 못한 행동들의 조합을 프로그래밍하기 어려운 경우가 많다. 이를 해결하기 위해 객체지향 설계가 등장해다. 객체지향 디자인은 이미 정해진 절차들을 묶음으로 생각하지 않고, 객체가 서로 주고받는 메세지들의 연속으로 파악해야 한다. 그렇게 때문에 프로그래머는 객체들의 연관성을 잘 정의해준다면 모든 사건의 조합을 만들어낼 필요가 없다.

객체지향 설계에 실패하는 것은 관점이 제대로 확립되지 않아서이다. 객체지향적 관점을 확실히 가지게 되면 실패할 수 없다.

객체지향 어플리케이션은 상호작용하는 여러 객체로 구성되어 있고 상호작용하는 방석은 서로 메세지를 주고받는 것이다. 여기서 송신하고 수신하는 객체가 두 객체 사이의 의존성을 만들어 내고, 이러한 의존성으로 인해 객체를 수정하는 것이 어려워진다.

객체 지향 설계는 의존성 관리에 관한 것이다. 객체들이 변화를 용인할 수 있도록 의존성을 잘 관리하는 것이 객체 지향 디자인이다. 제대로된 설계가 되지 않으면 객체들이 서로에 대해 너무 많이 알기 떄문에 관리되지 않는 의존성은 큰 혼란을 초래한다.

모든 어플리케이션은 코드의 집합이고, 코드를 어떻게 배열하는 것이 바로 설계이다. 설계를 할 때 고려해야 할 것이 두가지가 있다. 먼저 현재의 기능을 충실히 구현할 수 있어야한다는 것이다. 두번째는 나중에 변경될 수 있는 것을 고려해서 코드를 작성해야 한다는 것이다.

디자인은 나중에 디자인할 수 있는 여지를 남겨 놓기 위한 것이고, 그 최종 목표는 변화의 비용을 최소화하는 것이다.

### 1.1 객체 지향 디자인의 원칙과 디자인 패턴

`SOLID`는 마이클 플레즈가 만들고 로버트 마틴이 대중화한 객체 지향 설계의 5가지 원리이다.

1. Sngle Responsibility - 단일 책임
2. Open-Closed - 개방-폐쇄
3. Liskov Substitution - 리스코프 치환
4. Interface Segregation - 인터페이스 분리
5. Dependency Inversion - 의존성 역전

다른 디자인 원칙으로는 앤디 헌트와 데이브 토머스의 `DRY`(Don't Retape Yourself)와 노스이스트 대학교의 데메터 프로젝트의 `Law of Demeter`(LoD)가 있다. 이러한 설계 원칙들을 이 책을 통해서 다룬다.

또한, 객체지향 디자인의 원칙 외에도 디자인 패턴을 이해하는 것이 중요하다. <GoF의 디자인 패턴>은 패턴이란 객체지향 소프트웨어 디자인에서 명확한 문제를 처리하는 간단하고도 우아한 해결책이라고 말한다. 디자인 패턴은 **동일한 문제를 같은 방식으로 해결할 수 있는 방법**에 이름을 부여한 것을 말한다. 디자인 패턴은 프로그래머들이 서로 소통하고 협업할 수 있는 방법을 제공해 주었다.

디자인은 **반복적인 피드백**과 함께하는 **점진적인 발견**의 과정이다. 그리고 디자인은 지속적인 자기조절 능력을 갖추고, 자연스럽게 발전하는 것이 가장 좋다. 때문에 반복과 점진적인 발전을 중시하는 애자일 소프트웨어 개발은 잘 디자인된 애플리케이션을 만드는 데 매우 적합하다. 좋은 애플리케이션을 위해서는 **초기에 큰 디자인을 구상하지 않고 계속해서 디자인을 변경해주는 게 좋다**.

### 1.2 객체 지향 언어

 일반적인 절차지향적인 언어와 다르게 루비와 같은 객체지향 언어는 데이터와 행동(함수)를 완전히 분리하지 않고 하나의 객체에 결합하여 넣는다. 즉, 객체는 행동과 데이터를 포함하고, 객체만이 제어할 수 있는 데이터를 포함한다. 객체는 서로 메세지를 보내면서 서로의 행동을 불러 일으킨다.

루비는 문자열 데이터 타입 대신 문자열 객체를 가지고 있다. 문자열로 작동하는 연산은 언어의 문법대신에 문자열 객체에 내장되어 있다. 각각의 문자열 객체는 고유한 개인 데이터 문자열을 포함한다는 점에서 다르지만, 모든 문자열 객체는 동일한 동작을 한다는 점에서 유사하다고 볼 수 있다.

문자열 객체가 자체적으로 알맞은 행동을 제공해 주기때문에 문자열 데이터의 타입에 대해서 특별히 신경쓸 필요가 없다. 프로그래머는 객체가 메세지를 보내는 일반적인 방법만 알면 된다.

루비와 같은 클래스 기반의 객체 지향 언어는 유사한 객체의 구성에 대한 청사진을 제공하는 클래스를 정의 할 수 있다. 클래스는 메서드와 프로퍼티를 정의한다. 메서드는 메세지에 응답하여 호출된다. 동일한 메서드 이름은 다른 오브젝트에서도 정의될 수 있다. 전송된 메세지에 대한 올바른 오브젝트의 메서드를 찾고 호출하는 것은 루비의 역할이다.

클래스는 단순한 데이터 이상의 유형을 정의한다. 물체의 유형을 알면 물체가 어떻게 행동할지 예상할 수 있다. 절차지향 언어에서 변수는 단일 데이터 타입을 가진다. 이 데이터 타입에 대한 지식은 어떤 연산이 유효한지에 대한 예상하게 한다. 루비에서는 하나의 객체는 많은 타입을 가질 수 있다. 객체의 타입을 아는 것은 객체가 응답하는 메세지의 대한 예상을 할수 있게 한다.

루비에는 미리 정의된 클래스가 많이 있다. 가장 즉시 알아차릴수 있는 클래스는, 절차지향에서 쓰이는 데이터 타입과 중복되는 것들이다. 예를들면 스트링 클래스나, 정수를 표현하기 위한 Fixnum클래스 등이 있다. 보통은 모든 데이터 타입을 위한 미리정의된 클래스가 있다.

하지만, 객체지향 언어는 그 자체로 객체를 이용하여 만들어지고 이 점이 흥미로운 부분이다. 스트링 클래스 (새로운 문자열 객체를 위한 청사진)은 그 자체로 객체이다. 즉, String 클래스 또한 Class 클래스의 인스턴스이다. 모든 스트링 객체가 데이터가 구체화된 String 클래스의 객체라면, 모든 클래스 객체(String Fixnum ..)는 구체화된 데이터를 가지는 Class클래스의 인스턴스인 것이다. String 클래스가 새로운 문자열들은 만든다면, Class 클래스는 새로운 클래스들을 만든다.

## 2. Designing Classes with a Single Responsibility

객체지향 시스템에서 기초가 되는 것은 메세지이지만, 가장 뚜렷하게 확인할 수 있는 구조는 class이다. 메시지가 디자인의 핵심이지만, 클래스가 더 뚜렷하기 때문에 이번 장에서는 클래스에 속하는 것을 정하는 방법에 대해서 집중할 것이다.

만들려는 클래수가 무엇이고, 얼마나 많으며 어떠한 행동을 포함하고 있고 다른 클래스와의 관계는 어떠한지 정하는지에 대한 질문이 있을 수 있다. 이에 대한 정답은 클래스는 단순해야 한다는 것이다.

어플레케이션을 모델링하고, 클래스를 사용해서 지금 당장 있어야 하면서 나중에 수정하기 쉽게 하는 것이 목표이다. 현재 코드가 동작하게 하는 문제는 쉽지만, 수정하기 쉽게 만드는 것은 다른 문제이다.

### 2.1 클래스에 무엇이 포함될지 정하기

- 클래스에 Method를 그룹핑하기

  루비와 같은 객체지향 언어에서 메소드들은 클래스안에 정의되어 있다. 한번 생성된 클래스는 어플리케이션에 영원히 영향을 미칠것이다. 하지만, 메소드들을 알맞게 그룹핑하는것이 중요할지라도 프로젝트의 초반에 그것을 정하는 것이란 어려운 일이다. 또한, 성공적으로 그룹핑 했다고 하더라도 어플리케이션이 변하게 되다면 또 수정해야할 일이 발생할 수 있다. 디자인이란 완벽을 추구하는 행동이 보다는 영구적 변화에 대한 예술이다.

- 쉽게 수정가능한 코드를 구성하기

  수정하기 쉽다는 것은 명확하지 않기 때문에 그 의미를 정의할 필요가 있다.

  > 수정하기 쉬운것의 정의

  1. Changes have no unexpected side effects
  2. Small changes in requirements require correspondingly small changes in code
  3.  Existing code is easy to reuse
  4. The easiest way to make a change is to add code that in itself is easy to change

  > 수정하기 쉬운것의 기준 (TRUE)

  1. **Transparent** The consequences of change should be obvious in the code that is changing and in distant code that relies upon it
  2. **Reasonable** The cost of any change should be proportional to the benefits the change achieves
  3. **Usable** Existing code should be usable in new and unexpected contexts
  4. **Exemplary** The code itself should encourage those who change it to perpetuate these qualities

TURE를 만족하는 코드를 짜는 것의 첫 번째 단계는 각 클래스는 **단 하나의 잘 정의된 책임**을 가지는 것이다.

### 2.2. 하나의 책임을 지는 클래스 만들기

클래스는 최대한 작으면서도 유용해야한다. 즉, 클래스는 단일 책임을 가져야 한다. 

- 예시) 자전거와 기어

  자전거를 탈 때는 작은 기어(페달이 가벼워지고 느려짐), 큰 기어(페달이 무겁고 빨라짐) 중에 선택할 수 잇다. 기어는 발이 페달을 돌리는 힘으로 바퀴를 돌린다. 구체적으로는 페달이 회전할 때마다 바퀴가 얼마나 회전하는지를 기어에서 제어한다.

  ![image](https://user-images.githubusercontent.com/53181778/85508105-65bf2d00-b62e-11ea-9079-42ae9ca02fea.png)

  크고 작은 기어를 비율로 표현할 수 있다.

  ```ruby
  chainring = 52 # number of teeth
  cog = 11
  ratio = chainring / cog.to_f
  puts ratio # -> 4.72727272727273
  
  chainring = 30
  cog = 27
  ratio = chainring / cog.to_f
  puts ratio # -> 1.11111111111111
  ```

  위 코드를 기어 클래스로 만들어보자. 기어는 chainring, cog, ratio를 가지고 data와 behavior를 가지게 된다.

  ```ruby
  class Gear
  	attr_reader :chainring, :cog
      
  	def initialize(chainring, cog)
  	@chainring = chainring
  	@cog = cog
  	end
      
  	def ratio
      	chainring / cog.to_f
  	end
  end
  
  puts Gear.new(52, 11).ratio # -> 4.72727272727273
  puts Gear.new(30, 27).ratio # -> 1.11111111111111 
  ```

  

