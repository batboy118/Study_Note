# 99. PRACTICAL OBJECT-ORIENTED DESIGN IN RUBY

>PRACTICAL OBJECT-ORIENTED DESIGN IN RUBY 책을 읽고 내용을 정리합니다.

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./README.md)

---

<!-- TOC -->

- [1. Object-Oriented Design](#1-object-oriented-design)
	- [1.1 객체 지향 디자인의 원칙과 디자인 패턴](#11-객체-지향-디자인의-원칙과-디자인-패턴)
	- [1.2 객체 지향 언어](#12-객체-지향-언어)

<!-- /TOC -->

## 1. Object-Oriented Design

세상은 절차적이다. 시간의 흐름대로 사건이 흘러간다. 또한, 세계는 객체지향적이다. 객체들의 행동은 자연스럽게 섞이기 때문에 예상치 못한 행동들의 조합이 나타날 수 있다.

절차적 프로그램은 예상치 못한 행동들의 조합을 프로그래밍하기 어려운 경우가 많다. 이를 해결하기 위해 객체지향 설계가 등장해다. 객체지향 디자인은 이미 정해진 절차들을 묶음으로 생각하지 않고, 객체가 서로 주고받는 메세지들의 연속으로 파악해야 한다. 그렇게 때문에 프로그래머는 객체들의 연관성을 잘 정의해준다면 모든 사건의 조합을 만들어낼 필요가 없다.

객체지향 설계에 실패하는 것은 관점이 제대로 확립되지 않아서이다. 객체지향적 관점을 확실히 가지게 되면 실패할 수 없다.

객체지향 어플리케이션은 상호작용하는 여러 객체로 구성되어 있고 상호작용하는 방석은 서로 메세지를 주고받는 것이다. 여기서 송신하고 수신하는 객체가 두 객체 사이의 의존성을 만들어 내고, 이러한 의존성으로 인해 객체를 수정하는 것이 어려워진다.

객체 지향 설계는 의존성 관리에 관한 것이다. 객체들이 변화를 용인할 수 있도록 의존성을 잘 관리하는 것이 객체 지향 디자인이다. 제대로된 설계가 되지 않으면 객체들이 서로에 대해 너무 많이 알기 떄문에 관리되지 않는 의존성은 큰 혼란을 초래한다.

모든 어플리케이션은 코드의 집합이고, 코드를 어떻게 배열하는 것이 바로 설계이다. 설계를 할 때 고려해야 할 것이 두가지가 있다. 먼저 현재의 기능을 충실히 구현할 수 있어야한다는 것이다. 두번째는 나중에 변경될 수 있는 것을 고려해서 코드를 작성해야 한다는 것이다.

디자인은 나중에 디자인할 수 있는 여지를 남겨 놓기 위한 것이고, 그 최종 목표는 변화의 비용을 최소화하는 것이다.

### 1.1 객체 지향 디자인의 원칙과 디자인 패턴

`SOLID`는 마이클 플레즈가 만들고 로버트 마틴이 대중화한 객체 지향 설계의 5가지 원리이다.

1. Sngle Responsibility - 단일 책임
2. Open-Closed - 개방-폐쇄
3. Liskov Substitution - 리스코프 치환
4. Interface Segregation - 인터페이스 분리
5. Dependency Inversion - 의존성 역전

다른 디자인 원칙으로는 앤디 헌트와 데이브 토머스의 `DRY`(Don't Retape Yourself)와 노스이스트 대학교의 데메터 프로젝트의 `Law of Demeter`(LoD)가 있다. 이러한 설계 원칙들을 이 책을 통해서 다룬다.

또한, 객체지향 디자인의 원칙 외에도 디자인 패턴을 이해하는 것이 중요하다. <GoF의 디자인 패턴>은 패턴이란 객체지향 소프트웨어 디자인에서 명확한 문제를 처리하는 간단하고도 우아한 해결책이라고 말한다. 디자인 패턴은 **동일한 문제를 같은 방식으로 해결할 수 있는 방법**에 이름을 부여한 것을 말한다. 디자인 패턴은 프로그래머들이 서로 소통하고 협업할 수 있는 방법을 제공해 주었다.

디자인은 **반복적인 피드백**과 함께하는 **점진적인 발견**의 과정이다. 그리고 디자인은 지속적인 자기조절 능력을 갖추고, 자연스럽게 발전하는 것이 가장 좋다. 때문에 반복과 점진적인 발전을 중시하는 애자일 소프트웨어 개발은 잘 디자인된 애플리케이션을 만드는 데 매우 적합하다. 좋은 애플리케이션을 위해서는 **초기에 큰 디자인을 구상하지 않고 계속해서 디자인을 변경해주는 게 좋다**.

### 1.2 객체 지향 언어

 일반적인 절차지향적인 언어와 다르게 루비와 같은 객체지향 언어는 데이터와 행동(함수)를 완전히 분리하지 않고 하나의 객체에 결합하여 넣는다. 즉, 객체는 행동과 데이터를 포함하고, 객체만이 제어할 수 있는 데이터를 포함한다. 객체는 서로 메세지를 보내면서 서로의 행동을 불러 일으킨다.

루비는 문자열 데이터 타입 대신 문자열 객체를 가지고 있다. 문자열로 작동하는 연산은 언어의 문법대신에 문자열 객체에 내장되어 있다. 각각의 문자열 객체는 고유한 개인 데이터 문자열을 포함한다는 점에서 다르지만, 모든 문자열 객체는 동일한 동작을 한다는 점에서 유사하다고 볼 수 있다.

문자열 객체가 자체적으로 알맞은 행동을 제공해 주기때문에 문자열 데이터의 타입에 대해서 특별히 신경쓸 필요가 없다. 프로그래머는 객체가 메세지를 보내는 일반적인 방법만 알면 된다.

루비와 같은 클래스 기반의 객체 지향 언어는 유사한 객체의 구성에 대한 청사진을 제공하는 클래스를 정의 할 수 있다. 클래스는 메서드와 프로퍼티를 정의한다. 메서드는 메세지에 응답하여 호출된다. 동일한 메서드 이름은 다른 오브젝트에서도 정의될 수 있다. 전송된 메세지에 대한 올바른 오브젝트의 메서드를 찾고 호출하는 것은 루비의 역할이다.

클래스는 단순한 데이터 이상의 유형을 정의한다. 물체의 유형을 알면 물체가 어떻게 행동할지 예상할 수 있다. 절차지향 언어에서 변수는 단일 데이터 타입을 가진다. 이 데이터 타입에 대한 지식은 어떤 연산이 유효한지에 대한 예상하게 한다. 루비에서는 하나의 객체는 많은 타입을 가질 수 있다. 객체의 타입을 아는 것은 객체가 응답하는 메세지의 대한 예상을 할수 있게 한다.

루비에는 미리 정의된 클래스가 많이 있다. 가장 즉시 알아차릴수 있는 클래스는, 절차지향에서 쓰이는 데이터 타입과 중복되는 것들이다. 예를들면 스트링 클래스나, 정수를 표현하기 위한 Fixnum클래스 등이 있다. 보통은 모든 데이터 타입을 위한 미리정의된 클래스가 있다.

하지만, 객체지향 언어는 그 자체로 객체를 이용하여 만들어지고 이 점이 흥미로운 부분이다. 스트링 클래스 (새로운 문자열 객체를 위한 청사진)은 그 자체로 객체이다. 즉, String 클래스 또한 Class 클래스의 인스턴스이다. 모든 스트링 객체가 데이터가 구체화된 String 클래스의 객체라면, 모든 클래스 객체(String Fixnum ..)는 구체화된 데이터를 가지는 Class클래스의 인스턴스인 것이다. String 클래스가 새로운 문자열들은 만든다면, Class 클래스는 새로운 클래스들을 만든다.

## 2. Designing Classes with a Single Responsibility

객체지향 시스템에서 기초가 되는 것은 메세지이지만, 가장 뚜렷하게 확인할 수 있는 구조는 class이다. 메시지가 디자인의 핵심이지만, 클래스가 더 뚜렷하기 때문에 이번 장에서는 클래스에 속하는 것을 정하는 방법에 대해서 집중할 것이다.

만들려는 클래수가 무엇이고, 얼마나 많으며 어떠한 행동을 포함하고 있고 다른 클래스와의 관계는 어떠한지 정하는지에 대한 질문이 있을 수 있다. 이에 대한 정답은 클래스는 단순해야 한다는 것이다.

어플레케이션을 모델링하고, 클래스를 사용해서 지금 당장 있어야 하면서 나중에 수정하기 쉽게 하는 것이 목표이다. 현재 코드가 동작하게 하는 문제는 쉽지만, 수정하기 쉽게 만드는 것은 다른 문제이다.

### 2.1. 클래스에 무엇이 포함될지 정하기

#### 2.1.1. 클래스에 Method를 그룹핑하기

루비와 같은 객체지향 언어에서 메소드들은 클래스안에 정의되어 있다. 한번 생성된 클래스는 어플리케이션에 영원히 영향을 미칠것이다. 하지만, 메소드들을 알맞게 그룹핑하는것이 중요할지라도 프로젝트의 초반에 그것을 정하는 것이란 어려운 일이다. 또한, 성공적으로 그룹핑 했다고 하더라도 어플리케이션이 변하게 되다면 또 수정해야할 일이 발생할 수 있다. 디자인이란 완벽을 추구하는 행동이 보다는 영구적 변화에 대한 예술이다.

#### 2.1.2. 쉽게 수정가능한 코드를 구성하기

수정하기 쉽다는 것은 명확하지 않기 때문에 그 의미를 정의할 필요가 있다.

> 수정하기 쉬운것의 정의

1. Changes have no unexpected side effects
2. Small changes in requirements require correspondingly small changes in code
3.  Existing code is easy to reuse
4. The easiest way to make a change is to add code that in itself is easy to change

> 수정하기 쉬운것의 기준 (TRUE)

1. **Transparent** The consequences of change should be obvious in the code that is changing and in distant code that relies upon it
2. **Reasonable** The cost of any change should be proportional to the benefits the change achieves
3. **Usable** Existing code should be usable in new and unexpected contexts
4. **Exemplary** The code itself should encourage those who change it to perpetuate these qualities

TURE를 만족하는 코드를 짜는 것의 첫 번째 단계는 각 클래스는 **단 하나의 잘 정의된 책임**을 가지는 것이다.

### 2.2. 하나의 책임을 지는 클래스 만들기

클래스는 최대한 작으면서도 유용해야한다. 즉, 클래스는 단일 책임을 가져야 한다. 

#### 2.2.1. 자전거와 기어

자전거를 탈 때는 작은 기어(페달이 가벼워지고 느려짐), 큰 기어(페달이 무겁고 빨라짐) 중에 선택할 수 잇다. 기어는 발이 페달을 돌리는 힘으로 바퀴를 돌린다. 구체적으로는 페달이 회전할 때마다 바퀴가 얼마나 회전하는지를 기어에서 제어한다.

![image](https://user-images.githubusercontent.com/53181778/85508105-65bf2d00-b62e-11ea-9079-42ae9ca02fea.png)

크고 작은 기어를 비율로 표현할 수 있다.

```ruby
chainring = 52 # number of teeth
cog = 11
ratio = chainring / cog.to_f
puts ratio # -> 4.72727272727273

chainring = 30
cog = 27
ratio = chainring / cog.to_f
puts ratio # -> 1.11111111111111
```

위 코드를 기어 클래스로 만들어보자. 기어는 chainring, cog, ratio를 가지고 data와 behavior를 가지게 된다.

```ruby
class Gear
	attr_reader :chainring, :cog
    
	def initialize(chainring, cog)
	@chainring = chainring
	@cog = cog
	end
    
	def ratio
    	chainring / cog.to_f
	end
end

puts Gear.new(52, 11).ratio # -> 4.72727272727273
puts Gear.new(30, 27).ratio # -> 1.11111111111111 
```

Gear클래스는 Object클래스의 서브 클래스로 많은 메소드들을 상속 받는다. 그렇게 때문에 응답할 수 있는 메세지의 집합(behavior의 집합)이 꽤 큰편이다. 상속은 어플리케이션 설계에 중요하지만, Gear클래스와 같이 간단한 경우는 매우 기본적인 상속에 해당하기 때문에 상속된 메소드가 없다고 생각해도 된다. (상속의 복잡한 형태는 6장에서 다룰 것이다. )

만약, 두대의 자전거를 가지고 있고 서로 같은 기어를 가지고 있지만, 다른 사이즈의 바퀴를 가지는 경우라면 바퀴의 영향도 고려해야 할 것이다. 보통 기어 인치를 이용하여 바퀴와 기어가 다른 자전거들을 비교한다.

`gear inches = wheel diameter * gear ratio` where `wheel diameter = rim diameter + twice tire diameter`

```ruby
class Gear
  attr_reader :chainring, :cog, :rim, :tire
  def initialize(chainring, cog, rim, tire)
    @chainring = chainring
    @cog = cog
    @rim = rim
    @tire = tire
  end

  def ratio
    chainring / cog.to_f
  end

  def gear_inches
    # tire goes around rim twice for diameter
    ratio * (rim + (tire * 2))
  end
end

puts Gear.new(52, 11, 26, 1.5).gear_inches
# -> 137.090909090909
ㄴ
puts Gear.new(52, 11, 24, 1.25).gear_inches
# -> 125.272727272727
```

하지만, 만약 기존에 사용하던 코드에서 `puts Gear.new(52, 11).ratio`와 같이 사용했다면, initialize의 파라미터 수와 맞지 않기 때문에 에러가 난다. gear_inches 기능을 추가하면서 생긴 버그이다. 아직까진 프로그램이 작기 때문에 큰 문제는 되지 않는다.

하지만, 이게 최선일까? 앞으로 더 많은 클래스가 생겨날 것이고 어플리케이션은 더 커질것이다. 더 효율적으로 확장시키기 위해 코드는 더 바꾸기 쉬워야 한다.

#### 2.2.2. 왜 단일 책임이 중요한가?

수정이 쉬운 어플리케이션은 재사용하기 쉬운 클래스들로 이루어져 있다. 재사용 가능한 클래스는 얽힘이 거의 없는 잘 정의된 행동의 접속 가능한 유닛(쉽게 가져다 쓸수 있는 유닛)이다. 

하나 보다 많은 책임이 있는 클래스는 재사용하기 어렵다. 여러 책임을 가지는 클래스는 얼기설기 얽혀있는 것과 같다. 만약, 클래스의 전체가 아니라 일부분을 재사용하고 싶다면, 필요한 부분들만 얻는 것은 불가능하다. 이제 두 가지 옵션이 있고 두개다 매력적인 옵션은 아니다.

책임들이 너무 결합되어 필요한 행동들만 사용할 수 없다면, 필요한 코드를 복제하여 사용할 수 있다. 하지만 코드를 복제하는 것은 추가적인 유지보수를 유도하고 버그를 증가시키기 때문에 좋은 방법이 아니다. 만약 필요한 행동들에만 접근할 수 있는 구조화된 클래스가 있다면, 클래스 전체를 재사용 할 수 있을 것이다. 하지만, 이것은 단지 하나의 문제를 다른 문제로 대치하는 것에 불과하다. 재사용하는 클래스는 원래의 목적이 혼동되고, 뒤얽힌 몇몇 책임을 포함하게 되기 때문에, 여러 이유로 바뀌어야 한다. 여러 일을 하는 클래스에 의존하게 되면 어플리케이션이 잘못될 가능성이 높아진다.

#### 2.2.3. 클래스가 단일 책임을 가지는지 판단하기

클래스가 하나의 책임만을 가지는지 판단하는 방법에는 무엇이 있을까?

클래스가 인격이 있는 것처럼 질문을 하는 방법이 있다. 모든 메소드들을 질문으로 바꾸면, 질문을 하는 것이 말이 된다. 예를 들어, Gea에게 `당신의 기어비는 무엇인가요?` 라고 물어볼 수 있다. 하지만, 기어클래스에 `당신의 기어인치는 몇인가요?` 또는 `당신의 타이어 사이즈는 얼마나 되나요?` 와 같은 질문은 이상하다. 하지만 기어 클래스에게 `당신의 타이어는 무엇인가요?` 라고 물어보는 것은 충분히 가능한 일이다. 기어 클래스에서, 타이어는 ratio나 gear_inches와는 다른 종류의 것이다. 다른 모든 객체의 관점으로부터, 기어가 응답할수 있는 것은 또 다른 메세지일 뿐이다. 만약 기어가 메세지에 응답할 수 있다면 무언가가 메세지를 보낼것이고, 기어가 바뀐다면 송신자는 놀랄수도 있다(?).

클래스가 실제로 무엇을 하고있는지 이해하는 또 다른 방법은, 클래스의 책임을 한 문장으로 묘사해 보는 것이다. 클래스는 최대한 작으면서 유용한 것만 해야한다. 그렇기 때문에 간단하게 묘사할 수 있어야 한다. 만약 가장 단순한 표현에 `그리고, 또는`이라는 단어가 들어간다면 여러개의 책임을 가지고 있다고 볼 수 있다.

객체지향 설계는 `cohesion(화합, 결합, 응집력)` 의 단어를 사용하여 단일 책임의 개념을 설명한다. 하나의 클랙스 안에 있는 모든 것들이 클래스의 핵심 목적에 연관되어 있을 때, 이 클래스는 강하게 cohesion(결합)되어 1개의 책임을 가진다고 할 수 있다.

단일 책임 원칙(Single Responsibility Principle (SRP) )은 Wirfs-Brock & Brian Wilkerson의 Responsibility-Driven Design (RDD)에 뿌리를 두고 있다. RDD는 `하나의 클래스는 클래스의 목적을 수행하는 책임들로 구성되어 있다.`고 말한다. SRP는 하나의 클래스가 하나의 매우 좁은 일(목적)을 하거나 사소한 이유로 바뀌는 것을 요구하지 않는다. 대신에 SRP는 응집력있게 클래스가 하는 모든것은 클래스의 목적과 매우 높게 연관이 있어야 하는 것을 요구한다.

기어 클래스의 책임을 표현하자면 “앞, 뒤 톱니바퀴 사이의 기어비를 계산한다”. 만약 그렇다면 위에서 만든 Gear 클래스는 너무나 많은 일을 하고있다. 만약 “자전거에 기어가 미치는 영향을 계산한다”로 표현한다면 더 어울릴 것이다. 그렇다면 gear_inches 는 Gear 에 속하는 것이 맞지만, 타이어의 크기가 Gear에 속하는 것은 애매하다.

#### 2.2.4. 언제 디자인을 만들지 판단하기

클래스에 뭔가 문제가 있다고 느껴지는 순간이 자주 있다. Gear클래스에 왜 바퀴가 있지? 사실은 Bicycle 클래스이지 않을까 하는 고민이 있을 수 있다.

하지만, 우리는 미래에 어떤일이 생길지 모르고 우리에게 그에 대한 ㅈ어보가 없다. 준비가 안된 상태에서 서둘러서 디자인을 결정해야 한다고 느끼는 것은 좋지 않다. 다만, Gear클래스를 보면서 문제를 느꼈다면, `지금 이 문제를 수정하지 않는 다면 나중에 어떤 대가를 치르게 될까?`라고 스스로에게 질문해보자. 어쩌면 더 많은 정보를 얻을때 까지 아무것도 하지 않고 기다려 보는 것이 효율적인 접근일 수도 있다.

Gear클래스의 코드는 투명하고 적잘하지만 훌륭한 디자인은 아니다.아무런 `의존성`도 없기 때문에 코드를 수정한다고 해서 특별한 문제는 발생하지 않을 뿐이다. 만약 다른 객체와 의존성이 생긴다면 Gear 클래스는 투명함과 적절함을 잃게 될 것이다. 이 떄가 코드를 다시 구성해야할 때 이다. 그리고 이 의존성이 좋은 디자인을 결정하는 정보를 제공해준다.

지금 코드를 수정하는 비용이나 나중에 수정하는 비용이나 필요한 비용이 동일하다면 결정을 나중으로 미루는 것이 좋다. **디자인 결정은 꼭 필요한 순간에, 그 순간이 제공하는 정보들을 가지고 해야한다.**

하지만 Gear클래스는 지금당장 수정해야할지, 변경해야할지 의견이 분분할 것이다. 현재 클래스의 구조는 미래의 개발자에게 지금의 디자인 의도를 전달하는 메세지 이다. 미래의 개발자는 현재의 디자인 패턴을 참조할 것이다. 결론적으로, Gear클래스는 디자인 의도를 잘못 전달하고 있다. 사용성이 좋지도 않고, 좋은 코드도 아니다. 여러가지 책임을 가지고 있기 때문에 재사용하면 안되는 코드이다.

## 2.3 Writing Code That Embraces Change

나중에 수정에 필요한 경우에라도 쉽게 수정될 수 있도록 코드를 배치하는 일은 가능하다. 즉, 수정하기 쉬운 방식으로 코드를 하는 것이다.

### 2.3.1  데이터가 아닌 행동에 의존하기

행동은 메서드에 담겨있고 메세지를 보내는 행위를 통해 실행된다. 하나의 책임을 가지는 클래스를 만들때, 행동의 모든 작은 조각들은 한 장소에 속하게 된다. Don't Repeat Yorself(DRY)라는 문장은 이러한 아이디어를 의미한다. 행동을 바꾸는 것은 코드의 어떤 한 부분만을 바꾸면 되기 때문에, DRY 코드는 변화를 견뎌낼 수 있다.

객체는 행동과 함께 데이터를 가진다. 데이터는 객체의 인스턴스 변수에 속해 있고, 간단한 문자열이나 복잡한 해시일 수 있다. 데이터는 두가지 방법 중 하나로 접근할 수 있다. 인스턴스 변수를 직접 참조하거나, accessor 메서드안에 인스턴스 변수를 감싸는 방법이 있다.

- 인스턴스 변수 숨기기

  아래의 ratio 메서드 처럼, 직접 인스턴스 변수를 참조하는 대신에 인스턴스 변수를 accessor 메서드에 감싸서 접근하라.

  ```ruby
  class Gear
      def initialize(chainring, cog)
          @chainring = chainring
          @cog = cog
      end
      def ratio
          @chainring / @cog.to_f # <-- road to ruin
      end
  end
  ```

  클래스에서 변수들을 정의하고 있을지라고, 메서드로 변수를 감싸서 숨겨라. 루비는 `attr_reader`를 제공하여 캡슐화된 메서드를 쉽게 만들수 있다.

  ```ruby
  class Gear
      attr_reader :chainring, :cog # <-------
      def initialize(chainring, cog)
          @chainring = chainring
          @cog = cog
      end
  
      def ratio
          chainring / cog.to_f # <-------
      end
  end
  ```

  `attr_reader`는 변수를 감쌀 수 있는 간단한 wrapper 메서드를 생들어 준다. 

  > cog를 위한 가상의 wrapper 메서드 

  ```ruby
  # default implementation via attr_reader
  def cog
  	@cog
  end
  ```

  cog메서드만이 cog가 무엇을 의미하는지 이해할 수 있는 유일한 방법이다.  cog는 메세지 전송의 결과가 되었다. 이 메서드 구현함으로 cog는 `모든 곳에서 참조되는 데이터`에서 `한 번만 정의된 행동`으로 바뀌었다.

  `@cog` 인스턴스 변수가 10번 참조되고 갑자기 @cog의 내용을 바꿔야 한다면, 코드의 여러 부분을 수정해야 한다. 하지만 @cog가 래퍼 메서드로 감싸져 있었다면 cog 메서드를 직접 구현해서 cog가 어떤 의미인지 다시 정의할 수 있다. 우리가 직접 작성한 새로운 메서드는 아래의 첫 번째 예시처럼 간단할 수도 있고 두 번째 예시처럼 더 복잡할 수도 있다.

  #1

  ```ruby
  # a simple reimplementation of cog
  def cog
      @cog * unanticipated_adjustment_factor
  end
  ```

  #2

  ```ruby
  # a simple reimplementation of cog
  def cog
     	@cog * (foo? ? bar_adjustment : baz_adjustment)
  end
  ```

  데이터를 마치 '메시지를 이해하는 객체' 처럼 취급하는 것은 두 가지 이슈를 품고 있다.

  첫 번째 이슈는 `가시성`이다. `@cog`변수를 public 메서드로 감쌀 경우 다른 객체에 `@cog`변수에 접근할 수 있음을 의미한다. 반대로, private 메서드로 감쌀경우 외부에서는 접근할 수 없다. 이 두 선택지에 대해서는 4장에서 다룬다.
  
  두 번째 이슈는 조금더 더 추상적이다. 모든 변수를 메서드로 감싸고, 어떤 변수든지 마치 객체인것 처럼 다룰 수 있기 때문에 데이터와 보통의 객체를 구분하는 것이 무의미해진다. 가끔 어플리케이션의 일부분을 행동이 없는 데이터라 생각하는 것이  편리할 수 있지만, 대부분의 경우 데이터를 일반적인 객체로 받아들이는 것이 더 좋다.
  
  데이터를 감춤으로 예상치 못한 변화로부터 코드를 보호할 수 있다. 개발자도 데이터의 모든 행동을 다 알 수 없다. 변수를 데이터 처럼 생각할 지라도, 변수는 메시지를 보내는 것으로 접한하는 것이 좋다.

- 데이터 구조 숨기기

  인스턴스 변수에 애착을 가지는 것은 안좋지만, 복잡한 데이터 구조를 가지는 것은 더욱 더 좋지 않다. 아래의 ObscuringReferences 클래스를 보자.

  ```ruby
  class ObscuringReferences
      attr_reader :data
      def initialize(data)
          @data = data
      end
  
      def diameters
          # 0 is rim, 1 is tire
          data.collect {|cell|
              cell[0] + (cell[1] * 2)}
      end
      # ... many other methods that index into the array
  end
  ```

  이 클래스는 2차원 배열의 rims와 tires로 초기화 된다.

  ```ruby
  # rim and tire sizes (now in millimeters!) in a 2d array
  @data = [[622, 20], [622, 23], [559, 30], [559, 40]]
  ```

  ObscuringReferences 는 @data에 초기화 아규먼트를 저장하고, @data를 메서드에 감싸기 위해 attr_reader를 사용했다. diamwters메서드는 data에게 변수의 내용물에 접근하는 메세지를 보낸다. 이렇게 클래스 내부에서도 인스턴스 변수를 숨기고 있다.

  하지만, @data는 복잡한 데이터 구조를 가지고 있다. 단순히 인스턴스 변수를 숨기는 것만으로는 충분하지 ㅇ낳다. data 메서드는 단순히 배열을 반환할 뿐이다. 배열을 가지고 어떤 작업을 하려면, data메서드를 전송하는 객체의 정보를 잘 알고 있어야한다.

  diameters 메서드는 지름을 계산하는 것 뿐만아니라, rims와 tires를 배열의 어디서 찾아야 하는지 알고 있다. 배열의 [0]에 rims가 [1]에는 tires가 있다는 것을 알고 있다.

  이것은 배열의 구조에 의존적이다. 만약 데이터 구조가 바뀐다면 코드는 반드시 바뀌어야 한다. 배열에 데이터를 가지고 있을 때, 어플리케이션 곳곳에서 배열의 구조를 참조하는 코드를 작성해야 한다. 이런 참조는 위험하다. 변수의 캡슐화를 무시하고 배열 구조에 대한 지식을 코드 이곳저곳에 흩뿌려 놓는다. 전혀 DRY하지 않다. rims가 [0]에 있다는 것이 중복되어서는 안된다. 한 장소에서 이러한 것들을 관리해야한다.

  간단한 예시로 이것이 얼마나 나쁜지 충분히 확인할 수 있다. data가 여러 해시들로 이루어진 배열을 반환하고 이 배열을 코드의 여러 곳에서 사용한다고 상상해 보자. data의 구조를 변경한다면 코드 곳곳에 영향을 미칠 것이다. 그리고 각각의 변화는 버그를 만들수 있다.

  루비는 구조에서 의미를 손쉽게 분리할 수 있게 해준다. 메서드로 인스턴스 변수를 손쉽게 감쌀 수 있는 것처럼 루비의 `Struct 클래스`를 이용하면 데이터 구조를 감쌀 수 있다. 앞의 클래스와 동일한 외부 인터페이스를 가지고 있지만, 내부 인터페이스는 전혀 다르게 구현하였다.  

  ```ruby
  class RevealingReferences
      attr_reader :wheels
      def initialize(data)
          @wheels = wheelify(data)
      end
      def diameters
          wheels.collect {|wheel|
              wheel.rim + (wheel.tire * 2)}
      end
      # ... now everyone can send rim/tire to wheel
  
      Wheel = Struct.new(:rim, :tire)
      def wheelify(data)
          data.collect {|cell|
              Wheel.new(cell[0], cell[1])}
      end
  end
  ```

  변경된 클래스의 diameters 메서드는 배열의 내부 구조에 대한 지식이 전혀 없다. diameters가 알고있는 전부는 wheels 메세지가 enumerable를 리턴한다는 것과 각각의 enumerable에 속해 있는 모든 객체가 rim과 tire메서드에 응답할 수 있다는 것이다. 기존에는 cell[1]에 대한 참조였지만, wheel.tire로 메세지를 보내는 방식으로 바뀌었다.

  입력받은 배열의 구조에 대한 모든 지식은 `wheelify` 메서드 속에 격리되었고 이 메서드는 `배열들의 배열`을 `Struct들의 배열`로 변환 시켰다.루비 공식문서에는 `Struct`는 `명시적으로 클래스를 만들지 않고도 accesor 메서드를 이용해 여러 어트리뷰트들을 묶어내는 편리한 방법`이라고 정의한다. 즉, rim과 tire 메서드에 반응하는 작고 가벼운 객체를 만들어 준 것이다.

  

