# 99. PRACTICAL OBJECT-ORIENTED DESIGN IN RUBY

>PRACTICAL OBJECT-ORIENTED DESIGN IN RUBY 책을 읽고 내용을 정리합니다.

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./README.md)

---

<!-- TOC -->

- [1. Object-Oriented Design](#1-object-oriented-design)
	- [1.1 객체 지향 디자인의 원칙과 디자인 패턴](#11-객체-지향-디자인의-원칙과-디자인-패턴)
	- [1.2 객체 지향 언어](#12-객체-지향-언어)

<!-- /TOC -->

## 1. Object-Oriented Design

세상은 절차적이다. 시간의 흐름대로 사건이 흘러간다. 또한, 세계는 객체지향적이다. 객체들의 행동은 자연스럽게 섞이기 때문에 예상치 못한 행동들의 조합이 나타날 수 있다.

절차적 프로그램은 예상치 못한 행동들의 조합을 프로그래밍하기 어려운 경우가 많다. 이를 해결하기 위해 객체지향 설계가 등장해다. 객체지향 디자인은 이미 정해진 절차들을 묶음으로 생각하지 않고, 객체가 서로 주고받는 메세지들의 연속으로 파악해야 한다. 그렇게 때문에 프로그래머는 객체들의 연관성을 잘 정의해준다면 모든 사건의 조합을 만들어낼 필요가 없다.

객체지향 설계에 실패하는 것은 관점이 제대로 확립되지 않아서이다. 객체지향적 관점을 확실히 가지게 되면 실패할 수 없다.

객체지향 어플리케이션은 상호작용하는 여러 객체로 구성되어 있고 상호작용하는 방석은 서로 메세지를 주고받는 것이다. 여기서 송신하고 수신하는 객체가 두 객체 사이의 의존성을 만들어 내고, 이러한 의존성으로 인해 객체를 수정하는 것이 어려워진다.

객체 지향 설계는 의존성 관리에 관한 것이다. 객체들이 변화를 용인할 수 있도록 의존성을 잘 관리하는 것이 객체 지향 디자인이다. 제대로된 설계가 되지 않으면 객체들이 서로에 대해 너무 많이 알기 떄문에 관리되지 않는 의존성은 큰 혼란을 초래한다.

모든 어플리케이션은 코드의 집합이고, 코드를 어떻게 배열하는 것이 바로 설계이다. 설계를 할 때 고려해야 할 것이 두가지가 있다. 먼저 현재의 기능을 충실히 구현할 수 있어야한다는 것이다. 두번째는 나중에 변경될 수 있는 것을 고려해서 코드를 작성해야 한다는 것이다.

디자인은 나중에 디자인할 수 있는 여지를 남겨 놓기 위한 것이고, 그 최종 목표는 변화의 비용을 최소화하는 것이다.

### 1.1 객체 지향 디자인의 원칙과 디자인 패턴

`SOLID`는 마이클 플레즈가 만들고 로버트 마틴이 대중화한 객체 지향 설계의 5가지 원리이다.

1. Sngle Responsibility - 단일 책임
2. Open-Closed - 개방-폐쇄
3. Liskov Substitution - 리스코프 치환
4. Interface Segregation - 인터페이스 분리
5. Dependency Inversion - 의존성 역전

다른 디자인 원칙으로는 앤디 헌트와 데이브 토머스의 `DRY`(Don't Retape Yourself)와 노스이스트 대학교의 데메터 프로젝트의 `Law of Demeter`(LoD)가 있다. 이러한 설계 원칙들을 이 책을 통해서 다룬다.

또한, 객체지향 디자인의 원칙 외에도 디자인 패턴을 이해하는 것이 중요하다. <GoF의 디자인 패턴>은 패턴이란 객체지향 소프트웨어 디자인에서 명확한 문제를 처리하는 간단하고도 우아한 해결책이라고 말한다. 디자인 패턴은 **동일한 문제를 같은 방식으로 해결할 수 있는 방법**에 이름을 부여한 것을 말한다. 디자인 패턴은 프로그래머들이 서로 소통하고 협업할 수 있는 방법을 제공해 주었다.

디자인은 **반복적인 피드백**과 함께하는 **점진적인 발견**의 과정이다. 그리고 디자인은 지속적인 자기조절 능력을 갖추고, 자연스럽게 발전하는 것이 가장 좋다. 때문에 반복과 점진적인 발전을 중시하는 애자일 소프트웨어 개발은 잘 디자인된 애플리케이션을 만드는 데 매우 적합하다. 좋은 애플리케이션을 위해서는 **초기에 큰 디자인을 구상하지 않고 계속해서 디자인을 변경해주는 게 좋다**.

### 1.2 객체 지향 언어

 일반적인 절차지향적인 언어와 다르게 루비와 같은 객체지향 언어는 데이터와 행동(함수)를 완전히 분리하지 않고 하나의 객체에 결합하여 넣는다. 즉, 객체는 행동과 데이터를 포함하고, 객체만이 제어할 수 있는 데이터를 포함한다. 객체는 서로 메세지를 보내면서 서로의 행동을 불러 일으킨다.

루비는 문자열 데이터 타입 대신 문자열 객체를 가지고 있다. 문자열로 작동하는 연산은 언어의 문법대신에 문자열 객체에 내장되어 있다. 각각의 문자열 객체는 고유한 개인 데이터 문자열을 포함한다는 점에서 다르지만, 모든 문자열 객체는 동일한 동작을 한다는 점에서 유사하다고 볼 수 있다.

문자열 객체가 자체적으로 알맞은 행동을 제공해 주기때문에 문자열 데이터의 타입에 대해서 특별히 신경쓸 필요가 없다. 프로그래머는 객체가 메세지를 보내는 일반적인 방법만 알면 된다.

루비와 같은 클래스 기반의 객체 지향 언어는 유사한 객체의 구성에 대한 청사진을 제공하는 클래스를 정의 할 수 있다. 클래스는 메서드와 프로퍼티를 정의한다. 메서드는 메세지에 응답하여 호출된다. 동일한 메서드 이름은 다른 오브젝트에서도 정의될 수 있다. 전송된 메세지에 대한 올바른 오브젝트의 메서드를 찾고 호출하는 것은 루비의 역할이다.

클래스는 단순한 데이터 이상의 유형을 정의한다. 물체의 유형을 알면 물체가 어떻게 행동할지 예상할 수 있다. 절차지향 언어에서 변수는 단일 데이터 타입을 가진다. 이 데이터 타입에 대한 지식은 어떤 연산이 유효한지에 대한 예상하게 한다. 루비에서는 하나의 객체는 많은 타입을 가질 수 있다. 객체의 타입을 아는 것은 객체가 응답하는 메세지의 대한 예상을 할수 있게 한다.

루비에는 미리 정의된 클래스가 많이 있다. 가장 즉시 알아차릴수 있는 클래스는, 절차지향에서 쓰이는 데이터 타입과 중복되는 것들이다. 예를들면 스트링 클래스나, 정수를 표현하기 위한 Fixnum클래스 등이 있다. 보통은 모든 데이터 타입을 위한 미리정의된 클래스가 있다.

하지만, 객체지향 언어는 그 자체로 객체를 이용하여 만들어지고 이 점이 흥미로운 부분이다. 스트링 클래스 (새로운 문자열 객체를 위한 청사진)은 그 자체로 객체이다. 즉, String 클래스 또한 Class 클래스의 인스턴스이다. 모든 스트링 객체가 데이터가 구체화된 String 클래스의 객체라면, 모든 클래스 객체(String Fixnum ..)는 구체화된 데이터를 가지는 Class클래스의 인스턴스인 것이다. String 클래스가 새로운 문자열들은 만든다면, Class 클래스는 새로운 클래스들을 만든다.

## 2. Designing Classes with a Single Responsibility

객체지향 시스템에서 기초가 되는 것은 메세지이지만, 가장 뚜렷하게 확인할 수 있는 구조는 class이다. 메시지가 디자인의 핵심이지만, 클래스가 더 뚜렷하기 때문에 이번 장에서는 클래스에 속하는 것을 정하는 방법에 대해서 집중할 것이다.

만들려는 클래수가 무엇이고, 얼마나 많으며 어떠한 행동을 포함하고 있고 다른 클래스와의 관계는 어떠한지 정하는지에 대한 질문이 있을 수 있다. 이에 대한 정답은 클래스는 단순해야 한다는 것이다.

어플레케이션을 모델링하고, 클래스를 사용해서 지금 당장 있어야 하면서 나중에 수정하기 쉽게 하는 것이 목표이다. 현재 코드가 동작하게 하는 문제는 쉽지만, 수정하기 쉽게 만드는 것은 다른 문제이다.

### 2.1 클래스에 무엇이 포함될지 정하기

- 클래스에 Method를 그룹핑하기

  루비와 같은 객체지향 언어에서 메소드들은 클래스안에 정의되어 있다. 한번 생성된 클래스는 어플리케이션에 영원히 영향을 미칠것이다. 하지만, 메소드들을 알맞게 그룹핑하는것이 중요할지라도 프로젝트의 초반에 그것을 정하는 것이란 어려운 일이다. 또한, 성공적으로 그룹핑 했다고 하더라도 어플리케이션이 변하게 되다면 또 수정해야할 일이 발생할 수 있다. 디자인이란 완벽을 추구하는 행동이 보다는 영구적 변화에 대한 예술이다.

- 쉽게 수정가능한 코드를 구성하기

  수정하기 쉽다는 것은 명확하지 않기 때문에 그 의미를 정의할 필요가 있다.

  > 수정하기 쉬운것의 정의

  1. Changes have no unexpected side effects
  2. Small changes in requirements require correspondingly small changes in code
  3.  Existing code is easy to reuse
  4. The easiest way to make a change is to add code that in itself is easy to change

  > 수정하기 쉬운것의 기준 (TRUE)

  1. **Transparent** The consequences of change should be obvious in the code that is changing and in distant code that relies upon it
  2. **Reasonable** The cost of any change should be proportional to the benefits the change achieves
  3. **Usable** Existing code should be usable in new and unexpected contexts
  4. **Exemplary** The code itself should encourage those who change it to perpetuate these qualities

TURE를 만족하는 코드를 짜는 것의 첫 번째 단계는 각 클래스는 **단 하나의 잘 정의된 책임**을 가지는 것이다.

### 2.2. 하나의 책임을 지는 클래스 만들기

클래스는 최대한 작으면서도 유용해야한다. 즉, 클래스는 단일 책임을 가져야 한다. 

- 예시) 자전거와 기어

  자전거를 탈 때는 작은 기어(페달이 가벼워지고 느려짐), 큰 기어(페달이 무겁고 빨라짐) 중에 선택할 수 잇다. 기어는 발이 페달을 돌리는 힘으로 바퀴를 돌린다. 구체적으로는 페달이 회전할 때마다 바퀴가 얼마나 회전하는지를 기어에서 제어한다.

  ![image](https://user-images.githubusercontent.com/53181778/85508105-65bf2d00-b62e-11ea-9079-42ae9ca02fea.png)

  크고 작은 기어를 비율로 표현할 수 있다.

  ```ruby
  chainring = 52 # number of teeth
  cog = 11
  ratio = chainring / cog.to_f
  puts ratio # -> 4.72727272727273
  
  chainring = 30
  cog = 27
  ratio = chainring / cog.to_f
  puts ratio # -> 1.11111111111111
  ```

  위 코드를 기어 클래스로 만들어보자. 기어는 chainring, cog, ratio를 가지고 data와 behavior를 가지게 된다.

  ```ruby
  class Gear
  	attr_reader :chainring, :cog
      
  	def initialize(chainring, cog)
  	@chainring = chainring
  	@cog = cog
  	end
      
  	def ratio
      	chainring / cog.to_f
  	end
  end
  
  puts Gear.new(52, 11).ratio # -> 4.72727272727273
  puts Gear.new(30, 27).ratio # -> 1.11111111111111 
  ```

  Gear클래스는 Object클래스의 서브 클래스로 많은 메소드들을 상속 받는다. 그렇게 때문에 응답할 수 있는 메세지의 집합(behavior의 집합)이 꽤 큰편이다. 상속은 어플리케이션 설계에 중요하지만, Gear클래스와 같이 간단한 경우는 매우 기본적인 상속에 해당하기 때문에 상속된 메소드가 없다고 생각해도 된다. (상속의 복잡한 형태는 6장에서 다룰 것이다. )
  
  만약, 두대의 자전거를 가지고 있고 서로 같은 기어를 가지고 있지만, 다른 사이즈의 바퀴를 가지는 경우라면 바퀴의 영향도 고려해야 할 것이다. 보통 기어 인치를 이용하여 바퀴와 기어가 다른 자전거들을 비교한다.
  
  `gear inches = wheel diameter * gear ratio` where `wheel diameter = rim diameter + twice tire diameter`
  
  ```ruby
  class Gear
    attr_reader :chainring, :cog, :rim, :tire
    def initialize(chainring, cog, rim, tire)
      @chainring = chainring
      @cog = cog
      @rim = rim
      @tire = tire
    end
  
    def ratio
      chainring / cog.to_f
    end
  
    def gear_inches
      # tire goes around rim twice for diameter
      ratio * (rim + (tire * 2))
    end
  end
  
  puts Gear.new(52, 11, 26, 1.5).gear_inches
  # -> 137.090909090909
  ㄴ
  puts Gear.new(52, 11, 24, 1.25).gear_inches
  # -> 125.272727272727
  ```
  
  하지만, 만약 기존에 사용하던 코드에서 `puts Gear.new(52, 11).ratio`와 같이 사용했다면, initialize의 파라미터 수와 맞지 않기 때문에 에러가 난다. gear_inches 기능을 추가하면서 생긴 버그이다. 아직까진 프로그램이 작기 때문에 큰 문제는 되지 않는다.
  
  하지만, 이게 최선일까? 앞으로 더 많은 클래스가 생겨날 것이고 어플리케이션은 더 커질것이다. 더 효율적으로 확장시키기 위해 코드는 더 바꾸기 쉬워야 한다.
  
- 왜 단일 책임이 중요한가?

  수정이 쉬운 어플리케이션은 재사용하기 쉬운 클래스틀로 이루어져 있다. 재사용 가능한 클래스는 얽힘이 거의 없는 잘 정의된 행동의 접속 가능한 유닛이다. 

  하나 보다 많은 책임이 있는 클래스는 재사용하기 어렵다. 여러 책임을 가지는 클래스는 얼기설기 얽혀있는 것과 같다. 만약, 클래스의 전체가 아니라 일부분을 재사용하고 싶다면, 필요한 부분들만 얻는 것은 불가능하다. 이제 두 가지 옵션이 있고 두개다 매력적인 옵션은 아니다.

  책임들이 너무 결합되어 필요한 행동들만 사용할 수 없다면, 필요한 코드를 복제하여 사용할 수 있다. 하지만 코드를 복제하는 것은 추가적인 유지보수를 유도하고 버그를 증가시키기 때문에 좋은 방법이 아니다. 만약 필요한 행동들에만 접근할 수 있는 구조화된 클래스가 있다면, 클래스 전체를 재사용 할 수 있을 것이다. 하지만, 이것은 단지 하나의 문제를 다른 문제로 대치하는 것에 불과하다. 재사용하는 클래스는 원래의 목적이 혼동되고, 뒤얽힌 몇몇 책임을 포함하게 되기 때문에, 여러 이유로 바뀌어야 한다. 여러 일을 하는 클래스에 의존하게 되면 어플리케이션이 잘못될 가능성이 높아진다.

- 클래스가 단일 책임을 가지는지 판단하기

  클래스가 하나의 책임만을 가지는지 판단하는 방법에는 무엇이 있을까?

  클래스가 인격이 있는 것처럼 질문을 하는 방법이 있다. 모든 메소드들을 질문으로 바꾸면, 질문을 하는 것이 말이 된다. 예를 들어, Gea에게 `당신의 기어비는 무엇인가요?` 라고 물어볼 수 있다. 하지만, 기어클래스에 `당신의 기어인치는 몇인가요?` 또는 `당신의 타이어 사이즈는 얼마나 되나요?` 와 같은 질문은 이상하다. 하지만 기어 클래스에게 `당신의 타이어는 무엇인가요?` 라고 물어보는 것은 충분히 가능한 일이다. 기어 클래스에서, 타이어는 ratio나 gear_inches와는 다른 종류의 것이다. 다른 모든 객체의 관점으로부터, 기어가 응답할수 있는 것은 또 다른 메세지일 뿐이다. 만약 기어가 메세지에 응답할 수 있다면 무언가가 메세지를 보낼것이고, 기어가 바뀐다면 송신자는 놀랄수도 있다(?).

  클래스가 실제로 무엇을 하고있는지 이해하는 또 다른 방법은, 클래스의 책임을 한 문장으로 묘사해 보는 것이다. 클래스는 최대한 작으면서 유용한 것만 해야한다. 그렇기 때문에 간단하게 묘사할 수 있어야 한다. 만약 가장 단순한 표현에 `그리고, 또는`이라는 단어가 들어간다면 여러개의 책임을 가지고 있다고 볼 수 있다.

  객체지향 설계는 `cohesion(화합, 결합, 응집력)` 의 단어를 사용하여 단일 책임의 개념을 설명한다. 하나의 클랙스 안에 있는 모든 것들이 클래스의 핵심 목적에 연관되어 있을 때, 이 클래스는 강하게 cohesion(결합)되어 1개의 책임을 가진다고 할 수 있다.

  단일 책임 원칙(Single Responsibility Principle (SRP) )은 Wirfs-Brock & Brian Wilkerson의 Responsibility-Driven Design (RDD)에 뿌리를 두고 있다. RDD는 `하나의 클래스는 클래스의 목적을 수행하는 책임들로 구성되어 있다.`고 말한다. SRP는 하나의 클래스가 하나의 매우 좁은 일(목적)을 하거나 사소한 이유로 바뀌는 것을 요구하지 않는다. 대신에 SRP는 응집력있게 클래스가 하는 모든것은 클래스의 목적과 매우 높게 연관이 있어야 하는 것을 요구한다.

  기어 클래스의 책임을 표현하자면 “앞, 뒤 톱니바퀴 사이의 기어비를 계산한다”. 만약 그렇다면 위에서 만든 Gear 클래스는 너무나 많은 일을 하고있다. 만약 “자전거에 기어가 미치는 영향을 계산한다”로 표현한다면 더 어울릴 것이다. 그렇다면 gear_inches 는 Gear 에 속하는 것이 맞지만, 타이어의 크기가 Gear에 속하는 것은 애매하다.

- 언제 디자인을 만들지 판단하기

  Gear 처럼 불안한 클래스를 본다면, “지금 암것도 안하면 나중에 어떤 대가 치를까?” 라고 질문하기

  현재 Gear 는 다른 객체와의 의존성이 생길 경우 `투명함`과 `적절함`을 잃게 됨 바로 이 순간이 코드 재구성해야할 때