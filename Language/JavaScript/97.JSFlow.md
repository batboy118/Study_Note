# 97. JS Flow

> 정재남님의 JS Flow 강의를 정리

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./README.md)

---

<!-- TOC -->

- [1. 데이터 타입](#1-데이터-타입)
- [2. 함수](#2-함수)
	- [2.1. Hoisting (호이스팅)](#21-hoisting-호이스팅)
	- [2.2. 함수 선언식과 함수 표현식](#22-함수-선언식과-함수-표현식)
	- [2.3. 함수 스코프, 실행 컨텍스트](#23-함수-스코프-실행-컨텍스트)
	- [2.4. 메소드(Method)](#24-메소드method)
	- [2.5. 콜백 함수 (Callback function)](#25-콜백-함수-callback-function)
- [3. this](#3-this)
	- [3.1 전역공간에서 this](#31-전역공간에서-this)
	- [3.2. 함수 내부에서 this](#32-함수-내부에서-this)
	- [3.3. 메소드 호출 시 this](#33-메소드-호출-시-this)
	- [3.4. callback 함수에서 this](#34-callback-함수에서-this)
	- [3.5. 생성자함수에서 this](#35-생성자함수에서-this)
- [4. 클로저(Closure)](#4-클로저closure)
	- [4.1. 클로저의 정의](#41-클로저의-정의)
	- [4.2. 클로저의 활용 : Private member 만들기](#42-클로저의-활용--private-member-만들기)

<!-- /TOC -->

## 1. 데이터 타입

자바스크립트의 데이터 타입은 크게 두 가지로 구분된다.

1. 기본형(Primitive Type)
   - Number
   - String
   - Boolean
   - null
   - undefined
   - Symbol (ES6에서 추가됨)

2. 참조형(Reference Type)

   - Object
     - Array
     - Function
     - RegExp (정규표현식)
     - Set  (ES6에서 추가됨)
     - Map  (ES6에서 추가됨)
     - WeakSet  (ES6에서 추가됨)
     - WeakMap  (ES6에서 추가됨)

   > 참조현은 Object(객체)가 있고 그 하위에 배열, 함수, 정규표현식 등이 존재한다.

**기본형**은 값을 그대로 할당하는 형태이고, **참조형**은 값이 저장된 주소값을 할당 즉 참조를 하는 형태이다.

참조형 데이터 안에 참조형 데이터가 존재하는 형태를 `nested 객체`라고 한다.

## 2. 함수

### 2.1. Hoisting (호이스팅)

호이스팅은 선언과 관련된 자바스크립트의 특성이다.

변수의 선언과 함수의 선언을 위로 끌어 올리는 것을 호이스팅이라 한다.

```javascript
console.log(a)
console.log(b)
console.log(c)

// f()
// undefined
// undefined

function a(){
    return 'a';
}
var b = function bb(){
    return 'bb';
}
var c = function() {
    return 'c';
}
```

이러한 코드는 다른 언어라면 앞서 선언되지 않은 변수들은 사용하기 때문에 에러가 발생하지만, 자바스크립트에서는 그렇지 않다.

자바스크립트 엔진에서는 아래와 같은 순서로 실행하게 된다.

```js
function a(){
    return 'a';
}
var b;
var c;

console.log(a) // f()
console.log(b) // undefined
console.log(c) // undefined

b = function bb(){
    return 'bb';
}
c = function() {
    return 'c';
}
```

함수 선언문인 a는 통째로 올라간 반면에, 함수표현식(변수에 함수를 할당한 것)은 변수의 선언만 위로 올라가게 된다. 즉, 할당은 호이스팅의 대상이 아닌 선언만 호이스팅의 대상이 된다.

즉, 선언과 할당이 동시에 있을 경우 분리가 가능하기 때문에 선언만 위로가고, 할당은 그자리에 남아 있게 된다.

### 2.2. 함수 선언식과 함수 표현식

위에서 다루었던 코드를 살펴보자.

```js
//함수 선언문 (function declartion)
function a(){
    return 'a';
}

//기명(유명) 함수표현식 (named function expression)
var b = function bb(){
    return 'bb';
}

//(익명) 함수표현식 ((unnamed / annonymous) function expression)
var c = function() {
    return 'c';
}
```

예전에는 기명 함수표현식의 이점이 컸다. 그 이유는 에러가 발생할 때 어떤 함수에서 에러가 발생했는지 콘솔로 출력이 되기 때문에 디버깅이 편했다.

하지만, 최근의 브라우저들은 함수명이 비어있을 경우 자동으로 변수명을 함수의 이름으로 할당하기 때문에 디버깅을 위해서 기명함수를 쓰는일이 거의 없어졌다.

익명 함수표현식이 선언되고 정의되는 순서를 살펴보자.

```js
var c = function() {
    return 'c';
}
```

1. 변수 c선언

   ```js
   var c
   ```

2. 익명함수 선언

   ```js
   function() {
   	return 'c';
   }
   ```

3. **선언된 익명함수를 변수 c에 할당**

**함수 선언문**과 **함수 표현식**의 가장 큰 차이는 **할당의 여부**이다. 함수 표현식에서 할당이 이루어지기 때문에 익명함수는 호이스팅 되지 않고, 변수 c만 호이스팅된다.

**함수 선언문은 호이스팅때문에 큰 문제를 낳기도한다.**

아래의 코드를 예로 들어보자.

```js
function sum(a, b) {
	return a + ' + ' + b + ' = ' + ( a + b );
}
sum(1, 2); // 3 (의도치 않은 결과)

/* 엄청난 줄의 코드 */

function sum(a, b) {
	return ( a + b );
}
sum(3, 4); // 7
```

만약 코드의 줄이 너무 많아서 sum함수를 중복으로 함수 선언문을 통해 만들었다고 생각해보자.

두 함수는 모두 호이스팅이 되어 위로 올라가서 선언이 될 것이다. 그리고 캐스케이딩 원칙에 의해 나중에 선언된 함수가 최종적으로 sum함수가 될 것이다.

즉, 먼저 선언된 함수의 기능은 사용할 수 없게 되어버린다.

이러한 문제를 해결하기 위해 **함수 선언문보다 함수 표현식의 사용이 권장된다.** 아래와 같이 함수 표현식을 사용한다면 해당 문제를 해결할 수 있다. 함수 표현식은 안전하고 예측가능한 소스를 만드는데 도움을 준다.

```js
var sum = function (a, b) {
	return a + ' + ' + b + ' = ' + ( a + b );
}
sum(1, 2); //  '1 + 2 = 3'

/* 엄청난 줄의 코드 */

var sum = function (a, b) {
	return ( a + b );
}
sum(3, 4); // 7
```

> ES6에서는 이러한 예측 가능성이나 성능 상의 이유로, function이라는 단어를 쓰지않고도 함수를 선언 할 수 있도록  에로우 펑션을 만들었다.

### 2.3. 함수 스코프, 실행 컨텍스트

- Scope : 유효범위 (변수의 유효범위)

- Execution context : 실행되는 코드 덩어리 (추상적 개념)

둘의 가장 큰 차이점은 아래와 같다.

- **스코프는 함수가 정의될 때 경정된다.**

- **실행 컨텍스트는 함수가 샐행 될 때 생성된다.**

실행 컨텍스트에는 호이스팅, this 바인딩(this가 무엇인지 정해주는 것) 등의 정보가 담기게 된다.

코드를 보고 둘의 차이를 알아보자.

아래 코드의 결과를 예측해보자.

```js
var a = 1;
function outer() {
    console.log(a);   // 1st

    function inner() {
        console.log(a)   // 2nd
        var a = 3;
    }

    inner();

    console.log(a);  // 3rd
}

outer();
console.log(a);   //4th
```

> 출력 :
>
> 1
>
> undefined
>
> 1
>
> 1

위 코드를 살펴보자.

먼저 실행 컨텍스트가 생성될 때 **컨텍스트가 생성될 때 this 바인딩과 호이스팅이 생성됨을 유의**하며 아래 과정을 살펴보자.

0. 코드의 시작과 동시에 전역 실행 컨텍스트가 먼저 생성된다. [scope : global]

   >  전역 컨텍스트 시작

   ​	`전역 컨텍스트에 대한 호이스팅 시작`

   1. 변수 a 선언
   2. 함수 outer 선언 [scope  : Global > outer]

   ​	`전역 컨텍스트에 대한 호이스팅 끝`

   3. 변수 a에 1을 할당

   4. outer 함수 호출 => outer 실행 컨텍스트 생성

      > outer 컨텍스트 시작

      `outer 컨텍스트에 대한 호이스팅 시작`

       	5. 함수 inner 선언  [scope  : Global > outer > inner]

      `outer 컨텍스트에 대한 호이스팅 끝`

      6. outer scope에서 먼저 a를 탐색을 하지만 a가 없기 때문에 golobal scope에서 a를 탐색한 후 1을 출력

      7. inner 함수 호출 => inner 실행 컨텍스트 생성

         > inner 컨텍스트 시작

         `inner 컨텍스트에 대한 호이스팅 시작`

         8. 변수 a 선언

         `inner 컨텍스트에 대한 호이스팅 끝`

         9. inner scope에서 a를 탐색하지만, 선언만 이루어져 있는 상태이기 때문에 undefined가 출력된다.
         10. inner scope의 a에 3을 할당

         > inner 컨텍스트 종료

      11. outer scope에서 a 탐색 -> global scope에서 a탐색 -> 1출력

      > outer 컨텍스트 종료

   12. global scope에서 a탐색 -> 1출력

   >  전역 컨텍스트 종료

### 2.4. 메소드(Method)

함수처럼 생겼는데 앞에 `.`이 붙어 있으면 메소드라고 생각하면 된다.

함수와 메소드의 차이는 this 바인딩을 여부이다.

`객체.메소드()`를 하게 되면 컨텍스트가 생성될 때 `this`는 `메소드를 호출한 객체`가 된다.

아래 코드를 살펴보자.

```js
var obj = {
	a: 1,
    b: function bb(){
        console.log(this);
        //{a: 1, b: ƒ, c: ƒ}
    },
    c: function(){
        console.log(this.a)
        //1
    }
};
obj.b();
obj.c();

console.dir(obj.b);
//ƒ bb()
console.dir(obj.c);
//ƒ c()
```

> console.dir은 객체를 출력하여 분석할 때 유용하다. 객체의 메서드를 확인 가능하다.

![image](https://user-images.githubusercontent.com/53181778/88449791-c7202900-ce84-11ea-8a03-6461c5a27819.png)

### 2.5. 콜백 함수 (Callback function)

콜백 함수는 call과 back으로 쪼개서 생각하라 수 있다.

무언가가 함수를 호출한 뒤 언젠가 어떻게든 나에게 돌려줄 것이다. 즉, 콜백함수의 제어권을 어떤 대상에게 넘겨준다는 것을 의미한다.

예시를 통해 살펴보자.

```js
setInterval(function () {
    console.log('1초마다 실행될 겁니다.');
}, 1000);
```

> setInterval은 주기함수로, 일정시간 간격으로 인자로 받은 함수를 호출해준다.
>
> `setInterval(콜백함수, 주기(ms));`
>
> `setInterval`함수는 주기마다 콜백함수를 호출해주는 함수로 정의되어 있다.

위 코드는 1초마다 콜백함수를 실행할 것이다. 즉 콜백함수의 제어권은 SetInterval이 가져가게 되고, 실행결과를 돌려주게 된다.

```js
var cb = function () {
    console.log('1초마다 실행될 겁니다.')
};

setInterval(cb, 1000);
//cb가 콜백함수가 되는 것이다.
```

다른 예시를 살펴보자. (forEach)

```js
var arr = [1, 2, 3, 4, 5];
var entries = [];
arr.forEach(function(v, i) {
    entries.push([i, v, this[i]]);
},[10, 20, 30, 40, 50]);
console.log(entries);
//[[0, 1, 10], [1, 2, 20], [2, 3, 30], [3, 4, 40], [4, 5, 50]]
```

> forEach를 통해 arr배열을 순회하면서 콜백함수를 호출하고 있다. 그리고, this는 [10, 20, 30, 40 , 50]으로 해주도록 하고 있다.
>
> 여기서 콜백함수는 아래 함수이다.
>
> index와 value와 this의 값들을 배열로 만들어 원소로 넣어준다.
>
> ```js
> function(v, i) {
>     entries.push([i, v, this[i]]);
> }
> ```

forEach 메소드에 첫번째 인자로 콜백함수를 넘겨주고, 두번째 인자로 this로 인식할 대상(생략가능)을 넣어준다.

forEach를 직접 구현해보면 이런 형태가 될 것이다.

```js
Array.prototype.forEach = function(callback, thisArg) {
    var self = thisArg || this;
    for(var i = 0; i < this.length; i++){
        callback.call(self, this[i], i, this);
    }
}
```

> self라는 변수에는 thisArg의 값이 있으면 해당 배열을 넣고, 없다면, ForEach를 호출한 배열(this)을 넣는다.
>
> callback함수를 call이라는 메서드를 통해 호출하는데, 함수를 호출한때 `this 바인딩을 self`로 하게되고, `this, this[i], i`는 인자로 전달된다.

위 함수를 보게된다면 콜백을 어떤 타이밍에 어떤 형태로 정의하고, 매개변수로 어떤 순서로 전달할지 정해주는 것까지 전적으로 `forEach라는 메서드가 결정`한다. 즉, forEach가 정해놓은 규칙을 따르게 된다.

다른 예시를 살펴보자. (DOM객체 이벤트 핸들러)

```js
document.body,innterHTML = '<div id="a">abc</div>';
function cbFunc(x){
    console.log(this, x);
}

document.getElementById('a').addEventListener('click', cbFunc);

//출력
//this : <div id="a">abc</div>
//x : MouseEvent 객체
```

> id가 a인 객체를 클릭하면, 콜백함수(cbFunc)가 실행이 된다.

따로 this 바인딩을 해주지 않았지만, addEventListener 메서드 내부에서 this 바인딩을 해준 것이다. 그리고, x도 마찬가지로 addEventListener 에서 자동으로 마우스이벤트 객체를 담아준 것이다.

- 콜백함수의 특성
  - 다른 함수(A)의 매개변수로 콜백 함수(B)를 전달하면, A가 B의 제어권을 갖게 된다.
  - (특별한 요청(bind)가 없는 한) A에 미리 정해진 방식에 따라 B를 호출한다.
    - this에 무엇을 바인딩 할 지,
    - 매개변수는 어떤 값들을 어떤 순서로 가지는지
    - 어떤 타이밍에 콜백을 호출할지

- **주의할 점**

  callback 함수는 `함수`이다!. (`메소드`가 아니다!)

  ```js
  var arr = [1, 2, 3];
  var obj = {
      vals: [1, 2, 3],
      logValues: function(v, i){
          if(this.vals){
              console.log(this.vals, v, i);
          } else {
              console.log(this, v, i);
          }
      }
  };

  obj.logValues(1, 2);
  // [1, 2, 3] 1 2
  arr.forEach(obj.logValues);
  // window {} 1 0
  // window {} 2 1
  // window {} 3 2
  ```

  - obj.logValues(1, 2); 는 this.vals가 존재하기 때문에 `console.log(this.vals, v, i);` 를 잘 출력했다.
  - 다만, `arr.forEach(obj.logValues);` 에서는 forEach로 logValues 메소드가 아닌 매칭된 함수만 전달 된 것이기 때문에, this에는 window 객체가 있게 되어 `console.log(this, v, i);` 코드가 실행된다.

## 3. this

여러 상황에서 this가 무엇을 가르키는지 살펴보자.

- 전역공간에서
  - 전역 객체 : `window` 또는 `global`
- 함수 내부에서
  - 기본적으로 전역 객체 : `window` 또는 `global`
- 메소드 호출시
  - 메소드를 호출하는 주체
- callback에서
  - 기본적으로는 함수내부에서와 동일
- 생성자 함수에서
  - 인스턴스를 가리킨다.

### 3.1 전역공간에서 this

전역공간에서 this는 전역 객체를 의미한다.

즉, 브라우저 console에서는 `window`객체가 되고, node.js에서는 `global` 객체가 된다.

### 3.2. 함수 내부에서 this

**기본적으로** 함수내부에서 this를 사용한다면, 전역 객체를 의미하게 된다.

```js
function a(){
    console.log(this);
}
a();
//전역객체 출력

function b(){
    function c(){
        console.log(this);
    }
    c
}
b();
//전역객체 출력

var d = {
    e: function (){
        function f(){
            console.log(this);
        }
        f();
    }
}
d.e();
//전역객체 출력 (d가 출력되지 않는 것에 유의!)
//실제 출력되는 부분은 f(); 함수를 호출하는 것이기 때문이다.
```

> 위 코드의 모든 this는 전역객체이다.

### 3.3. 메소드 호출 시 this

```js
var a = {
    b: function(){
        console.log(this);
    }
}
a.b();
//a객체가 출력된다.

var a = {
    b: {
        c: function(){
            console.log(this);
        }
    }
}
a.b.c();
//b객체가 출력된다.
```

> 메소드명 바로 앞에있는 객체가 this가 된다.

**앞서 설명함 함수는 `전역객체`의 메소드 라고 생각하는 것이 좋다.** 즉, 앞에 아무것도 존재하지 않는 함수라면 전역객체의 메소드라고 생각하면 된다. window.함수() 에서 window.이 생략되었다고 생각하자. (또는 global.)

- 내부함수에서의 우회법

  ```js
  var a = 10;
  var obj = {
      a: 20,
      b: function(){
          console.log(this.a); //20

          function c(){
              console.log(this.a); //10
          }
          c();
      }
  }
  obj.b();
  ```

  만약 위 코드에서 function c에서 obj.a를 표현하고 싶다면 어떻게 해야할까? 변수를 선언해서 사용하면 된다.

  ```js
  var a = 10;
  var obj = {
      a: 20,
      b: function(){
          var self = this;
          console.log(this.a); //20

          function c(){
              console.log(self.a); //20
          }
          c();
      }
  }
  obj.b();
  ```

  self라는 변수에 this를 담아 obj.a를 c함수에서도 표현 할 수 있다.

### 3.4. callback 함수에서 this

기본적으로는 **함수 내부에서**와 동일하다.

그전에 먼저 call, apply, bind를 살펴보자.

```js
function a(x, y, z){
    console.log(this, x, y, z);
}
var b = {
    c: 'eee';
};

a.call(b, 1, 2, 3);

a.apply(b, [1, 2, 3]);

var c = a.bind(b);
c(1, 2, 3);

var d = a.bind(b, 1, 2);
d(3);
```

출력은 4가지의 경우가 모두 동일하다.

각각의 api 문서를 살펴보면 아래와 같다.

`func.call(thisArg[, arg1,[, arg2[, ...] ] ])`

`func.apply(thisArg, [argsArray])`

`func.bind(thisArg[, arg1,[, arg2[, ...] ] ])`

- thisArg : 모두 가지고 있는 인자로, func가 실행될 때 this를 thisArg로 바인딩 되도록 명시한다.

- call은 두 번째 인자부터 무한의 인자를 줄 수 있다.
- apply는 두 번째 인자에 배열하나를 준다.
- call과 apply는 즉시 호출하는 함수이다.
- bind는 즉시 호출되지 않고, 인자가 저장된 새로운 함수를 생성하여 반환한다. (currying)

이제 다시 콜백함수로 돌아가서 this를 살펴보자.

```js
var callback = function() {
	console.dir(this);
}
var obj = {
    a: 1,
    b: function(cb) {
        cb();
    }
};
obj.b(callback);
```

- obj의 b메서드는 콜백함수를 받아 그대로 실행하는 메서드이다.
- 위의 경우 this는 전역객체가 될 것이다. 이것이 함수 내부에서의 this와 기본적으로 같다는 의미이다.

만약 call,apply,bind로 콜백함수를 이용하여 this를 다른것으로 명시한다면 얘기가 달라진다.

```js
var callback = function() {
	console.dir(this);
}
var obj = {
    a: 1,
    b: function(cb) {
        cb.call(this);
    }
};
obj.b(callback);
```

- 위에서 this는 obj객체가 된다.

setTimeout의 경우 this를 별도로 바인딩하지 않는 함수이기 때문에 아래의 경우 this는 전역객체에 해당한다.

```js
var callback = function() {
	console.dir(this);
};
var obj = {
	a: 1
};
setTimeout(callback, 100);
```

만약, this를 obj로 바꾸고 싶다면 아래와 같이 바꾸어 사용할 수 있다.

```js
var callback = function() {
	console.dir(this);
};
var obj = {
	a: 1
};
setTimeout(callback.bind(obj), 100);
```

this를 obj로 바인딩한 함수를 만들어서 인자로 전달해 준 것이다.

또한 아래와 같이 사용하는 것도 가능하다.

```js
document.body,innterHTML = '<div id="a">abc</div>';

function cbFunc(x){
    console.log(this, x);
}

var obj = {a: 1}

document.getElementById('a').addEventListener('click', cbFunc.bind(obj));

//출력
//this : {a: 1}
//x : MouseEvent 객체
```

콜백함수의 this를 정리를 해보면 아래와 같다.

- 기본적으로 함수의 this와 같다.
- 제어권을 가진 함수가 callback의 this를 명시한 경우 그에 따른다.
- 개발자가 this를 바인딩한 채로 callback을 넘기면 그에 따른다.

### 3.5. 생성자함수에서 this

생성자함수에서의 this는 인스턴스를 가리킨다.

```js
function Person(n, a){
	this.name = n;
	this.age = a;
}
var gomugom =  new Person('고무곰', 30);
console.log(gomugom);
```

## 4. 클로저(Closure)

### 4.1. 클로저의 정의

클로저는 함수와 함수의 **선언**될 당시의 환경 정보의 조합이다.

> lexical environment : 선언 당시의 환경에 대한 저보를 담는 객체(구성 환경)

선언될 당시 환경정보는 Scope와 밀접하게 관련이 있다.

scope는 변수의 유효범위이고, 클로저는 그 유효범위로 인한 상태로 보면된다.

함수 내부에서 생성한 데이터와 그 유효범위로 인해 발생하는 특수한 `현상/상태`라고 볼 수 있다.

closure : 폐쇄성, 닫혀있음 => 클로저에서 내부의 정보를 밖으로 전달하는 방법은 `return`을 이용하는 것 뿐이다.

클로저에서 함수를 리턴한다고 해도, 반환된 함수에서는 scope 및 lexical environments는 변하지 않는다.

클로저를 잘 활용하면, 아래의 이점을 얻을 수 있다.

1. 접근 권한 제어
2. 지역변수 보호
3. 데이터 보존 및 활용

예시로 접근 권한 제어와 지역변수 보호를 살펴보자.

```js
function a() {
    var x = 1;
    function b() {
        console.log(x);
    };
    b();
}
a();
console.log(x); // 에러
```

- 함수 a의 내부에 또 다른 스코프 함수 b가 선언되어 있다.
- x변수에 대해서 a와 b 함수의 스코프에서는 접근할 수 있지만, a의 외부에서는 접근할 수 없다.

위 예제를 조금 수정하면 데이터 보존 및 활용에 쓰일 수 있다.

```js
function a() {
    var x = 1;
    return function b() {
        console.log(x);
    };
}
var c = a();
c();
```

- a에서 b함수를 반환했고,  c에 할당해 주었다.
- c라는 변수를 이용하여 외부에서도 x의 값을 얻을 수 있다.
- 하지만, 외부에서 x의 값을 변경하는 것은 불가능하다.

위 코드에 접근 권한을 제어하기위해 getter와 setter를 만들어보자.

```js
function a() {
    var _x = 1;
    return {
        get x() { return _x; },
        set x(v) { _x = v; }
    };
}
var c = a();
c.x = 10;
console.log(c.x) //10
```

- 이제 외부에서 c.x의 값에 접근 할 수 있다.

###  4.2. 클로저의 활용 : Private member 만들기

자바스크립트에는 태생적으로 private 변수를 제공하지 않지만, 클로저를 이용하여 흉내를 낼 수 있다.

Private member를 만들는 것은 외부로부터의 접근을 제한하기도 하지만 전역스코프의 변수를 최소화하는데 도움이 되기도한다.

게임을 만들어보자.

- 자동차 게임
  - 차량별로 연료량 및 연비는 랜덤
  - 유저별로 차량 하나씩 고르면 게임 시작
  - 각 유저는 자신의 턴에 주사위를 굴려 랜덤하게 나온 숫자만큼 이동
  - 만약 연료가 부족하면 이동 불가
  - 가장 멀리 간 사람이 승리

```js
var car = {
    fuel: 10,  //연료 (l)
    power: 2,  //연비 (km/l)
    total: 0,
    run: function(km){
        var wasteFuel = km / this.power;
        if(this.fule < wasteFuel) {
            console.log('이동 불가');
            return;
        }
        this.fuel -= wasteFuel;
        this.total += km;
    }
};
```

하지만 이렇게 된다면 외부에서 car.power나 car.fule에 접근이 가능해서 값을 변경할 수 있을 것이다.

조금더 안정적인 서비스를 위해서 멤버를 보호할 필요가 있다.

```js
var createCar = function(f, p){
    var fuel= f;  //연료 (l)
    var power= p;  //연비 (km/l)
    var total= 0;
    return {
        run: function(km){
            var wasteFuel = km / power;
            if(fule < wasteFuel) {
                console.log('이동 불가');
                return;
            }
            fuel -= wasteFuel;
            total += km;
        }
    }
};

var car = createCar(10, 2);
```

이런식으로 run이라는 메서드만 외부로 노출시키게 되면 사용자가 임의로 값을 변경하는 것은 불가능해진다.

1. 함수에서 **지역변수 및 내부함수 등을 생성**한다.

2. **외부에 노출시키고자 하는 멤버들로 구성된 객체를 return** 한다.

   => return한 객체에 포함되지 않은 멤버들은 private하다.

   => return한 객체에 포함된 멤버들은 public하다.

> 클로저는 객체지향 뿐만 아니라, 함수형 프로그래밍의 커링에도 개념이 활용된다.
