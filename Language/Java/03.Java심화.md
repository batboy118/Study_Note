# 03. Java 심화

> 자바의 심화된 내용에 대해 학습합니다.

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./README.md)

---

<!-- TOC -->

- 

<!-- /TOC -->

## 1.  클래스패스

```java
class Item{}

class ClasspathDemo {}
```

- 컴파일

```
javac ClasspathDemo.java
```

두 개의 클래스 파일이 생성

- ClasspathDemo.class
- Item.class

즉 클래스 하나는 하나의 클래스 파일

ClasspathDemo2.java을 만들고 내용을 아래와 같이 한다.

```java
class Item2{ 
    public void print(){
        System.out.println("Hello world");  
    }
}


class ClasspathDemo2 {
    public static void main(String[] args){
        Item2 i1 = new Item2();
        i1.print();
    }
}
```

컴파일

```
javac ClasspathDemo2.java
```

그리고 현재 디렉터리 하위에 lib 디렉토리를 만들고 여기에 Item2.class 파일을 이동한다. 현재 디렉터리에는 Item2.class 파일이 없어야 한다. 그리고 ClasspathDemo2를 실행한다.

```
java ClasspathDemo2
```

에러가 발생한다.

이것은 item.class 파일이 현재 디렉터리에 존재하지 않기 때문에 찾을 수 없다는 메시지다. 아래와 같이 실행해서 이 문제를 해결할 수 있다.

```
java -classpath ".;lib" ClasspathDemo2
```

리눅스, OSX와 같은 유닉스 계열의 시스템이라면 아래와 같이 콜론을 사용해야 한다.

```
java -classpath ".:lib" ClasspathDemo2
```

옵션 -classpath는 자바를 실행할 때 사용할 클래스들의 위치를 가상머신에게 알려주는 역할을 한다. -classpath의 값으로 사용된 ".;lib"를 살펴보자.

![img](https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/516/1902.gif)

**.**

현재 디렉터리에서 클래스를 찾는다는 뜻이다.

**;**

경로와 경로를 구분해주는 구분자

**lib**

현재 디렉터리에 없다면 현재 디렉터리의 하위 디렉터리 중 lib에서 클래스를 찾는다는 의미다.

만약 .을 제외한다면 어떻게 될까? 아래와 같은 오류가 발생할 것이다.

```
F:\tmp\java>java -classpath "lib" ClasspathDemo``오류: 기본 클래스 Classpath을(를) 찾거나 로드할 수 없습니다.
```

**환경변수**

디렉터리 lib 아래에 있는 Item.class 파일을 찾았는데 정작 현재 디렉터리에 있는 ClasspathDemo.class 파일은 찾을 수 없기 때문이다.

이와 같이 클래스 패스라는 것은 자바를 실행할 때 클래스의 위치를 지정하는 역할을 하는 것이다. 클래스 패스는 자바 애플리케이션이 사용하고 있는 클래스가 여러 경로에 분산되어 있을 때 유용하게 사용할 수 있는 방법이다.

지금까지는 자바를 실행할 때 클래스 패스를 지정하는 방법을 알아봤다. 실행 할 때마다 클래스 패스를 지정하는 것이 귀찮다면 클래스 패스를 시스템의 환경변수로 지정하면 된다.

환경변수는 운영체제에 지정하는 변수로 자바 가상머신과 같은 애플리케이션들은 환경변수의 값을 참고해서 동작하게 된다. 자바는 클래스 패스로 환경변수 CLASSPATH를 사용하는데 이 값을 지정하면 실행할 때마다 -classpath 옵션을 사용하지 않아도 되기 때문에 편리하다. 하지만 운영체제를 변경하면 클래스 패스가 사라지기 때문에 이식성면에서 불리할 수 있다.

## 2. 컴파일

프로젝트 구조

- 프로젝트 디렉토리
  - bin
  - src

bin은 바이트 코드 ( JVM이 이해할 수 있는 코드 )

src는 사람이 작성한 코드

최상위 프로젝트 디렉토리에서, 

`javac src/컴파일할 패키지의 경로/소스파일이름.java`

또는

`javac src/컴파일할 패키지의 경로/*.java`

를 명령하게 되면 같은 디렉토리에 클래스 파일이 생성된다.

만약, 클래스파일이 bin아래에 생성되게 하고 싶다면?

`javac src/컴파일할 패키지의 경로/*.java -d bin`

-d bin : bin 디렉토리에 결과를 만들라는 의미



> 동일한 클래스명을 가진 패키지들을 로드하고 인스턴스를 생성하면, 어떤 패키지의 클래스를 사용하는지 알지 못하기 때문에 에러가 발생한다.
>
> 그때는 패키지명.클래스 형식으로 사용하여 어떤 패키지의 클래스인지 명확하게 해주면 된다.

## 3. API

자바는 기본으로 여러가지 API가 존재한다.

자바 시스템을 제어하기 위해서 자바에서 제공하는 여러 명령어들을 자바 API라 한다.

JDK를 설치하면 자바시스템을 제어하는 API를 기본으로 제공한다.

패키지 `java.lang.*`의 클래스들도 자바에서 제공하는 API 중의 하나라고 할 수 있다.

> 자바는 자동으로 `java.lang.*`을 로드함.
>
> 명시적으로 `import java.lang.*`을 써도 됨
>
> System 클래스도 java.lang 패키지에 포함되어 있음

**Java SE**(JAVA platform. **S**tandard **E**dition)
예전에는 J2SE로 불리었으나 버전 6.0 이후에 Java SE로 변경. 자바 플랫폼에서 가장 널리 쓰이는 자바 API의 집합체이다.

**Java EE**(Java Platform, **E**nterprise **E**dition)
자바를 이용한 서버측 개발을 위한 플랫폼이다.java EE 플랫폼은 pc에서 동작하는 표준플랫폼인 Java SE에 부가하여,웹 애플리케이션 서버에서 동작하는 장애복구 및 분산 멀티티어를 제공,자바 소프트웨어의 기능을 추가한 서버를 위한 플랫폼이다. 이전 J2EE라고 불리었으나 5.0이후로 Java EE로 개칭

**Java ME**(Java Platform, **Micro** **E**dition)
Java ME 또는 J2ME 등으로 불림 제한된 자원을 가진 휴대전화, PDA, 세트톱박스 등에서 Java프로그래밍 언어를 지원하기 위해 만들어진 플랫폼이다.

각 에디션에 맞춘 공식 문서를 확인해보면 사용가능한 API를 확인 할 수 있다.

## 4. Exception

**ArithmeticException의 상속 구조**

java.lang.Object

- java.lang.Throwable
  - java.lang.Exception
    - java.lang.RuntimeException
      - java.lang.ArithmeticException
        - checked & unchecked 

> **Throwable** 클래스에 속한 메서드
>
> - getMessage()
> - toString()
> - printStackTrace()
> - 등등

Error와 Exception은 각각 Throwable을 상속받는다.

- Error 클래스는 JVM에 문제가 발생했을 경우 발생

  (개발자가 에러를 그냥 처리할 수 없고 환경에 대한 개선(메모리의 증가 등)으로 처리해야함)

- Exception은 코드 로직상의 문제가 발생했을 경우 발생

![Is It a Bad Practice to Catch Throwable? | Baeldung](https://www.baeldung.com/wp-content/uploads/2019/11/Throwable-3.png)

 **checked와 unchecked**

- **ArithmeticException**은 런타임 예외를 상속받고, unchecked 예외이다.
- 그 외 예외는(ex, **IOException**) checked 예외이다.
  - checked 예외는 컴파일시 반드시 처리를 해주어야 한다 (try와 exception, 또는 throws)
- RuntimeException을 상속 받는 사용자 지정 예외를 사용한다면, 컴파일시 예외처리를 해주지 않아도 문제가 되지는 않는다.
- 반면에, Exception을 상속받는 사용자 지정 예외를 만들어서 사용한다면, 예외를 반드시 처리해 주어야 한다.

## 5. Object 클래스

- 모든 클래스의 부모 클래스 (최상위 클래스)

**메서드**

- toString()

  - 객체를 문자화 시킨 것
  - `return getClass() + getName() + "@" + Integer.toHexString(hashCode());`
  - 모든 객체에서 이 함수를 오버라딩해서 다르게 사용 가능

- equals()

  - 원시 데이터를 비교할 때는 `==`을 사용하고, 스트링 같은 참조 데이터를 비교할 때는 equals를 사용한다.

  - 기본적으로 같은 객체가 아니면 false이다.

  - 이것도 오버라이딩해서, 두 객체가 같은 조건을 따로 줄 수 있다.

  - String 클래스의 경우는 문자열이 같다면 같은 것으로 판단되도록 오버라이딩 되어 있다.

  - 오버라이딩 시 주의해야할 점은, 파라미터도 Object형이기 때문에 다형성이 적용되어 있다. 그렇기 때문에 타입 캐스팅을 통해 변환 시켜주어야 한다.

    ```java
    String name;
    
    public boolean equals (Object Obj){
        클래스 c = (클래스) c;
        return this.name == c.name;
    }
    ```

- finalize()

  - 객체가 소멸할 때 동작하는 메서드이다.
  - 만약, 어떤 객체가 소멸할 때 특정 작업을 해야한다면, 이 메서드를 오버라이딩하면 된다.
  - 하지만, 자바의 전문가들은 이 메서드를 사용하는 것을 권장하지 않는다.
  - 가비지 컬렉션에 의해 소멸 되기전에 실행된다.

- clone()

  - 복제를 할 때 사용한다.
  - **`Cloneable`이라는 인터페이스**를 **implements해야 사용가능**하다. (실제로 Cloneable이라는 인터페이스는 아무 내용도 없지만, JVM 에게 이 클래스는 클론이 가능하다는 것을 알려주는 구분자의 역할을 해준다.)
  - clone()은 protected 접근제어자로 선언되어 있다. 그렇게 때문에 public 접근 제어 지시자를 이용하여, 오버라이드 해야한다.
  - 그리고 super.clone()을 넣어준다.
  - 하지만, 예외를 처리해 주어야한다. ( checked 예외를 super.clone에서 에러를 던짐)
  - 같은 주소값을 가지지는 않고, `==`과 equals 도 false로 나온다.

- hashCode() 

## 6. 가비지 컬렉션

- C나 C++과 같은 언어에서는 메모리를 관리할 수 있는 함수를 제공하지만, 자바에서는 극히 제한적이다.
- 그 이유는, 가비지 컬렉션에서 대부분의 메모리 관리를 자동으로 해주기 때문이다.

## 7. 제네릭

- 제네릭(Generic)은 클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법
- 타입만 다르고, 동일한 동작을 하는 클래스가 있을 때 사용하면 유용하다.

```java
class Person<T>{
    public T info;
}

public class GenericDemo {

    public static void main(String[] args) {
        Person<String> p1 = new Person<String>();
        Person<StringBuilder> p2 = new Person<StringBuilder>();
    }

}
```

- p1.info : String
- p2.info : StringBuilder

데이터 타입을 Object로 제너럴하게 주어 여러가지 타입을 허용할 수 있겠지만, 실제 변수에 담긴 데이터를 다른곳에 넣을 때 런타임 에러가 발생한다. 하지만 제네릭을 사용하면 컴파일시 에러를 잡을 수 있다.

```java
class StudentInfo{
    public int grade;
    StudentInfo(int grade){ this.grade = grade; }
}
class EmployeeInfo{
    public int rank;
    EmployeeInfo(int rank){ this.rank = rank; }
}
class Person{
    public Object info;
    Person(Object info){ this.info = info; }
}
public class GenericDemo {
    public static void main(String[] args) {
        Person p1 = new Person("부장");
        EmployeeInfo ei = (EmployeeInfo)p1.info;
        System.out.println(ei.rank);
    }
}
```

- 위 코드는 컴파일 되지만, 런타임 에러가 발생한다.
- 클래스 Person의 생성자는 매개변수 info의 데이터 타입이 Object이다. 따라서 모든 객체가 될 수 있다. 그렇기 때문에 위와 EmployeeInfo의 객체가 아니라 String이 와도 컴파일 에러가 발생하지 않는다. 대신 런타임 에러가 발생한다. 
- 위와 같은 에러를 타입에 대해서 안전하지 않다고 한다. 즉 모든 타입이 올 수 있기 때문에 타입을 엄격하게 제한 할 수 없게 되는 것이다. 

위 코드를 제네릭을 사용하여변경해보자.

```java
class StudentInfo{
    public int grade;
    StudentInfo(int grade){ this.grade = grade; }
}
class EmployeeInfo{
    public int rank;
    EmployeeInfo(int rank){ this.rank = rank; }
}
class Person<T>{
    public T info;
    Person(T info){ this.info = info; }
}
public class GenericDemo {
    public static void main(String[] args) {
        Person<EmployeeInfo> p1 = new Person<EmployeeInfo>(new EmployeeInfo(1));
        EmployeeInfo ei1 = p1.info;
        System.out.println(ei1.rank); // 성공

        Person<String> p2 = new Person<String>("부장");
        String ei2 = p2.info;
        System.out.println(ei2.rank); // 컴파일 실패
    }
}
```

- 다른 타입의 클래스를 사용하면 컴파일 에러가 발생하는 것을 확인할 수 있다.
- 즉, **컴파일시 타입을 체크**하게 된다.

여러가지 타입의 제네릭도 사용이 가능하다.

```java
class EmployeeInfo{
    public int rank;
    EmployeeInfo(int rank){ this.rank = rank; }
}
class Person<T, S>{
    public T info;
    public S id;
    Person(T info, S id){ 
        this.info = info; 
        this.id = id;
    }
}
public class GenericDemo {
    public static void main(String[] args) {
        Person<EmployeeInfo, int> p1 = new Person<EmployeeInfo, int>(new EmployeeInfo(1), 1);
    }
}
```

- 하지만, 위코드는 컴파일 에러가 발생한다.
- 그 이유는 제네릭의 타입으로는 `참조형` 데이터 타입만 올 수 있기 때문이다.

**래퍼클래스**

- 기본형 자료형을 감싸는 클래스
- Integer, Double 등

```java
class EmployeeInfo{
    public int rank;
    EmployeeInfo(int rank){ this.rank = rank; }
}
class Person<T, S>{
    public T info;
    public S id;
    Person(T info, S id){ 
        this.info = info; 
        this.id = id;
    }
}
public class GenericDemo {
    public static void main(String[] args) {
        Integer id = new Integer(1);
        Person<EmployeeInfo, Integer> p1 = new Person<EmployeeInfo, Integer>(new EmployeeInfo(1), id);
    }
}
```

- new Integer(1); 로 인스턴스형식를 만들어 주어야 한다.
- id.intValue(); 를 이용해서 원시 타입으로 변경할 수 있다.

**만약, 생성자에서 타입을 명시적으로 주고 있다면, 제네릭형식을 생략할 수 있다.**

```java
class EmployeeInfo{
    public int rank;
    EmployeeInfo(int rank){ this.rank = rank; }
}
class Person<T, S>{
    public T info;
    public S id;
    Person(T info, S id){ 
        this.info = info; 
        this.id = id;
    }
}
public class GenericDemo {
    public static void main(String[] args) {
        Integer id = new Integer(1);
        EmployeeInfo e = new EmployeeInfo(1);
        Person p1 = new Person(e, id);
    }
}
```

- 위 코드에서 생성자에서 T와 S가 명시적으로 되어있고, p1이 생성될때, e와 id의 타입인 EmployeeInfo, Integer가 각각 T와 S임을 유추할 수 있기 때문에 생략이 가능하다. 

**제네릭은 클래스 이외에 메서드에서도 사용가능하다.**

```java
public <U> void printInfo(U info){
    System.out.println(info);
}

//호출하는 법
<Integer>printInfo(new Integer(1));

//위에서 U의 타입이 유추 가능하므로 아래처럼 호출도 가능하다.
printInfo(new Integer(1));

```

**제네릭의 제한**

- extends 키워드

  특정 클래스나 인터페이스를 상속받은 자료형만 사용이 가능한 제네릭

  ```java
  abstract class Info{
      public abstract int getLevel();
  }
  class EmployeeInfo extends Info{
      public int rank;
      EmployeeInfo(int rank){ this.rank = rank; }
      public int getLevel(){
          return this.rank;
      }
  }
  class Person<T extends Info>{
      public T info;
      Person(T info){ this.info = info; }
  }
  public class GenericDemo {
      public static void main(String[] args) {
          Person p1 = new Person(new EmployeeInfo(1));
          Person<String> p2 = new Person<String>("부장");
      }
  }
  ```

  인터페이스라고 implements를 사용하지 않는다는 것의 주의!

    ```java
  interface Info{
      int getLevel();
  }
  class EmployeeInfo implements Info{
      public int rank;
      EmployeeInfo(int rank){ this.rank = rank; }
      public int getLevel(){
          return this.rank;
      }
  }
  class Person<T extends Info>{
      public T info;
      Person(T info){ this.info = info; }
  }
  public class GenericDemo {
      public static void main(String[] args) {
          Person p1 = new Person(new EmployeeInfo(1));
          Person<String> p2 = new Person<String>("부장");
      }
  }
    ```
  
  - 위에서는 interface를 사용했지만, extends를 사용함.
  - 그냥 부모 자식관의 관계를 명시해주기 위해 사용하는 키워드라고 생각하면 될듯
  
  이때, 제네릭은 부모에 있는 클래스에 선언된 메서드들만 접근이 가능하다.
  
  ```java
  interface Info{
      int getLevel();
  }
  class EmployeeInfo implements Info{
      public int rank;
      EmployeeInfo(int rank){ this.rank = rank; }
      public int getLevel(){
          return this.rank;
      }
  }
  class Person<T extends Object>{
      public T info;
      Person(T info){ 
          this.info = info; 
          info.getLevel(); // 컴파일 에러
      }
  }
  public class GenericDemo {
      public static void main(String[] args) {
          Person p1 = new Person(new EmployeeInfo(1));
          Person<String> p2 = new Person<String>("부장");
      }
  }
  ```
  
  - Object를 상속받는 메서드들만 생성이 가능하며, 이때, T에서는 부모에 있는 Object에 있는 메서드만을 사용할 수 있게 된다.

## 8. Collections framework

- 컬렉션 프레임워크의 종류는 여러가지가 있다.

  - ArrayList, List, Set, Queue, Map 등.

- 이는 또, Collection과 Map으로 구분된다.

  ![Java Collections - List, Map, Set, Tree, Stack, Queue](https://daddyprogrammer.org/wp-content/uploads/2019/04/Java-Collections.png)

- Collection 아래에는 List, Set, Queue가 있고, 또 각 하위에 다른 것들이 있다.

- Map하위에도 다른 것들이 있다.

## 8. ArrayList

- 가장 많이 쓰이는 colleciton

- `import java.util.ArrayList;`

```java
import java.util.ArrayList;

public class ArrayListDemo {

    public static void main(String[] args) {
        String[] arrayObj = new String[2];
        arrayObj[0] = "one";
        arrayObj[1] = "two";
        // arrayObj[2] = "three"; 오류가 발생한다.
        for(int i=0; i<arrayObj.length; i++){
            System.out.println(arrayObj[i]);
        }

        ArrayList al = new ArrayList();
        al.add("one");
        al.add("two");
        al.add("three");
        for(int i=0; i<al.size(); i++){
            System.out.println(al.get(i));
        }
    }

}
```

- **add** 메서드로 데이터를 추가할 수 있다.
- **get** 메서드로 데이터를 읽어 올 수 있다.

만약 특정 데이터 타입에 담으려면, 강제 타입캐스팅 또는 제네릭을 사용해야함. 

기본적으로 ArrayList를 생성할 때 제네릭으로 타입을 명시해주지 않으면, Object 타입으로 되어 있기 때문에

```java
ArrayList<String> al = new ArrayList<String>();  //제네릭사용
al.add("one");
al.add("two");
al.add("three");
for(int i=0; i<al.size(); i++){
    String val = al.get(i); // 이처럼 특정 데이터 타입에 담기 위해서는 제네릭 또는 타입캐스팅을 사용해야함
    System.out.println(val);
}
```

## 9.Set

- Set은 **중복 데이터를 허용하지 않는다**.
- **HashSet**, **LinkedHashSet**, **TreeSet**
- Set 메서드
  - **A.add(값);**   :  값을 추가한다.
  - **A.remove(값);**   : 값을 삭제한다.
  - **A.containsAll(B);**   : B는 A의 부분집합인지 판단 (true, false)
  - **A.addAll(B);**   : A에 B 집합을 모두 추가한다. (합집합)
  - **A.removeAll(B);**   : A에서 B 집합을 모두 뺀다. (차집합)
  - **A.retainAll(B);**   : A와 B모두 에 있는 값만 A에 담는다. (교집합)

## 10. Collection interface

![Java Collections Framework | Java Web Tutor](https://www.javawebtutor.com/images/java/Java-Collection-Framework.png)

![img](https://prashantgaurav1.files.wordpress.com/2013/12/java-util-collection.gif)

https://prashantgaurav1.files.wordpress.com/2013/12/java-util-collection.gif

## 11. 이터레이터

모든 collection에는 이터레이터가 존재한다.

```java
import java.util.ArrayList;
import java.util.HashSet;
 
import java.util.Iterator;
 
public class SetDemo {
 
    public static void main(String[] args) {
        HashSet<Integer> A = new HashSet<Integer>();
        A.add(1);
        A.add(2);
        A.add(3);
         
        HashSet<Integer> B = new HashSet<Integer>();
        B.add(3);
        B.add(4);
        B.add(5);
         
        HashSet<Integer> C = new HashSet<Integer>();
        C.add(1);
        C.add(2);
         
        System.out.println(A.containsAll(B)); // false
        System.out.println(A.containsAll(C)); // true
         
        //A.addAll(B);
        //A.retainAll(B);
        //A.removeAll(B);
         
        Iterator hi = A.iterator();
        while(hi.hasNext()){
            System.out.println(hi.next());
        }
    }
 
}
```

- 이터레이터는 인터페이스이다.
- 이터레이터 메서드를 이용해 이터레이터를 리턴받을 수 있다.
  - `Iterator hi = A.iterator();`
- 메서드는 3가지가 있다
  - hasNext();
  - next();
  - remove();

## 12. Map

- Key : Value 형식의 데이터

- 키의 중복은 허용되지 않음

  ```java
  import java.util.*;
  
  public class MapDemo {
  
      public static void main(String[] args) {
          HashMap<String, Integer> a = new HashMap<String, Integer>();
          a.put("one", 1);
          a.put("two", 2);
          a.put("three", 3);
          a.put("four", 4);
          System.out.println(a.get("one"));
          System.out.println(a.get("two"));
          System.out.println(a.get("three"));
  
          iteratorUsingForEach(a);
          iteratorUsingIterator(a);
      }
  }
  
  ```

  - 제네릭에 두개의 타입을 주어야 함 <키, 밸류>
  - 메서드
    - M.put(키, 밸류);
    - M.get(키);

- Map인터페이스에는 `entrySet()`이라는 메서드가 정의 되어 있다.

  - 이는, Map 데이터를 Set 형식으로 저장하게 해준다.
  - Map자체에는 이터레이터 기능이 없지만, 이를 활용하여 이터레이터를 사용할 수 있게됨
  - Set에 저장되는 데이터 타입은 `Map.Entry<키자료형, 밸류자료형>`으로 이 데이터 타입은 getKey()와 getValue()의 메서드를 가진다. 

  ```java
  package org.opentutorials.javatutorials.collection;
   
  import java.util.*;
   
  public class MapDemo {
   
      public static void main(String[] args) {
          HashMap<String, Integer> a = new HashMap<String, Integer>();
          a.put("one", 1);
          a.put("two", 2);
          a.put("three", 3);
          a.put("four", 4);
          System.out.println(a.get("one"));
          System.out.println(a.get("two"));
          System.out.println(a.get("three"));
           
          iteratorUsingForEach(a);
          iteratorUsingIterator(a);
      }
       
      static void iteratorUsingForEach(HashMap map){
          Set<Map.Entry<String, Integer>> entries = map.entrySet();
          for (Map.Entry<String, Integer> entry : entries) {
              System.out.println(entry.getKey() + " : " + entry.getValue());
          }
      }
       
      static void iteratorUsingIterator(HashMap map){
          Set<Map.Entry<String, Integer>> entries = map.entrySet();
          Iterator<Map.Entry<String, Integer>> i = entries.iterator();
          while(i.hasNext()){
              Map.Entry<String, Integer> entry = i.next();
              System.out.println(entry.getKey()+" : "+entry.getValue());
          }
      }
   
  }
  ```


## 13. 정렬

- **Collections**라는 클래스에 **sort**가 존재함
- sort 메서드를 사용하려면, **Comparable**라는 인터페이스를 **implements** 해야한다.

- 그리고, **Comparable**인터페이스는 **compareTo** 메서드를 가지고 있기 때문에, 사용하기 위해서는 반드시 해당 메서드를 정의해 주어야 한다.

  ```java
  import java.util.*;
  
  class Computer implements Comparable{
      int serial;
      String owner;
      Computer(int serial, String owner){
          this.serial = serial;
          this.owner = owner;
      }
      public int compareTo(Object o) {
          return this.serial - ((Computer)o).serial; // 오른차순 (타입 캐스팅을 해주어야 함)
      }
      public String toString(){
          return serial+" "+owner;
      }
  }
  
  public class CollectionsDemo {
  
      public static void main(String[] args) {
          List<Computer> computers = new ArrayList<Computer>();
          computers.add(new Computer(500, "egoing"));
          computers.add(new Computer(200, "leezche"));
          computers.add(new Computer(3233, "graphittie"));
          Iterator i = computers.iterator();
          System.out.println("before");
          while(i.hasNext()){
              System.out.println(i.next());
          }
          Collections.sort(computers); // sort
          System.out.println("\nafter");
          i = computers.iterator();
          while(i.hasNext()){
              System.out.println(i.next());
          }
      }
  
  }
  ```

  