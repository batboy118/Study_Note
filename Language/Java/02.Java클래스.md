# 02. Java 클래스

> 자바의 클래스에 대해 학습

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./README.md)

---

<!-- TOC -->

- [1. 클래스 선언](#1-클래스-선언)
- [2. 인스턴스 생성](#2-인스턴스-생성)
- [3. 필드(field)](#3-필드field)
- [4. 메소드(Method)](#4-메소드method)
- [5. String 클래스](#5-string-클래스)
    - [5.1. String 메서드](#51-string-메서드)
- [6. 변수의 scope와 static](#6-변수의-scope와-static)
    - [6.1. 변수의 스코프](#61-변수의-스코프)
    - [6.2. main메소드에서 사용하기](#62-main메소드에서-사용하기)
    - [6.3. static](#63-static)
- [7. 열겨헝(enum)](#7-열겨헝enum)
- [8. 생성자](#8-생성자)
- [9. this 키워드](#9-this-키워드)
- [10. 메소드 오버로딩](#10-메소드-오버로딩)
- [11. 생성자 오버로딩과 this](#11-생성자-오버로딩과-this)
- [12. 패키지](#12-패키지)
- [13. 상속](#13-상속)
- [14. 접근 제한자(제어자)](#14-접근-제한자제어자)
- [15. 추상클래스](#15-추상클래스)
- [16. super와 부모 생성자](#16-super와-부모-생성자)
- [17. 오버라이딩](#17-오버라이딩)
- [18. 클래스 형변환](#18-클래스-형변환)
- [19. 인터페이스](#19-인터페이스)
- [20. 인터페이스의 default method](#20-인터페이스의-default-method)
- [21. 내부 클래스](#21-내부-클래스)
- [22. Exception](#22-exception)
- [23. throws](#23-throws)
- [24. 강제로 예외 발생 시키기](#24-강제로-예외-발생-시키기)
- [25. 사용자 정의 Exception (상속)](#25-사용자-정의-exception-상속)

<!-- /TOC -->

## 1. 클래스 선언

```java
public class Car{

}
```

> (접근제어자) class 클래스 이름 { 멤버변수, 메서드 }

자바에서는 import나 package선언 외의 모든 코드는 클래스 내부에 선언 되어야 한다.

public class인 경우는 파일과 클래스 이름을 같이해야 한다.

하나의 파일에 여러개의 클래스가 존재할 수 있지만 **public 클래스는 반드시 하나**만 존재한다.

## 2. 인스턴스 생성

```java
Car 변수 = new Car();
```

- 변수는 스택 영역에, Car 인스턴스는 힙영역에 생긴다.
  - 즉 스택영역의 변수가 힙영역의 인스턴스를 가리키고 있는 형태
  - 가바지 컬렉터가 알아서 힙영역의 메모리를 관리해준다.
  - 참조 변수를 출력해보면 **인스턴스의 주소**(참조 값), 즉 해시코드같이 출력된다. `클래스 이름@주소값(해시코드)`

## 3. 필드(field)

```java
public class Car{
    String name;
    int number;
}
```

- 클래스가 가지고 있는 속성을 필드라한다.
- 또는 멤버변수, 속성(property), 특성(attribute) 이라 한다.

## 4. 메소드(Method)

- 메소드 종류

  - main 메소드
  - 사용자 정의 메소드 (main 이외의 모든 메소드)
- main 메서드
  - 프로그램을 시작하는 함수
    - JVM이 프로그램을 시작하기 위해 호출하는 함수
  - 클래스 내부에 만들지만, 클래스의 메서드는 아님
  - 클래스를 테스트 하기 위해서는 main함수가 필요하다.
    - 이때 main은 테스트할 클래스 자체에 존재해도 되고, 별도의 테스트 클래스를 만들어 그 안에 main을 넣고 테스트할 클래스를 main함수안에서 테스트 하면 된다.
      - 다만, 테스트 클래스와 테스트할 클래스가 같은 패키지에 존재하지 않는 경우 (같은 디렉토리가 아닌경우) 따로 import 헤주어야 한다.
- 클래스의 행동(함수)를 의미

```java
public 리턴타입(파라미터){

}
```

- 예시

```java
public class MyClass{

    public void method(){
        System.out.println("method1이 실행됩니다.");
    }

    public void method1(){
        System.out.println("method1이 실행됩니다.");
    }

    public void method2(int x){
        System.out.println(x + " 를 이용하는 method2입니다.");
    }

    public int method3(){
        System.out.println("method3이 실행됩니다.");
        return 10;
    }

    public void method4(int x, int y){
        System.out.println(x + "," + y + " 를 이용하는 method4입니다.");
    }

}
```

## 5. String 클래스

```java
String str1 = "hello";
String str2 = new String("hello");
```

- String 클래스는 특별하게 new 연산자 없이 인스턴스를 생성할 수 있다.

- 생성방식에 따른 차이점이 존재한다.

  - `String str1 = "hello";`의 경우 스트링은 메모리 상의 **상수들이 저장되는 영역(상수 풀)에 저장**된다.

    만약, `String str3 = "hello;"`와 같이 같은 스트링을 또 선언한다면, **같은 인스턴스를 참조**하게 된다.

  - `String str2 = new String("hello");`처럼 **new 연산자를 만들게 되면, 새로운 인스턴스**를 만들어 낸다.(힙 영역) 같은 인스턴스를 참조하지 않는다.

- **스트링은 불변**의 값이다. 값을 변경하고 싶으면 새로운 스트링을 만들어 주어야 한다.

- `str1 == str2`은 같은 참조를 가지는지 확인, `str1.equals(str2)`는 같은 값을 가지는지 확인

- 스트링에서 기본자료형으로의 형변환

  ```java
  int iVal = Integer.ValueOf(str);
  int dVal = Double.ValueOf(str);
  int chVal = str.charAt(0); // 0번째 문자
  ```

> **StringBuffer** & **StringBuilder** 클래스 활용
>
> 스트링을 활용할 때 빈번히 스트링을 변경해야 할 경우가 있다.
>
> 일반 String 클래스는 스트링이 변경될 때 마다 새로운 인스턴스를 생성하기 때문에 메모리 낭비가 심하다.
>
> 그럴 때 **String Buffer**와 **StringBuilder** 클래스를 활용한다.
>
> 이 두 클래스는 내부적으로 final char[] 변수가 아닌 char[]변수를 가지고 있다.
>
> 차이점 : 여러 작업(스레드)가 동시에 문자열을 변경하려 할 때 문자열이 안전하게 변경되도록 보장해주는지의 차이가 있음
>
> - Stringbuffer
>   - 문자열이 안전하게 변경되는 것을 보장 (멀티스레드 프로그램에 적합)
>   - 속도가 조금 느림
> - StringBuilder
>   - 문자열이 안전하게 변경되는 것을 보장하지 않음 
>   - 속도가 더 빠름
>
> StringBuilder 사용법
>
> - 먼저 String 클래스의 인스턴스를 이용해, StringBuilder 인스턴스를 만들고, 조작 후, toString()메서드로 스트링 클래스에 넣어 준다.

### 5.1. String 메서드

- str.length();

- `Strint ss = str.split("구분자");`

  - 어레이 리턴

- concat

  - str.concat(world) 메소드는 str 이 참조하는 문자열 hello 에다가 메소드의 인자로 들어온 문자열 world 를 붙혀서 String 타입으로 리턴하는 메소드다.
  - String Class는 불변 클래스로, 메소드가 수행되면, 새로운 문자열을 만든다. 그러므로, 원래 클래스는 변하지 않는다.

  ```java
  String str = new String("hello");

  System.out.println(str.concat(" world"));  //출력결과는 hello world
  System.out.println(str);  //출력결과는 hello
  ```

- substring

  - str.subString(1,3) 은 str이 참조하는 문자열을 인덱스 1번부터 3번까지 자른 결과이다.
  - str.subString(2) 은 str이 참조하는 문자열을 2번 인덱스부터 마지막까지 자른 결과를 의미한다.
  - 문자열의 인덱스는 0번 부터 시작한다.

  ```java
  System.out.println(str.substring(1, 3)); //출력결과  el
  System.out.println(str.substring(2));   //출력결과 llo world
  ```

## 6. 변수의 scope와 static

### 6.1. 변수의 스코프

- 클래스의 속성으로 선언된 변수 globalScope 의 사용 범위는 클래스 전체 이다.
- 매개변수로 선언된 int value 는 블럭 바깥에 존재하기는 하지만, 메서드 선언부에 존재하므로 사용범위는 해당 메소드 블럭내이다.
- 메소드 블럭내에서 선언된 localScope 변수의 사용범위는 메소드 블럭내이다.

```java
public class ValableScopeExam{

    int globalScope = 10;   // 인스턴스 변수

    public void scopeTest(int value){
        int localScope = 10;
        System.out.println(globalScope);
        System.out.println(localScpe);
        System.out.println(value);
    }
}
```

### 6.2. main메소드에서 사용하기

- 같은 클래스 안에 있는데 globalScope 변수를 사용 할 수 없다.
- main은 static한 메소드이다. **static한 메서드에서는 static 하지 않은 필드를 사용 할 수 없다.**

```java
public class VariableScopeExam {
    int globalScope = 10;

    public void scopeTest(int value){
        int localScope = 20;
        System.out.println(globalScope);
        System.out.println(localScope);
        System.out.println(value);
    }
    public static void main(String[] args) {
        System.out.println(globalScope);  //오류
        System.out.println(localScope);   //오류
        System.out.println(value);        //오류
    }
}
```

### 6.3. static

- 클래스의 인스턴스를 생성할 때 만들어지는 것이 아니라, 클래스의 선언시(프로그램이 시작할 때) 데이터 영역에 static 변수가 저장된다.

- main 메소드는 static 이라는 키워드로 메소드가 정의되어 있다. 이런 메서드를 static 한 메소드 라고 한다.
- static한 필드(필드 앞에 static 키워드를 붙힘)나, static한 메소드는 **Class가 인스턴스화 되지 않아도 사용할 수 있다.**

```java
public class VariableScopeExam {
    int globalScope = 10;
    static int staticVal = 7;

    public void scopeTest(int value){
        int localScope = 20;
    }

    public static void main(String[] args) {
        System.out.println(staticVal);      //스태틱 필드는 사용가능
    }

}
```

**static한 변수는 공유된다.**

- static하게 선언된 변수는 값을 저장할 수 있는 공간이 하나만 생성된다. 그러므로, 인스턴스가 여러개 생성되도 static한 변수는 하나다.
  - 데이터 영역에 저장되고, 인스턴스들은 모두 같은 메모리 주소를 가리키고 있음

```java
public static void main(String[] args) {
    ValableScopeExam v1 = new ValableScopeExam();
    ValableScopeExam v2 = new ValableScopeExam();
    v1.golbalScope = 20;
    v2.golbalScope = 30;

    System.out.println(v1.golbalScope);  //20 이 출력된다.
    System.out.println(v2.golbalScope);  //30이 출력된다.

    v1.staticVal = 10;
    v2.staticVal = 20;

    System.out.println(v1.statVal);  //20 이 출력된다.
    System.out.println(v2.statVal);  //20 이 출력된다.
}
```

- **golbalScope**같은 변수(필드)는 인스턴스가 생성될때 생성되기때문에 **인스턴스 변수**라고 한다.
- **staticVal**같은 static한 필드를 **클래스 변수**라고 한다.
- **staticVal**같은 클래스 변수는 **레퍼런스.변수명 하고 사용하기 보다는 `클래스명.변수명 `으로 사용하는것이 더 바람직**하다고 하다.
  - `VariableScopeExam.staticVal`

> **static 메서드(클래스 메서드)에서는 인스턴스 멤버에 접근이 불가**능하다.
>
> **인스턴스 메서드에서는 스태틱 멤버에 접근이 가능**하다.

- private static 변수를 외부 클래스에서 접근하고 싶다면, public static getter, setter를 이용하는 것이 좋다.

| 유형                     | 선언 위치                                   | 사용 범위                                                    | 메모리      | 생성과 소멸                  |
| ------------------------ | ------------------------------------------- | ------------------------------------------------------------ | ----------- | ---------------------------- |
| 지역 변수(로컬 변수)     | 함수 내부                                   | 함수 내부에서만 사용                                         | 스택        | 함수 호출, 함수 반환         |
| 멤버 변수(인스턴스 변수) | 클래스 멤버 변수                            | 클래스 내부에서만 사용, private가 아니라면 참조 변수로 다른 클래스에서 사용 | 힙          | 인스턴스 생성, 가비지 컬렉터 |
| static 변수(클래스 변수) | static 예약어를 사용하여 클래스 내부에 선언 | 클래스 내부에서 사용하고, private가 아니라면 클래스 이름으로 다른 클래스에서 사용 가능 | 데이터 영역 | 프로그램 시작, 프로그램 끝   |



## 7. 열겨헝(enum)

- 열거형은 JDK5에서 추가되었다.
- enum도 클래스의 일종이다.
- 하지만, 더 간편하게 사용할 수 있다.
- 상속은 불가능하다.
- JDK5 이전에는 상수를 열거형 대신 사용
  - 상수를 이용하는 방법

```java
public class EnumExam {
    public static final String MALE = "MALE";
    public static final String FEMALE = "FEMALE";

    public static void main(String[] args) {
        String gender1;

        gender1 = EnumExam.MALE;
        gender1 = EnumExam.FEMALE;
    }
}
```

**상수를 사용했때의 문제점**

- String으로 선언된 gender1 에는 MALE,FEMALE 둘 중 한가지 값을 갖기 원하는데, gender1의 type이 String 이기 때문에 gender1 = "소년"; 이렇게 수행 되어도 전혀 문제가 되지 않는다.
- 다른 카테고리에서, 같은 이름의 상수를 사용할 수 있는데, 그때 중복으로 선언이 안될 수 있다.(과일 APPLE, 기업 APPLE)
- interface를 이용해서, FRUIT.APPLE와 COMPANY.APPLE로 구분하게 될 수 있지만, 그 둘은 다른 값인데 `==`와 같은 비교연산자를 사용할 수 있게 된다.
- Class를 static 변수를 만든다면, `==`와 같은 연산자를 컴파일 시간에 잡아준다. 하지만, switch 문에서 사용이 불가능하다. (switch문의 데이터 타입은 원시, enum, String 만 허용)
- 실행할때 원했던 값인 MALE,FEMALE 이 아닌 다른 값이 들어오게 되므로 문제를 발생시킬 수 있다.

**해결 방법**

- 열거형 사용 방법

```java
public class EnumExam {
    public static void main(String[] args) {
        Gender gender2;

        gender2 = Gender.MALE;
        gender2 = Gender.FEMALE;
        //Gender타입의 변수에는 MALE이나 FEMALE만 대입이 가능. 다른 값은 저장할 수가 없다.
    }
}

//정의
enum Gender{
    MALE, FEMALE;
}

//위 코드는 아래 코드와 같은 의미를 가진다. (switch 문에서 안되는 것 빼고)
class Gender{
    public static final Gender MALE = new Gender();
    public static final Gender FEMALE = new Gender();
}

//그렇기 때문에 enum 안에서 있는 상수 취급되는 변수의 수 만큼 생성자가 실행되는 것과 같다.(인스턴스화)
//아래처럼 생성자를 만들게 되면, 호출이 두번 출력되는 것을 확인할 수 있다.
//그리고 인스턴스 변수(퍼블릭 변수)를 사용할 수 있고, 초기화도 가능하다.
//퍼블릭 메서드도 사용가능하다.
enum Gender{
    MALE("남자"), FEMALE("여자");
    public String Korean;
    Gender(String korean){
        System.out.println("호출" + this);
        this.Korean = Korean;
    }
}

//아래처럼 사용도 가능하다. 배열처럼 활용
for(Gender g : Gender.values()){
    Systemp.out.println(g);
}
//결과
MALE
FEMALE

// enum을 스위치문에서 활용할 때 case에서는 Gender.MALE 같은 방식이 아닌, MALE로 사용한다.
Gender g = Gender.MALE;
switch(g){
    case MALE:
        System.out.println("MALE")
        break;
    case FEMALE:
        System.out.println("FEMALE")
        break;
}
```

**특정 값만 가져야 한다면 열거형을 사용하는 것이 좋다.**

## 8. 생성자

```java
Public class 클래스명{
    타입 필드명;

    //생성자
    public 클래스명(매개변수 목록){
        ...
    }

    public 리턴타입 메소드명 (매개변수 목록){

    }
}
```

**생성자의 특징**

- 생성자는 **리턴타입이 없다.**
- 생성자가 없다면, **기본 생성자가 컴파일 시 만들어진다.**
- 매개변수가 없는 생성자를 기본생성자라고 한다.
- **생성자가 하나라도 존재한다면, 기본 생성자는 만들어지지 않는다.**

**생성자의 역할**

- 생성자가 하는 일은 객체가 될 때 **필드를 초기화** 하는 역할을 수행한다.
- 자동차가 객체가 될때 반드시 이름을 가지도록 하려면, Car클래스를 다음과 같이 만들어야 한다.

```java
public class Car{
    String name;
    int number;

    public Car(String n){
        name = n;
    }
}
```

- 위의 Car 클래스를 이용하여 Car 인스턴스를 생성하는 방법

```java
public class CarExam2{
    public static void main(String args[]){

        Car c1 = new Car("소방차");
        Car c2 = new Car("구급차");
        //Car c3 = new Car(); // 컴파일 오류가 발생합니다.

        System.out.println(c1.name);

        System.out.println(c2.name);
    }
}
```

- Car클래스는 기본 생성자를 가지지 않는다. 그래서 기본생성자로 Car 객체를 생성할 수 없다.

> 멤버 초기화 vs block 초기화 vs 생성자
>
> - block 초기화는 로직을 넣을 수 있으며, static 변수(클래스 변수)의 경우 주로 사용
> - 생성자는 인스턴스 변수 초기화에 주로 사용

## 9. this 키워드

this는 현재 객체(인스턴스), 자기 자신을 나타낸다.

```java
public class Car{
    String name;
    int number;

    public Car(String n){
        name = n;
    }
}
```

- Car클래스의 생성자 매개변수의 이름이 n 이다. n 이라는 변수명은 무엇을 의미하는지 쉽게 알수 없다.

```java
public Car(String name){
    name = name;
}
```

- 'name=name' 이라고 코드를 바꾸면, 가깝게 선언된 변수를 우선 사용하기 때문에 'name=name'이라는 코드는 매개변수의 name의 값을 매개변수 name에 대입하라는 의미가 된다.
- 즉, 필드는 바뀌지 않습니다. 이런 경우 필드라는 것을 **컴파일러와 JVM**에게 알려주기 위해서 **this키워드**를 사용해야 한다.

```java
public Car(String name){
    this.name = name;
}
```

- 즉 매개변수의 값을 필드에 대입하라는 의미가 된다.

**클래스 안에서 자기 자신이 가지고 있는 메소드를 사용할 때도 this.메소드명()으로 호출할 수 있다.**

```java
class Person {
    String name;
    int age;
    
    Person(){
        this("이름 없음", 1);
    }
    
    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

- this를 사용해 다른 생성자를 호출할 수 있다.
- 이때, `this("이름 없음",1);` 앞에 어떠한 코드도 올 수 없다.
  - 생성자는 클래스 인스턴스가 생성될 떄 호출되어야 하는데, 앞에 다른 코드가 있다면 인스턴스가 생성이 된 후이기때문에 그 후 생성자를 호출하면 에러가 발생한다.

```java
class Person {
    String name;
    int age;
    
    Person(){
        this("이름 없음", 1);
    }
    
    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public Person returnItSelf(){
        return this;
    }
}
```

- 인스턴스의 주소를 반환한다.

## 10. 메소드 오버로딩

매개변수의 타입 또는 개수를 다르게 하여 같은 이름의 메소드를 여러 개 가져서 상황에 맞춰 호출되는 것

```java
class MyClass2{
    public int plus(int x, int y){
        return x+y;
    }

    public int plus(int x, int y, int z){
        return x + y + z;
    }

    public String plus(String x, String y){
        return x + y;
    }
}

public int plus(int i, int f){
    return i+f;
}

public MethodOverloadExam{
    public static void main(String args[]){
        MyClass2 m = new MyClass2();
        System.out.println(m.plus(5,10));
        System.out.println(m.plus(5,10,15));
        System.out.println(m.plus("hello" + " world"));
    }
}
```

## 11. 생성자 오버로딩과 this

**생성자의 매개변수의 유형과 개수가 다르게 하여 같은 이름의 생성자를 여러 개 가질 수 있다.**

- 생성자도 메소드와 마찬가지로 여러개를 선언할 수 있다.
- 매개변수의 수와 타입이 다르다면 여러개의 생성자를 선언할 수 있다.

```java
public class Car{
    String name;
    int number;

    public Car(){

    }

    public Car(String name){
        this.name = name;
    }

    public Car(String name, int number){
        this.name = name;
        this.number = number;
    }
}
```

**오버로딩된 생성자 이용하기**

```java
public class CarExam4{
    public static void main(String args[]){
        Car c1 = new Car();
        Car c2 = new Car("소방차");
        Car c3 = new Car("구급차", 1234);
    }
}
```

**자기 생성자 호출하는 this()**

- 기본생성자를 호출하였을 때 name을 이름없음 , 숫자를 0으로 초기화 하기

```java
public Car(){
    this.name = "이름없음";
    this.number = 0;
}
```

- 위처럼 작성했을 경우 코드의 중복이 일어난다.
- 자신이 가지고 있는 다른 생성자를 이용할 수 있다.

```java
public Car(){
    this("이름없음", 0);
}
```

- this괄호 열고로 시작하면 자신의 생성자를 호출하는 것이다.
- 자기 자신의 생성자를 호출함으로써 비슷한 코드가 중복되서 나오는 것을 방지할 수 있다.

## 12. 패키지

**패키지**

패키지(package)란 서로 관련이 있는 **클래스** 또는 인터페이스들을 묶어 놓은 묶음

- 패키지를 만들면, 물리적으로 프로젝트 하위에 디렉토리가 생성됨

- 패키지를 사용함으로써 클래스들이 필요할 때만 사용

- 클래스를 패키지 이름과 함께 계층적인 형태로 사용함으로써 다른 그룹에 속한 클래스와 발생할 수 있는 클래스 이름간의 충돌을 막아줌으로 클래스의 관리를 편하게 해줌

**패키지 정의방법**

```java
pakage 패키지이름;

public class 클래스명 {

}
```

- package이름은 보통 **도메인 이름**을 거꾸로 적은 후, 그 뒤에 **프로젝트 이름**을 붙여서 만든다. 물론, 프로젝트 이름 뒤에 또 다른 이름이 나올 수도 있다.
- package이름은 **폴더명.폴더명.폴더명** 과 같은 형식으로 만들어진다. 각각의 폴더명은 숫자로 시작할 수 없다.
- 도메인 이름이 8cruz.com 이고 프로젝트 이름이 **javastudy** 라면 **com.eightcruz.javastudy.Hello** 로 패키지를 지정 할 수 있다.
  - 도메인이 숫자로 시작되는데 패키지명은 첫글자에 숫자를 사용할 수 없으므로 적절하게 수정한다.
  - 도메인으로 사용하는 이유는 패키지가 중복되는것을 방지하기 위함이므로, 반드시 존재하는 도메인이 아니라도 상관없다.

**이클립스에서 패키지 생성하기**

1. 소스폴더를 선택한 후 우측버튼을 클릭하여 패키지 생성을 선택한다.
2. 패키지 이름에 **kr.co.helloWorld.javastudy**를 입력한다.
3. 해당 패키지를 선택하고 Hello클래스를 작성한다.
   - 작성된 클래스 파일의 첫줄에 **package com.eightcruz.javastudy.Hello;** 생성된것을 볼 수 있다.
   - 패키지를 생성하는 예약어는 **package** 다.

**패키지에 생성된 클래스 사용하기**

- **java.lang**패키지를 제외하고는 **다른 패키지에 있는 클래스**를사용하려면 **import라는 구문**을 적어줘야 한다.
- **import com.eightcruz.javastudy.Hello;**
- 위의 코드는 **com.eightcruz.javastudy**패키지 아래의 Hello클래스를 사용하겠다는 것을 컴파일러와 JVM에게 알리는 것이다.
- 클래스 이름대신에 **\*** 를 적어도 된다. **import com.eightcruz.javastudy.\***;

**import 하지 않고 사용하는 방법**

- 만약 import를 하기 싫다면, 혹은 각기 다른 패키지에 존재하는 같은 이름의 클래스 파일을 사용해야 한다면 아래와 같이 이용한다.
  - **com.eightcruz.javastudy.Hello hello = new()** **com.eightcruz.javastudy.Hello();** 이렇게 사용한다.

## 13. 상속

**상속이란? 부모가 가진것을 자식에게 물려주는것을 의미한다.**

- 노트북은 컴퓨터의 한 종류다.
- 침대는 가구의 한 종류다. 혹은 침대는 가구다.
- 소방차는 자동차다.

이렇게 말할 수 있는 관계를 **is a** 관계 혹은 kind of 관계라고 한다.

**Car 를 상속받은 Bus 를 class로 표현하는 방법**

```java
public class Car{

}

public class Bus extends Car{

}
```

- 자바는 클래스 이름 뒤에 **extends** 키워드를 적고 부모클래스 이름을 적게 되면 부모 클래스가 가지고 있는 것을 상속받을 수 있게 된다.
- 상속이란 부모가 가지고 있는 것을 자식이 물려받는 것을 말한다. 즉, 부모가 가지고 있는 것을 자식이 사용할 수 있게 된다.

부모클래스에 메소드 추가하기

- Car에 run()메소드를 추가

```java
public class Car{
    public void run(){
        System.out.println("달리다.");
    }
}
```

- Car를 상속받은 Bus 사용

```java
public class BusExam{
    public static void main(String args[]){
        Bus bus = new Bus();
        bus.run();
        //Bus class 는 아무런 코드를 가지지 않는다. 그럼에도 run 이라는 메소드를 사용하는데 문제가 발생되지 않는다.
    }
}
```

- Bus에 메소드 추가

```java
public class Bus extends Car{
    public void ppangppang(){
        System.out.println("빵빵");
    }
}
```

- Bus는 Car에서 물려받은 run메소드와 ppangppang메소드를 사용할 수 있게 된다.
- 부모가 가지고 있는 메소드외에 추가로 메소드를 선언하는 것을 확장하였다고 표현한다.

## 14. 접근 제한자(제어자)

접근 제한자란 클래스 내에서 멤버의 접근을 제한하는 역할을 한다.

**접근제한자의 종류**

- **public**
  - 어떤 클래스든 접근할 수 있다는 것을 의미
- **protected**
  - 기본적으로 **자기자신, 같은 패키지에서는 접근 가능**하고, **다른 패키지에서는 접근이 불가능**
  - but, 다른 패키지다 하더라도 **상속받은 자식 클래스에서는 접근할수 있다.**
- **private**
  - **자기 자신만 접근**할 수 있다는 것을 의미
  - 같은 패키지도 불가능
- (접근제한자를 적지 않으면 ) **default**접근 지정자
  - **자기자신과 같은 패키지**에서만 접근할 수 있다는 것을 의미

```java
public class AccessObj{
    private int i = 1;
    int k = 2; // default접근 제한자
    public int p = 3;
    protected int p2 = 4;
}
```

- AccessObj를 사용하는 AccessObjExam (**같은 패키지**)
  - AccessObj의 필드 i 의 접근 제한자는 private이므로 다른 클래스인 AccessObjExam에서 접근할 수 없다.

```java
public class AccessObjExam{
    public static void main(String args[]){
        AccessObj po = new AccessObj();

        System.out.println(po.i); // 컴파일 오류가 발생합니다.
        System.out.println(po.k);
        System.out.println(po.p);
        System.out.println(po.p2);
    }
}
```

- AccessObj 와 **다른 패키지에서 사용**해보기
  - 패키지가 달라졌기때문에 default접근제한자로 지정된 필드 k 와 protected 접근제한자로 지정된 필드 p2 도 접근할 수 없다.

```java
public class AccessObjExam{
    public static void main(String args[]){
        AccessObj po = new AccessObj();

        System.out.println(po.i); // 컴파일 오류가 발생합니다.
        System.lout.println(po.k);// 컴파일 오류가 발생합니다.
        System.lout.println(po.p);
        System.lout.println(po.p2);// 컴파일 오류가 발생합니다.
    }
}
```

- AccessObjExam을 **AccesObj로 부터 상속**받도록 수정한 후 사용해 보기
  - **패키지는 다르지만 상속관계**에 있으므로 protected 접근제한자로 지정된 필드 p2에 접근할 수 있다.

```java
public class AccessObjExam extends AccessObj{
    public static void main(String[] args) {
        AccessObjExam obj = new AccessObjExam();
        System.out.println(obj.p);
        System.out.println(obj.p2);
        System.out.println(obj.k);// 컴파일 오류가 발생합니다.
        System.out.println(obj.i);// 컴파일 오류가 발생합니다.
    }
}
```

- getter, setter (`get(), set()`)

  private로 선언한 변수를 외부 코드에서 사용하려면 get(), set()메서드를 사용하면 된다.

  ```java
  public class HelloWorld {
      private String name;
  
      public String getName() {
          return name;
      }
      
      public void setName(String name) {
          this.name = name;
      }
  
      public HelloWorld(String pName){
          name = pName;
      }
  }
  ```

- 정보 은닉

  - public으로 프로퍼티에 접근하는 것과, private와 getter, setter를 사용해서 프로퍼티에 접근하는 것의 차이점은?

    

## 15. 추상클래스

추상 클래스란 **구체적이지 않은 클래스**를 의미한다. 새, 포유류 같은 것은 구체적이지 않다. 이런 것을 구현한 클래스를 추상 클래스라고 한다.

> 메소드의 시그니처를 미리 정의해 놓고, 실제 동작 방법은 하위 클래스에서 사용하는 경우가 많다.

**추상 클래스 정의하기**

- 추상 클래스는 클래스 앞에 **abstract** 키워드를 이용해서 정의한다.
- 추상 클래스는 **미완성의 추상 메소드를 포함할 수 **있다.
  - **추상 메소드**란, **내용이 없는 메소드** 이다. 즉 구현이 되지 않은 메소드이다.
  - **추상 메소드**는 리턴 타입 앞에 **abstract**라는 키워드를 붙여야 한다.
- 추상 클래스는 인스턴스를 생성할 수 없다.

```java
public abstract class Bird{
    public abstract void sing(); //추상 메소드

    public void fly(){
        System.out.println("날다.");
    }
}
```

**추상 클래스를 상속받는 클래스 생성하기**

- **추상 클래스를 상속**받은 클래스는 추상 클래스가 갖고 있는 추상 메소드를 **반드시 구현**해야 한다.
- 추상 클래스를 상속받고, 추상 클래스가 갖고 있는 **모든 추상 메소드를 구현하지 않으면 해당 클래스도 추상 클래스로 만들어야 된다**.

```java
public class Duck extends Bird{
    @Override
    public void sing() {
        System.out.println("꽥꽥!!");
    }
}
```

**사용하기**

- **Bird는 추상 클래스 이므로 객체를 생성할 수 없다.**

```java
public class DuckExam {
    public static void main(String[] args) {
        Duck duck = new Duck();
        duck.sing();
        duck.fly();

        //Bird b = new Bird();
    }
}
```

추상클래스를 사용하는 이유

- 자식 클래스에서 메서드 구현을 강제할 수 있다.

## 16. super와 부모 생성자

class가 인스턴스화 될때 부모의 생성자부터 실행된다.

**부모 생성자**

```java
public class Car{
    public Car(){
        System.out.println("Car의 기본생성자입니다.");
    }
}

public class Bus extends Car{
    public Bus(){
        System.out.println("Bus의 기본생성자입니다.");
    }

}
```

- 생성자 테스트

```java
public class BusExam{
    public static void main(String args[]){
        Bus b = new Bus();
    }
}
```

- 결과

> Car의 기본생성자입니다.
> Bus의 기본생성자입니다.

- new 연산자로 Bus객체를 생성하면, Bus객체가 메모리에 올라갈때 **부모인 Car도 함께 메모리에 올라간다.**
- 생성자가 호출될 때 **자동으로 부모의 생성자가 호출되면서 부모객체를 초기화** 하게된다.

**super**

- **자신을** 가리키는 키워드가 **this** 라면, **부모들 가리키는 키워드**는 **super**
- **super() 는 부모의 생성자**를 의미한다.
- 부모의 생성자를 임의로 호출하지 않으면, **부모 class의 기본 생성자가 자동으로 호출**된다.
- 아래 예제처럼 호출해보면 위에서 **super()를 호출하지 않을때와 결과가 같다.** 즉, super()가 없더라도 생략되어 있다고 생각하면 된다.

```java
public Bus(){
    super();
    System.out.println("Bus의 기본생성자입니다.");
}
```

**부모의 기본생성자가 아닌 다른 생성자를 호출하는 방법**

- 클래스는 **기본 생성자가 없는 경우도 존재**한다.

```java
public class Car{
    public Car(String name){
        System.out.println(name + " 을 받아들이는 생성자입니다.");
    }
}
```

- Car class가 위 처럼 수정되면, Bus생성자에서 컴파일 오류가 발생
- 부모가 **기본생성자가 없기 때문에** 컴파일 오류가 발생
- 이런 문제를 해결하려면 **자식 클래스의 생성자에서 직접 부모의 생성자를 호출**

```java
public Bus(){
    super("소방차"); // 문자열을 매개변수로 받는 부모 생성자를 호출하였다.
    System.out.println("Bus의 기본생성자입니다.");
}
```

- super 키워드는 자식에서 부모의 메소드나 필드를 사용할 때도 사용

## 17. 오버라이딩

오버라이딩이란 부모가 가지고 있는 **메소드와 똑같은 모양의 메소드를 자식이 가지고 있는 것**이다. 즉 오버라이딩이란 **메소드를 재정의** 하는 것이다.

**메소드 오버라이딩**

- Car 클래스를 상속받은 Bus 클래스는 부모클래스가 가진고 있는 run() 메소드를 잘 사용한다.

```java
//run 메소드를 가지고 있는  Car클래스
public class Car{
    public void run(){
        System.out.println("Car의 run메소드");
    }
}

//Car 를 상속받는 Bus 클래스
public class Bus extends Car{

}

public class BusExam{
    public static void main(String args[]){
        Bus bus = new Bus();
        bus.run();  //Car의 run메소드가 실행된다.
    }
}
```

- Bus클래스에 부모가 가지고 있는 메소드와 모양이 같은 메소드를 선언

```java
public class Bus extends Car{
    public void run(){
        System.out.println("Bus의 run메소드");
    }
}

public class BusExam{
    public static void main(String args[]){
        Bus bus = new Bus();
        bus.run();  //Bus run메소드가 실행된다.
    }
}
```

- BusExam을 실행해 보도록 하겠습니다. Bus의 run메소드가 출력된다.
- **메소드를 오버라이드 하면, 항상 자식클래스에서 정의된 메소드가 호출**된다.
- 오버라이딩 한다고 해서 부모의 메소드가 사라지는 것은 아니다.
  - **super 키워드를 이용하면, 부모의 메소드를 호출** 할 수 있다.

```java
public class Bus extends Car{
    public void run(){
        super.run();  // 부모의  run()메소드를 호출
        System.out.println("Bus의 run메소드");
    }
}
```

- 가상 메서드

  변수가 사용하는 메모리와 메서드가 사용하는 메모리는 다르다. 변수는 인스턴스가 생성될 때 마다 새로 생성되지만, 메서드는 싱행해야 할 명령 집합이기 때문에, 인스턴스가 달라도 같은 로직을 수행한다. 즉, 여러개의 인스턴스를 생성해도 여러개의 메서드가 생성되는 것이 아니다. 즉, 다른 인스턴스라고 하더라도 같은 메모리 주소의 메서드를 참조하고 있게 된다.

  일반적으로 프로그램에서 메서드를 호출한다는 것은 그 메서드의 명령집합이 있는 메모리 위치를 참조하여 명령을 실행한다.

  가상 메서드의 경우에는 **가상 메서드 테이블**이 만들어지고, 가상 메서드 테이블은 각 메서드 이름과 실제 메모리 주소가 짝을 이루고 있다. 즉, 어떤 메서드가 호출되면 어떤 주소값으로 찾아서 메서드를 실행할지 매핑해둔다. 

  즉, 가상함수는 **실행시점에 동작바인딩**에 의해 어떤 메소드 코드를 호출해야 할지 결정하는데 이때 가상 메서드 테이블을 사용한다.

  ![img](https://t1.daumcdn.net/cfile/tistory/991CDF4D5C4D08A733)

  자바는 모든 메소드를 가상함수라고 본다. 즉 모든 메소드는 반드시 가상함수 테이블에 가서 주소를 찾은 다음에 호출을 위해 점프할 수 있다. 이것은 당연히 C++에 비해 효율성이 많이 떨어진다. 그러나 자바는 virtual이라든가 다른 키워드를 사용하지 않아도 되고 구별없이 오버라이드할 수 있다. (최근에는 @Override를 써주라고 하는데, 이것은 성능과는 관계없이 컴파일러가 메소드 선언을 슈퍼에 맞게 잘 했는지 검사해 주는 역할과 가독성을 위한 문서화 역할을 한다.[1](https://plas.tistory.com/29#footnote_29_1) 여전히 모든 메소드는 가상함수다.)

  - 만약, 클래스 A에 x라는 메서드가 있고, **클래스 A를 B에서 상속** 받는다. 그리고, B는 **x를 오버라이딩**하고, **y라는 새로운 메서드를 정의** 했다. 만약, `A obj = new B();`와 같이 A타입에 B의 인스턴스를 담는다고하면, obj.x()와 obj.y()는 각각 어떻게 작동할까?
    - obj.x()는 B에 정의된 x가 실행된다.(오버라이딩) **데이터 타입의 껍데기는 A**이지만 **실제 인스턴스는 B**이기 때문에 **오버라이딩으로 동작**하게 되는 것이다.
      - 상속에서 상위 클래스와 하위 클래스에 같은 이름의 메서드가 존재할 때 호출되는 메서드는 **인스턴스의 타입**에 따라 결정됨(변수의 선언 타입이 아닌)
    -  하지만, **obj.y()같이 A에는 정의 되지 않은 메서드를 호출**되면**, A타입에는 없기 때문에 에러**가 발생한다.



## 18. 클래스 형변환

부모타입으로 자식객체를 참조하게 되면 부모가 가지고 있는 메소드만 사용할 수 있다. 자식객체가 가지고 있는 메소드나 속성을 사용하고 싶다면 형변환 해야 한다.

**형변환**

```java
public class Car{
    public void run(){
        System.out.println("Car의 run메소드");
    }
}

public class Bus extends Car{
    public void ppangppang(){
        System.out.println("빵빵.");
    }
}
```

- 부모타입으로 자식객체를 참조할 수 있다.
  - 부모타입으로 자식객체를 참조하게 되면 부모가 가지고 있는 메소드만 사용할 수 있다.

```java
public class BusExam{
    public static void main(String args[]){
        Car car = new Bus(); // Bus의 인스턴스를 Car 타입으로 선언
        car.run();
        car.ppangppang(); // 컴파일 오류 발생
    }
}
```

- **ppangppang()메소드**를 호출하고 싶다**면 Bus타입의 참조변수로 참조**해야 한다.

```java
public class BusExam{
    public static void main(String args[]){
        Car car = new Bus();  // 묵시적 형변환
        car.run();
        //car.ppangppang(); // 컴파일 오류 발생

        Bus bus = (Bus)car;  // 부모타입을 자식타입으로 형변환
        bus.run();
        bus.ppangppang();
    }
}
```

- 객체들 끼리도 형변환이 가능하다. 단 **상속관계에 있었을 때만 가능**하다.
- **부모타입으로 자식타입의 객체를 참조할 때는 묵시적으로 형변환**이 일어난다.
- 다운캐스팅 : **부모타입의 객체를 자식타입으로 참조하게 할때는 명시적으로 형변환** 해주어 한다. 단 이렇게 형변환 할때에는 **부모가 참조하는 인스턴스가 형변환 하려는 자식타입일 때만 가능**하다.

## 19. 인터페이스

**인터페이스**: 서로 관계가 없는 물체들이 상호 작용을 하기 위해서 사용하는 장치나 시스템

기능들을 모아 놓은 것

**인터페이스 정의**

- 프로그램에 어떤 메서드를 제공할지 미리 알려주는 명세

- **추상 메소드와 상수를 정의** 할 수 있다.
- 인터페이스에 정의된 수는 상수이고, 메서드는 추상메서드이다.
- 추상 메소드에 abstract를 쓰지 않아도되고, 상수에 final을 쓰지 않아도 컴파일러가 자동으로 변환한다.

```java
public interface TV{
    public int MAX_VOLUME = 100; // public static final 로 인식
    int MIN_VOLUME = 0; // public을 쓰지 않아도 public static final 로 인식

    public void turnOn(); // public abstract로 인식
    void turnOff(); // public을 쓰지 않아도 public abstract로 인식
    public void changeVolume(int volume);
    public void changeChannel(int channel);
}
```

인터페이스에서 변수를 선언하면 컴파일시 자동으로 아래와 같이 바뀐다.

```java
public static final int MAX_VOLUME = 100;
public static final int MIN_VOLUME = 0;
```

**인터페이스에서 정의된 메소드는 모두 추상 메소드**이다. 위에서 선언된 모든 메소드는 컴파일 시에 다음과 같이 자동으로 변경된다.

```java
public abstract void on();
public abstract void off();
public abstract void volume(int value);
public abstract void channel(int number);
```

**인터페이스 사용**

- 인터페이스는 사용할때 해당 인터페이스를 구현하는 클래스에서 **implements** 키워드를 이용한다.

```java
public class LedTV implements TV{
    public void on(){
        System.out.println("켜다");
    }
    public void off(){
        System.out.println("끄다");
    }
    public void volume(int value){
        System.out.println(value + "로 볼륨조정하다.");
    }
    public void channel(int number){
        System.out.println(number + "로 채널조정하다.");
    }
}
```

- 인터페이스가 가지고 있는 **메소드를 하나라도 구현하지 않는다면 해당 클래스는 추상클래스가 된다.**(추상클래스는 인스턴스를 만들 수 없음)

```java
public class LedTVExam{
    public static void main(String args[]){
        TV tv = new LedTV();
        tv.on();
        tv.volume(50);
        tv.channel(6);
        tv.off();
    }
}
```

- **참조변수의 타입** (TV tv = )으로 인터페이스를 사용할 수 있다. 이 경우 **인터페이스가 가지고 있는 메소드만 사용할 수 있다.**
- 형변환도 가능하다.
- 만약 TV인터페이스를 구현하는 LcdTV를 만들었다면 위의 코드에서 new LedTV부분만 new LcdTV로 변경해도 똑같이 프로그램이 동작할 것다. 동일한 인터페이스를 구현한다는 것은 클래스 사용법이 같다는 것을 의미한다.
- 클래스는 이러한 인터페이스를 **여러개 구현**할 수 있다. (다중 상속)
- 인터페이스는 인터페이스를 상속 받을 수 있으며, 다중 상속도 가능하다. 이때 인터페이스 끼리 상속받을 때는 implements가 아닌 extends로 상속 받게 된다.

## 20. 인터페이스의 default method & static method

**JAVA 8**이 등장하면서 interface에 대한 정의가 몇 가지 변경되었다.

**default메소드**

- 인터페이스가 **default키워드**로 선언되면 **메소드가 구현될 수 있다**.
- 또한 이를 구현하는 클래스는 **default메소드를 오버라이딩** 할 수 있다.
- 이를 지원하는 이유는 아마 유지보수 측면에서 인터페이스가 수정되면 인터페이스를 상속하는 클래스들을 모두 바꾸어야 하는데, 그것이 쉽지 않아서 그런게 아닐까..?

```java
public interface Calculator {
    public int plus(int i, int j);
    public int multiple(int i, int j);
    default int exec(int i, int j){      //default로 선언함으로 메소드를 구현할 수 있다.
        return i + j;
    }
}

//Calculator인터페이스를 구현한 MyCalculator클래스
public class MyCalculator implements Calculator {

    @Override
    public int plus(int i, int j) {
        return i + j;
    }

    @Override
    public int multiple(int i, int j) {
        return i * j;
    }
}

public class MyCalculatorExam {
    public static void main(String[] args){
        Calculator cal = new MyCalculator();
        int value = cal.exec(5, 10);
        System.out.println(value);
    }
}
```

- 인터페이스가 변경이 되면, 인터페이스를 구현하는 모든 클래스들이 해당 메소드를 구현해야 하는 문제가 있다. 이런 문제를 해결하기 위하여 인터페이스에 메소드를 구현해 놓을 수 있도록 하였다.

**static메소드**

```java
public interface Calculator {
    public int plus(int i, int j);
    public int multiple(int i, int j);
    default int exec(int i, int j){
        return i + j;
    }
    public static int exec2(int i, int j){   //static 메소드
        return i * j;
    }
}

//인터페이스에서 정의한 static메소드는 반드시 인터페이스명.메소드 형식으로 호출해야한다.

public class MyCalculatorExam {
    public static void main(String[] args){
        Calculator cal = new MyCalculator();
        int value = cal.exec(5, 10);
        System.out.println(value);

        int value2 = Calculator.exec2(5, 10);  //static메소드 호출
        System.out.println(value2);
    }
}
```

- 인터페이스에서 정의한 static메소드는 반드시 **인터페이스명.메소드** 형식으로 호출해야한다.
- 인터페이스에 static 메소드를 선언함으로써, **인터페이스를 이용하여 간단한 기능을 가지는 유틸리티성 인터페이스**를 만들 수 있게 되었다.

> 자바 9버전 부터는 private 메서드도 사용이 가능하다.
>
> private는 재정의를 하거나 외부에서 사용할 수 없다.

### 다중상속

- 클래스는 이러한 인터페이스를 **여러개 구현**할 수 있다. (다중 상속)
- 만약 동일한 디폴트 메서드를 가지고있는 인터페이스들을 상속받는 경우 어떻게 해야할까?
  - 컴파일 에러가 발생하게 된다. 
  - 해당 디폴트 메서드를 재정의(오버라이딩)해서 사용해야 한다.

## 21. 내부 클래스

클래스 내부에 선언되어 있는 클래스를 내부 클래스라고 하고, 보통 두 클래스 사이에 밀접한 관련이 있는 경우에 사용한다.

**어느 위치에 선언하느냐에 따라서 4가지 형태가 있을 수 있다.**

> 인스턴스 내부 클래스, 정적 내부 클래스, 지역 내부 클래스, 익명 클래스
>
> ```java
> class ABC{					// 외부 클래스
> 	class In{				// 인스턴스 내부 클래스
>         static class Sin{	// 정적 내부 클래스
>             
>         }
>     }
>     
>     public void abc(){
>         class Local{		// 지역 내부 클래스
>             
>         }
>     }
> }
> ```

### **인스턴스 내부 클래스**

- 첫번째는 **클래스 안에 인스턴스 변수**, 즉 필드를 선언하는 위치에 선언되는 경우. 
- 보통 **중첩클래스** 혹은 **인스턴스 클래스**라고 한다.
- 외부클래스 생성없이 내부 클래스를 생성할 수 없다.
  - 내부에 있는 Cal객체를 생성하기 위해서는, 밖에는 **InnerExam1의 객체를 만든 후**에 `InnerExam1.Cal cal = t.new Cal();`과 같은 방법으로 Cal객체를 생성한 후 사용한다.

```java
public class InnerExam1{
    class Cal{
        int value = 0;
        public void plus(){
            value++;
        }
    }

    public static void main(String args[]){
        InnerExam1 t = new InnerExam1();
        InnerExam1.Cal cal = t.new Cal();
        cal.plus();
        System.out.println(cal.value);
    }
}
```

- 바로 외부 클래스 내부에서 클래스를 사용하는 경우 많이 사용

```java
public class Out{
    private In inClass;
    
    private class In{
        int inNum = 100;
        //static int sInNum = 200;  (인스턴스 내부 클래스에 정적 변수 선언 불가능)
    
    	void inTest(){
            //...
        }
    }
	
    public Out() {
        inClass = new In();
    }
    
    public void usingClass(){
        inClass.inTest();
    }
}
```

- 외부 클래스에서 사용하지 않는다면 내부 클래스를 private로 하는 것이 좋음
- 인스턴스 내부 클래스에서 정적 변수나 메서드를 선언할 수 없음
  - 외부 클래스가 먼저 선언되어야 하기 때문..

### 정적 내부 클래스

- 두번째는 **내부 클래스가 static으로 정의된 경우**, **정적 중첩 클래스** 또는 **static 클래스**라고 한다.
- 정적 내부 클래스에서 **정적 변수나 메서드를 선언할 수 있음**
  - 다만, static이기 때문에 **외부 클래스의 인스턴스 변수는 사용할 수 없음**
- 정적 클래스이기 때문에 외부 클래스의 인스턴스를 따로 생설할 필요 없이 클래스명으로 내부 클래에 바로 접근이 가능하다. 
  - 필드 선언할 때 스태틱한 필드로 선언한 것과 같다. 이 경우에는 **InnerExam2객체를 생성할 필요없이** **new InnerExam2.Cal() 로 객체를 생성할 수 있다.**

```java
public class InnerExam2{
    private int num = 10;
    
    static class Cal{
        int value = 0;
        static int a = 3; //정적 변수 사용 가능
        
        
        public void plus(){
        	//num += 10   인스턴스 변수는 static 내부 클래스에서 사용이 불가능하다.
            value++;
        }
    }

    public static void main(String args[]){
        InnerExam2.Cal cal = new InnerExam2.Cal();
        cal.plus();
        System.out.println(cal.value);

    }
}
```

- 정적 내부 클래스 메서드와 사용 가능 변수 유형

| 정적 내부 클래스 메서드 | 변수 유형 : 사용 가능 여부                                   |
| ----------------------- | ------------------------------------------------------------ |
| 일반 메서드             | 외부 클래스의 인스턴스 변수 : X<br />외부 클래스의 정적 변수 : O<br />정적 내부 클래스의 인스턴스 변수 : O<br />정적 내부 클래스의 정적 변수 : O |
| 정적 메서드             | 외부 클래스의 인스턴스 변수 : X<br />외부 클래스의 정적 변수 : O<br />정적 내부 클래스의 인스턴스 변수 : X<br />정적 내부 클래스의 정적 변수 : O |

### 지역 내부 클래스

- 세번째로는 **메소드 안에 클래스를 선언**한 경우
- **지역 중첩 클래스** 또는 **지역 클래스**라고 한다.
  - **메소드 안에서 해당 클래스를 이용할 수 있다.**
  - 보통은 메서드 내부에서 인스턴스를 생성해서 반환해 주는 경우 사용한다.

```java
public class InnerExam3{
    public void exec(){
        class Cal{
            int value = 0;
            public void plus(){
                value++;
            }
        }
        Cal cal = new Cal();
        cal.plus();
        System.out.println(cal.value);
    }


    public static void main(String args[]){
        InnerExam3 t = new InnerExam3();
        t.exec();
    }
}
```

- 지역 내부 클래스에서 외부 메서드에 선언된 변수들을 사용하게 되면, 해당 변수들은 **상수처리** 된다. (지역 내부 클래스로 생성된 인스턴스에서는 외부 메서드가 스택에서 사라지더라도 해당 값들을 유지 할 수 있음 => 자바스크립트의 클로저랑 비슷한 느낌)
  - 자바 7까지는 final을 명시적으로 써주어야 했지만, 자바8부터는 써주지 않아도 자동으로 상수처리됨

### 익명 클래스

- 네번째로는 익명 중첩 클래스가 있다. **익명 클래스**라고 보통 말하며, **내부 클래스**이기도 하다.

```java
//추상클래스 Action
public abstract class Action{
    public abstract void exec();
}

//------------------------------------//

//추상클래스 Action을 상속받은 클래스 MyAction
public class MyAction extends Action{
    public void exec(){
        System.out.println("exec");
    }
}

//MyAction을 사용하는 클래스 ActionExam
public class ActionExam{
    public static void main(String args[]){
        Action action = new MyAction();
        action.exec();
    }
}

//------------------------------------//

//MyAction을 사용하지 않고 Action을 상속받는 익명 클래스를 만들어서 사용하도록 수정해 보도록 하겠습니다.
public class ActionExam{
    public static void main(String args[]){
        Action action = new Action(){  //인터페이스나 추상클래스를 이용해 익명 클래스 생성 가능
            public void exec(){
                System.out.println("exec");
            }
        };
        action.exec();
    }
}
```

- **생성자 다음에** 중괄호 열고 닫고가 나오면, 해당 생성자 이름에 해당하는 **클래스를 상속받는 이름없는 객체**를 만든다는 것을 뜻한다.
- **괄호 안에는 메소드를 구현하거나 메소드를 추가할 수 있다.** 이렇게 생성된 이름 없는 객체를 **action이라는 참조변수가 참조하도록 하고, exec()메소드를 호출**.
- 익명클래스를 만드는 이유는 **Action을 상속받는 클래스를 만들 필요가 없을 경우**이다.
- **Action을 상속받는 클래스가 해당 클래스에서만 사용되고 다른 클래스에서는 사용되지 않는 경우**이다.

## 22. Exception

**오류와 예외**

자바에서 제공하는 오류는 모두 **Throwable**클래스를 상속 받음

Throwable클래스 하위에 Error 클래스와 Exception클래스가 존재

Error클래스는 제어 불가능, Exception 클래스와 그 하위의 클래스만 제어

- 시스템 오류(error)
  - 자바 가상머신에서 발생 (스택오버플로우 등)
  - 핸들링 불가능
- 예외 (exception) 
  - 핸들링 가능



프로그램 실행 중 예기치 못한 사건을 예외라 한다.

```java
public class ExceptionExam {
    public static void main(String[] args) {
        int i = 10;
        int j = 5;
        int k = i / j;
        System.out.println(k);
        System.out.println(main 종료!!);
    }
}
```

- 위 코드에서 j를 0으로 바꾸면 Excption 발생
  - j를 0으로 바꾸면 **ArithmeticException이 발생**하면서 프로그램이 종료된다.
  - Java는 정수를 정수로 나눌때 0으로 나누면 안된다.0으로 나누면 오류가 발생하는 것입니다.
- 예외 처리
  - 프로그래머는 j라는 변수에 0이 들어올지도 모르는 예외 상황을 미리 예측하고 처리할 수 있다.
- 예외처리하는 문법
  - 오류가 발생할 예상 부분을 **try라는 블록으로 감싼 후,** 발생할 오류와 관련된 **Exception을 catch라는 블록에서 처리**한다.
  - 오류가 발생했든 안했든 **무조건 실행되는 finally라는 블록**을 가질 수 있다.
  - finally는 언제 쓰는 것일까?
    - ex) 데이터베이스 서버에 접속해서 여러개의 자바 어플리케이션이 정보를 가져올 때 DB와 관련된 작업을 try로 묶어주고, 에러 발생시 catch를 해준뒤, final에서 DB의 연결을 끊어 주어야 커넥션을 다른 어플리케이션이 사용할 수 있다.
  - **finally블록은 생략가능**하다.

```java
public class ExceptionExam {
    public static void main(String[] args) {
        int i = 10;
        int j = 0;
        try{
            int k = i / j;
            System.out.println(k);
        }catch(ArithmeticException e){
            System.out.println("0으로 나눌 수 없습니다. : " + e.toString());
        }finally {
            System.out.println("오류가 발생하든 안하든 무조건 실행되는 블록입니다.");
        }
    }
}
```

- 실행결과

  > 0으로 나눌 수 없습니다. :` java.lang.ArithmeticException: / by zero`
  >
  > 오류가 발생하든 안하든 무조건 실행되는 블록입니다.

- Exception 처리하지 않았을때는 프로그램이 강제 종료되었는데 **catch라는 블록으로 Exception을 처리하니 강제종료되지 않고 잘 실행**되는 것을 알 수 있다.

- try블록에서 여러종류의 Exception이 발생한다면 **catch라는 블록을 여러개** 둘 수 있다.

- **Exception클래스들은 모두 Exception클래스를 상속**받으므로, **예외클래스에 Exception을 두게 되면 어떤 오류가 발생하든지 간에 ** **하나의 catch블록에서 모든 오류를 처리**할 수 있다.

- catch가 여러개라면, 하나의 캐치만 동작하게 된다.(if, else if, else 느낌처럼 앞의 순서부터 매칭을 해보고 매치잉 되면 그부분의 캐치만 실행된다.) 그래서 부모 예외는 나중에 놓고 자식예외는 먼저 놓는 것이 좋다. (**부모가 예외가 앞에있다면 자식 예외는 항상 실행되지 않는다**.)

**Exception 객체의 메세지 표현방법**

- e.getMessage(); : 짧은 메세지의 스트링 리턴
- e.toString(); : 에러의 종류 + 메세지의 스트링 리턴
- e.printStackTrace() : 에러 발생을 트레이스한 결과를 출력함

> 컴파일 타임에 예외처리를 체크하는 예외가 존재한다. (ex, IO)
>
> 그러한, 예외는 반드시 예외처리를 해주어야 한다. 

**try-with-resources**

- 자바 7부터 제공
- try안에서 열린 리소스들을 닫아주지 않더라도 자동으로 close()해주는 기능
- 이 문법을 사용하기 위해서는 AutoCloseable 인터페이스를 구현(상속)해야함
  - ex) FileInputStream은 AutoCloseable과 Closeable을 구현하고 있음, 따라서 try-with-resources를 사용할 수 있음
- **try(사용할 리소스){}** 형식으로 사용

**AutoCloseable 인터페이스**

```java
public class AutoCloseObj implemets AutoCloseable {
    @Override
    public void close() throws Exception {
        //...
    }
}
```

```java
try (AutoCloseObj obj1 = new AutoCloseOBj(); AutoCloseObj obj2 = new AutoCloseOBj()){   //사용할 리소스 
    //..
} catch (Exception e) {
    //...
}
```

**향상된 try-with-resoureces**

- 자바 9에서 업그레이드 됨
- 자바 7에서는 무조건 리소스가 try문 안에서 선언 되어야 했지만, 자바 9부터는 `try(리소스)`형식으로 외부에서 선언된 리소스도 자동으로 close해주는 기능이 추가되었다.

```java
AutoCloseObj obj1 = new AutoCloseOBj();
AutoCloseObj obj2 = new AutoCloseOBj();

try(obj1; obj2){
    //..
} catch (Exception e)  {
    //...
}
```

## 23. throws

**throws**는 예외가 발생했을때 예외를 **호출한 쪽에서 처리하도록 던져준다.**

> 예외처리를 미룬다고 봐도 된다.

throws가 있는 메서드는 **호출될 때 반드시 호출되는 곳에서 예외처리**가 되어야 한다. (트라이/캐치 또는 throws 로 처리)

```java
public class ExceptionExam2 {
    public static void main(String[] args) {
        int i = 10;
        int j = 0;
        int k = divide(i, j);
        System.out.println(k);
    }

    public static int divide(int i, int j){
        int k = i / j;
        return k;
    }
}
```

다음과 같이 divide메소드를 수정

```java
public class ExceptionExam2 {

    public static void main(String[] args) {
        int i = 10;
        int j = 0;
        int k = divide(i, j);
        System.out.println(k);
    }
    
    public static int divide(int i, int j) throws ArithmeticException{
        int k = i / j;
        return k;
    }
}
```

메소드 선언 뒤에 `throws ArithmeticException` 이 적혀있는 것을 알 수 있습니다. 이렇게 적어놓으면 divide메소드는 **ArithmeticException**이 발생하니 **divide메소드를 호출하는 쪽에서 오류를 처리**하라는 뜻입니다.

```java
package javaStudy;
public class ExceptionExam2 {

    public static void main(String[] args) {
        int i = 10;
        int j = 0;
        try{
            int k = divide(i, j);
            System.out.println(k);
        } catch(ArithmeticException e){
            System.out.println("0으로 나눌수 없습니다.");
        } 

    }

    public static int divide(int i, int j) throws ArithmeticException{
        int k = i / j;
        return k;
    }

}
```

- 메서드 뒤에 `throws Exception` 이라고 적으면 모든 예외에 대해서 예외를 던진다.

## 24. 강제로 예외 발생 시키기

`throw != throws`

**throw**는 오류를 떠넘기는 **throws**와 **보통 같이 사용**됩니다.

```java
public class ExceptionExam3 {
    public static void main(String[] args) {
        int i = 10;
        int j = 0;
        int k = divide(i, j);
        System.out.println(k);

    }
    public static int divide(int i, int j){
        int k = i / j;
        return k;
    }
}
```

- divide메소드는 2번째 파라미터의 값이 0일 경우 나누기를 할 때 Exception이 발생한다.

**위의 코드를 에러가 발생하지 않게 수정**

```java
public class ExceptionExam3 {
    public static void main(String[] args) {
        int i = 10;
        int j = 0;
        int k = divide(i, j);
        System.out.println(k);
    }

    public static int divide(int i, int j){
        if(j == 0){
            System.out.println("2번째 매개변수는 0이면 안됩니다.");
            return 0;
        }
        int k = i / j;
        return k;
    }
}
```

- j가 0일 경우 안된다는 메시지가 출력되도록 수정하고 0을 리턴.
- 이렇게 할 경우 main메소드의 k변수는 0값을 가지게 되고 0을 출력하게 된다.
- 0으로 나눈 결과는 0이 아니다. 0으로 반환하면 더 큰 문제가 발생할수도 있다.

**에러도 발생하지 않고, 올바르지 않은 결과를 리턴하지 않도록 수정**

```java
public class ExceptionExam3 {
    public static void main(String[] args) {
        int i = 10;
        int j = 0;
        int k = divide(i, j);
        System.out.println(k);

    }
    public static int divide(int i, int j) throws IllegalArgumentException{
        if(j == 0){
            throw new IllegalArgumentException("0으로 나눌 수 없어요.");
        }
        int k = i / j;
        return k;
    }
}
```

- j가 0일 경우에 new연산자를 통하여 **IllegalArgumentException 객체가 만들어 진다.**
- **new 앞에 throw 는 해당 라인에서 익셉션이 발생한다는 의미**이다.
- 즉 그 줄에서 오류가 발생했다는 것이다. 0으로 나눌수 없습니다. 라는 오류가 발생한것이다.
- **Exception클래스 이름을 보면 아규먼트가 잘못되었기 때문에 발생한 오류라는 것을 알 수 있다.**

**divide 메소드를 호출 한 쪽에서의 오류 처리**

- divide 메소드 뒤에 **throws IllegalArgumentException 은 해당 오류는 divide를 호출한 쪽에서 처리를 해야한다는 것을 의미**한다.

```java
public class ExceptionExam3 {
    public static void main(String[] args) {
        int i = 10;
        int j = 0;
        try{
            int k = divide(i, j);
            System.out.println(k);
        }catch(IllegalArgumentException e){
            System.out.println(e.toString()); // 0으로 나눌 수 없어요.
        }
    }

    public static int divide(int i, int j) throws IllegalArgumentException{
        if(j == 0){
            throw new IllegalArgumentException("0으로 나눌 수 없어요.");
        }
        int k = i / j;
        return k;
    }
}
```

## 25. 사용자 정의 Exception (상속)

원하는 Exception의 이름을 만들기 위해 상속을 사용할 수 있다.

- **Exception 클래스를 상속** 받아 정의한 **checked Exception**
  - **반드시 오류를 처리 해야만 하는 Exception**
  - 예외 처리하지 않으면 **컴파일 오류**를 발생 시킨다.
- **RuntimeException 클래스를 상속** 받아 정의한 **unChecked Exception**
  - 예외 처리하지 않아도 **컴파일 시에는 오류를 발생시키지 않는다.**
  - 런타임시 오류를 발생

**RuntimeException을 상속받은 BizException객체**

```java
public class BizException extends RuntimeException {
    public BizException(String msg){
        super(msg);
    }
    public BizException(Exception ex){
        super(ex);
    }
}
```

- 생성자 오버로딩을 활용
  - 스트링을 받아서 에러 메세지를 받도록 함
  - 다른 예외를 입력받아서 예외 생성

**BizService**클래스는 업무를 처리하는 메소드를 가지고 있다고 가정한다.

```java
public class BizService {
    public void bizMethod(int i)throws BizException{
        System.out.println("비지니스 로직이 시작합니다.");
        if(i < 0){
            throw new BizException("매개변수 i는 0이상이어야 합니다.");
        }
        System.out.println("비지니스 로직이 종료됩니다.");
    }
}
```

**앞에서 만든 BizService를 이용하는 BizExam클래스**

- 매개변수 값을 -1을 넘길때는 Exception이 발생하기 때문에 try catch블록으로 처리한다.

```java
public class BizExam {
    public static void main(String[] args) {
        BizService biz = new BizService();
        biz.bizMethod(5);
        try{
            biz.bizMethod(-3);
        }catch(Exception ex){
            ex.printStackTrace();
        }
    }
}
```

**실행결과**

> 비지니스 로직이 시작합니다.
> 비지니스 로직이 종료됩니다.
> 비지니스 로직이 시작합니다.
> javaStudy.BizException: 매개변수 i는 0이상이어야 합니다.
> at javaStudy.BizService.bizMethod(BizService.java:7)
> at javaStudy.BizExam.main(BizExam.java:9)

## 26. instanceof

`인스턴스 instanceof 클래스` 

- true or false

다운캐스팅에 활용할 수 있음

```java
Animal hAnimal = new Human();
if(hAnimal instanceof Human){
	Human human = (Human)hAnimal;
} else if (hAnimal instanceof Tiger){
    Tiger tiger = (Tiger)hAnimal;
}
```

- 만약에 다른 종류의 잘못된 클래스로 다운캐스팅 되면, 컴파일 에러는 없지만, 런타임 에러가 발생한다. 