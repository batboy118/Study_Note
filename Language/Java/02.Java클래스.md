# 02. Java 클래스

> 자바의 클래스에 대해 학습

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./README.md)

---

<!-- TOC -->

- 

<!-- /TOC -->

## 1. 클래스 선언

```java
public class Car{

}
```

## 2. 인스턴스 생성

```java
Car 변수 = new Car();
```

## 3. 필드(field)

```java
public class Car{
    String name;    
    int number;
}
```

- 클래스가 가지고 있는 속성을 필드라한다.

## 4. 메소드(Method)

- 메소드 종류
  - main 메소드
  - 사용자 정의 메소드 (main 이외의 모든 메소드)

- 클래스의 행동(함수)를 의미

```
public 리턴타입(파라미터){

}
```

- 예시

```java
public class MyClass{

    public void method(){
        System.out.println("method1이 실행됩니다.");
    }
    
    public void method1(){
        System.out.println("method1이 실행됩니다.");
    }

    public void method2(int x){
        System.out.println(x + " 를 이용하는 method2입니다.");
    }

    public int method3(){
        System.out.println("method3이 실행됩니다.");
        return 10;
    }

    public void method4(int x, int y){
        System.out.println(x + "," + y + " 를 이용하는 method4입니다.");
    }
    
}
```

## 5. String 클래스

```java
String str1 = "hello";
String str2 = new String("hello");
```

- String  클래스는 특별하게 new 연산자 없이 인스턴스를 생성할 수 있다.

- 생성방식에 따른 차이점이 존재하긴 한다.

  - `String str1 = "hello";`의 경우 스트링은 메모리 상의 상수들이 저장되는 영역에 저장된다.

    만약, `String str3 = "hello;"`와 같이 같은 스트링을 또 선언한다면, 같은 인스턴스를 참조하게 된다.

  - `String str2 = new String("hello");`처럼 new 연산자를 만들게 되면, 새로운 인스턴스를 만들어 낸다. 같은 인스턴스를 참조하지 않는다.

- 스트링은 불변의 값이다. 값을 변경하고 싶으면 새로운 스트링을 만들어 주어야 한다.

- `str1 == str2`은 같은 참조를 가지는지 확인, `str1.equals(str2)`는 같은 값을 가지는지 확인

- 스트링에서 기본자료형으로의 형변환

  ```java
  int iVal = Integer.ValueOf(str);
  int dVal = Double.ValueOf(str);
  int chVal = str.charAt(0); // 0번째 문자
  ```

### 5.1. String 메서드

- str.length();

- `Strint ss = str.split("구분자");`

  - 어레이 리턴

- concat

  - str.concat(world) 메소드는 str 이 참조하는 문자열 hello 에다가 메소드의 인자로 들어온 문자열 world 를 붙혀서 String 타입으로 리턴하는 메소드다.
  - String Class는 불변 클래스로, 메소드가 수행되면, 새로운 문자열을 만든다. 그러므로, 원래 클래스는 변하지 않는다.

  ```java
  String str = new String("hello");
  
  System.out.println(str.concat(" world"));  //출력결과는 hello world 
  System.out.println(str);  //출력결과는 hello 
  ```

- substring

  - str.subString(1,3) 은 str이 참조하는 문자열을 인덱스 1번부터 3번까지 자른 결과이다.
  - str.subString(2) 은 str이 참조하는 문자열을 2번 인덱스부터 마지막까지 자른 결과를 의미한다.
  - 문자열의 인덱스는 0번 부터 시작한다.

  ```java
  System.out.println(str.substring(1, 3)); //출력결과  el
  System.out.println(str.substring(2));   //출력결과 llo world
  ```

## 6. 변수의 scope와 static

### 6.1. 변수의 스코프

- 클래스의 속성으로 선언된 변수 globalScope 의 사용 범위는 클래스 전체 이다.
- 매개변수로 선언된 int value 는 블럭 바깥에 존재하기는 하지만, 메서드 선언부에 존재하므로 사용범위는 해당 메소드 블럭내이다.
- 메소드 블럭내에서 선언된 localScope 변수의 사용범위는 메소드 블럭내이다.

```java
public class ValableScopeExam{

    int globalScope = 10;   // 인스턴스 변수 

    public void scopeTest(int value){   
        int localScope = 10;
        System.out.println(globalScope);
        System.out.println(localScpe);
        System.out.println(value);
    }
}
```

### 6.2. main메소드에서 사용하기

- 같은 클래스 안에 있는데 globalScope 변수를 사용 할 수 없다.
- main은 static한 메소드이다. **static한 메서드에서는 static 하지 않은 필드를 사용 할 수 없다.**

```java
public class VariableScopeExam {
    int globalScope = 10; 

    public void scopeTest(int value){
        int localScope = 20;            
        System.out.println(globalScope);
        System.out.println(localScope);
        System.out.println(value);
    }   
    public static void main(String[] args) {
        System.out.println(globalScope);  //오류
        System.out.println(localScope);   //오류
        System.out.println(value);        //오류  
    }   
}
```

### 6.3. static

- 같은 클래스 내에 있음에도 해당 변수들을 사용할 수 없다.
- main 메소드는 static 이라는 키워드로 메소드가 정의되어 있다. 이런 메서드를 static 한 메소드 라고 한다.
- static한 필드(필드 앞에 static 키워드를 붙힘)나, static한 메소드는 **Class가 인스턴스화 되지 않아도 사용할 수 있다.**

```java
public class VariableScopeExam {
    int globalScope = 10; 
    static int staticVal = 7;

    public void scopeTest(int value){
        int localScope = 20;        
    }

    public static void main(String[] args) {
        System.out.println(staticVal);      //스태틱 필드는 사용가능 
    }

}
```

**static한 변수는 공유된다.**

- static하게 선언된 변수는 값을 저장할 수 있는 공간이 하나만 생성된다. 그러므로, 인스턴스가 여러개 생성되도 static한 변수는 하나다.

```java
public static void main(String[] args) {
    ValableScopeExam v1 = new ValableScopeExam();
    ValableScopeExam v2 = new ValableScopeExam();
    v1.golbalScope = 20;
    v2.golbalScope = 30; 

    System.out.println(v1.golbalScope);  //20 이 출력된다.  
    System.out.println(v2.golbalScope);  //30이 출력된다. 

    v1.staticVal = 10;
    v2.staticVal = 20; 

    System.out.println(v1.statVal);  //20 이 출력된다. 
    System.out.println(v2.statVal);  //20 이 출력된다. 
}
```

- **golbalScope**같은 변수(필드)는 인스턴스가 생성될때 생성되기때문에 **인스턴스 변수**라고 한다.
- **staticVal**같은 static한 필드를 **클래스 변수**라고 한다.
- **staticVal**같은 클래스 변수는 **레퍼런스.변수명 하고 사용하기 보다는 클래스명.변수명 으로 사용하는것이 더 바람직**하다고 하다.
  - VariableScopeExam.staticVal

> static 메서드(클래스 메서드)에서는 인스턴스 멤버에 접근이 불가능하다.
>
> 인스턴스 메서드에서는 스태틱 멤버에 접근이 가능하다.

## 7. 열겨헝(enum)

- 열거형은 JDK5에서 추가되었다.

- JDK5 이전에는 상수를 열거형 대신 사용
  - 상수를 이용하는 방법

```java
public class EnumExam {
    public static final String MALE = "MALE";
    public static final String FEMALE = "FEMALE";

    public static void main(String[] args) {
        String gender1;

        gender1 = EnumExam.MALE;
        gender1 = EnumExam.FEMALE;                  
    }
}
```

**상수를 사용했때의 문제점**

- String으로 선언된 gender1 에는 MALE,FEMALE 둘 중 한가지 값을 갖기 원하는데, gender1의 type이 String 이기 때문에 gender1 = "소년"; 이렇게 수행 되어도 전혀 문제가 되지 않는다.
- 실행할때 원했던 값인 MALE,FEMALE 이 아닌 다른 값이 들어오게 되므로 문제를 발생시킬 수 있다.

**해결 방법**

- 열거형 사용 방법

```java
public class EnumExam {
    public static void main(String[] args) {
        Gender gender2;

        gender2 = Gender.MALE;
        gender2 = Gender.FEMALE;
        //Gender타입의 변수에는 MALE이나 FEMALE만 대입이 가능. 다른 값은 저장할 수가 없다.  
    }
}

//정의
enum Gender{    
    MALE, FEMALE;
}

```

**특정 값만 가져야 한다면 열거형을 사용하는 것이 좋다.**

## 8. 생성자

```java
Public class 클래스명{
    타입 필드명;
    
    //생성자
    public 클래스명(매개변수 목록){
        ...
    }
    
    public 리턴타입 메소드명 (매개변수 목록){
        
    }
}
```

**생성자의 특징**

- 생성자는 **리턴타입이 없다.**
- 생성자가 없다면, **기본 생성자가 컴파일 시 만들어진다.**
- 매개변수가 없는 생성자를 기본생성자라고 한다.
- **생성자가 하나라도 존재한다면, 기본 생성자는 만들어지지 않는다.**

**생성자의 역할**

- 생성자가 하는 일은 객체가 될 때 **필드를 초기화** 하는 역할을 수행한다.
- 자동차가 객체가 될때 반드시 이름을 가지도록 하려면, Car클래스를 다음과 같이 만들어야 한다.

```java
public class Car{
    String name;
    int number;

    public Car(String n){
        name = n;
    }
}
```

- 위의 Car 클래스를 이용하여 Car 인스턴스를 생성하는 방법

```java
public class CarExam2{
    public static void main(String args[]){

        Car c1 = new Car("소방차");
        Car c2 = new Car("구급차");
        //Car c3 = new Car(); // 컴파일 오류가 발생합니다.

        System.out.println(c1.name);

        System.out.println(c2.name);
    }
}
```

- Car클래스는 기본 생성자를 가지지 않는다. 그래서 기본생성자로 Car 객체를 생성할 수 없다.

## 9. this 키워드

this는 현재 객체, 자기 자신을 나타낸다.

```java
public class Car{
    String name;
    int number;

    public Car(String n){
        name = n;
    }
}
```

- Car클래스의 생성자 매개변수의 이름이 n 이다. n 이라는 변수명은 무엇을 의미하는지 쉽기 알수 없다.

```java
public Car(String name){
    name = name;
}
```

- 'name=name' 이라고 코드를 바꾸면, 가깝게 선언된 변수를 우선 사용하기 때문에 'name=name'이라는 코드는 매개변수의 name의 값을 매개변수 name에 대입하라는 의미가 된다.
- 즉, 필드는 바뀌지 않습니다. 이런 경우 필드라는 것을 **컴파일러와 JVM**에게 알려주기 위해서 **this키워드**를 사용해야 한다.

```java
public Car(String name){
    this.name = name;
}
```

- 즉 매개변수의 값을 필드에 대입하라는 의미가 된다.

**클래스 안에서 자기 자신이 가지고 있는 메소드를 사용할 때도 this.메소드명()으로 호출할 수 있다.**

## 10. 메소드 오버로딩

매개변수의 타입 또는 개수를 다르게 하여 같은 이름의 메소드를 여러 개 가져서 상황에 맞춰 호출되는 것

```java
class MyClass2{
    public int plus(int x, int y){
        return x+y;
    }

    public int plus(int x, int y, int z){
        return x + y + z;
    }

    public String plus(String x, String y){
        return x + y;
    }
}

public int plus(int i, int f){
    return i+f;
}

public MethodOverloadExam{
    public static void main(String args[]){
        MyClass2 m = new MyClass2();
        System.out.println(m.plus(5,10));
        System.out.println(m.plus(5,10,15));
        System.out.println(m.plus("hello" + " world"));
    }
}
```

## 11. 생성자 오버로딩과 this

**생성자의 매개변수의 유형과 개수가 다르게 하여 같은 이름의 생성자를 여러 개 가질 수 있다.**

- 생성자도 메소드와 마찬가지로 여러개를 선언할 수 있다.
- 매개변수의 수와 타입이 다르다면 여러개의 생성자를 선언할 수 있다.

```java
public class Car{
    String name;
    int number;

    public Car(){

    }

    public Car(String name){
        this.name = name;
    }

    public Car(String name, int number){
        this.name = name;
        this.number = number;
    }
}
```

**오버로딩된 생성자 이용하기**

```java
public class CarExam4{
    public static void main(String args[]){
        Car c1 = new Car();
        Car c2 = new Car("소방차");
        Car c3 = new Car("구급차", 1234);
    }
}
```

**자기 생성자 호출하는 this()**

- 기본생성자를 호출하였을 때 name을 이름없음 , 숫자를 0으로 초기화 하기

```java
public Car(){
    this.name = "이름없음";
    this.number = 0;
}
```

- 위처럼 작성했을 경우 코드의 중복이 일어난다.
- 자신이 가지고 있는 다른 생성자를 이용할 수 있다.

```java
public Car(){
    this("이름없음", 0);
}
```

- this괄호 열고로 시작하면 자신의 생성자를 호출하는 것이다.
- 자기 자신의 생성자를 호출함으로써 비슷한 코드가 중복되서 나오는 것을 방지할 수 있다.

## 12. 패키지

**패키지**

패키지(package)란 서로 관련이 있는 **클래스** 또는 인터페이스들을 묶어 놓은 묶음

- 패키지를 사용함으로써 클래스들이 필요할 때만 사용

- 클래스를 패키지 이름과 함께 계층적인 형태로 사용함으로써 다른 그룹에 속한 클래스와 발생할 수 있는 클래스 이름간의 충돌을 막아줌으로 클래스의 관리를 편하게 해줌

**패키지 정의방법**

```java
pakage 패키지이름;

public class 클래스명 {

}
```

- package이름은 보통 **도메인 이름**을 거꾸로 적은 후, 그 뒤에 **프로젝트 이름**을 붙여서 만든다. 물론, 프로젝트 이름 뒤에 또 다른 이름이 나올 수도 있다.
- package이름은 **폴더명.폴더명.폴더명** 과 같은 형식으로 만들어진다. 각각의 폴더명은 숫자로 시작할 수 없다.
- 도메인 이름이 8cruz.com 이고 프로젝트 이름이 **javastudy** 라면 **com.eightcruz.javastudy.Hello** 로 패키지를 지정 할 수 있다.
  - 도메인이 숫자로 시작되는데 패키지명은 첫글자에 숫자를 사용할 수 없으므로 적절하게 수정한다.
  - 도메인으로 사용하는 이유는 패키지가 중복되는것을 방지하기 위함이므로, 반드시 존재하는 도메인이 아니라도 상관없다.

**이클립스에서 패키지 생성하기**

1. 소스폴더를 선택한 후 우측버튼을 클릭하여 패키지 생성을 선택한다.
2. 패키지 이름에 **kr.co.helloWorld.javastudy**를 입력한다.
3. 해당 패키지를 선택하고 Hello클래스를 작성한다.
   - 작성된 클래스 파일의 첫줄에 **package com.eightcruz.javastudy.Hello;** 생성된것을 볼 수 있다.
   - 패키지를 생성하는 예약어는 **package** 다.

**패키지에 생성된 클래스 사용하기**

- **java.lang**패키지를 제외하고는 **다른 패키지에 있는 클래스**를사용하려면 **import라는 구문**을 적어줘야 한다.
- **import com.eightcruz.javastudy.Hello;**
- 위의 코드는 **com.eightcruz.javastudy**패키지 아래의 Hello클래스를 사용하겠다는 것을 컴파일러와 JVM에게 알리는 것이다.
- 클래스 이름대신에 ***** 를 적어도 된다. **import com.eightcruz.javastudy.***;

**import 하지 않고 사용하는 방법**

- 만약 import를 하기 싫다면, 혹은 각기 다른 패키지에 존재하는 같은 이름의 클래스 파일을 사용해야 한다면 아래와 같이 이용한다.
  - **com.eightcruz.javastudy.Hello hello = new()** **com.eightcruz.javastudy.Hello();** 이렇게 사용한다.

## 13. 상속

**상속이란? 부모가 가진것을 자식에게 물려주는것을 의미한다.**

- 노트북은 컴퓨터의 한 종류다.
- 침대는 가구의 한 종류다. 혹은 침대는 가구다.
- 소방차는 자동차다.

이렇게 말할 수 있는 관계를 **is a** 관계 혹은 kind of 관계라고 한다.

**Car 를 상속받은 Bus 를 class로 표현하는 방법**

```java
public class Car{

}

public class Bus extends Car{

}
```

- 자바는 클래스 이름 뒤에 **extends** 키워드를 적고 부모클래스 이름을 적게 되면 부모 클래스가 가지고 있는 것을 상속받을 수 있게 된다.
- 상속이란 부모가 가지고 있는 것을 자식이 물려받는 것을 말한다. 즉, 부모가 가지고 있는 것을 자식이 사용할 수 있게 된다.

부모클래스에 메소드 추가하기

- Car에 run()메소드를 추가

```java
public class Car{
    public void run(){
        System.out.println("달리다.");
    }
}
```

- Car를 상속받은 Bus 사용

```java
public class BusExam{
    public static void main(String args[]){
        Bus bus = new Bus();
        bus.run();  
        //Bus class 는 아무런 코드를 가지지 않는다. 그럼에도 run 이라는 메소드를 사용하는데 문제가 발생되지 않는다. 
    }   
}
```

- Bus에 메소드 추가

```java
public class Bus extends Car{
    public void ppangppang(){
        System.out.println("빵빵");
    }       
}
```

- Bus는 Car에서 물려받은 run메소드와 ppangppang메소드를 사용할 수 있게 된다.
- 부모가 가지고 있는 메소드외에 추가로 메소드를 선언하는 것을 확장하였다고 표현한다.

## 14. 접근 제한자

접근 제한자란 클래스 내에서 멤버의 접근을 제한하는 역할을 한다.

**접근제한자의 종류**

- **public**
  - 어떤 클래스든 접근할 수 있다는 것을 의미
- **protected**
  - 기본적으로 **자기자신, 같은 패키지에서는 접근 가능**하고, **다른 패키지에서는 접근이 불가능**
  - but, 다른 패키지다 하더라도 **상속받은 자식 클래스에서는 접근할수 있다.**
- **private**
  - **자기 자신만 접근**할 수 있다는 것을 의미
  - 같은 패키지도 불가능
- (접근제한자를 적지 않으면 ) **default**접근 지정자
  - **자기자신과 같은 패키지**에서만 접근할 수 있다는 것을 의미

```java
public class AccessObj{
    private int i = 1;
    int k = 2; // default접근 제한자
    public int p = 3;
    protected int p2 = 4;
}
```

- AccessObj를 사용하는 AccessObjExam (**같은 패키지**)
  - AccessObj의 필드 i 의 접근 제한자는 private이므로 다른 클래스인 AccessObjExam에서 접근할 수 없다.

```java
public class AccessObjExam{
    public static void main(String args[]){
        AccessObj po = new AccessObj();

        System.out.println(po.i); // 컴파일 오류가 발생합니다.
        System.out.println(po.k);
        System.out.println(po.p);
        System.out.println(po.p2);
    }
}
```

- AccessObj 와 **다른 패키지에서 사용**해보기
  - 패키지가 달라졌기때문에 default접근제한자로 지정된 필드 k 와 protected 접근제한자로 지정된 필드 p2 도 접근할 수 없다.

```java
public class AccessObjExam{
    public static void main(String args[]){
        AccessObj po = new AccessObj();

        System.out.println(po.i); // 컴파일 오류가 발생합니다.
        System.lout.println(po.k);// 컴파일 오류가 발생합니다.
        System.lout.println(po.p);
        System.lout.println(po.p2);// 컴파일 오류가 발생합니다.
    }
}
```

- AccessObjExam을 **AccesObj로 부터 상속**받도록 수정한 후 사용해 보기
  - **패키지는 다르지만 상속관계**에 있으므로 protected 접근제한자로 지정된 필드 p2에 접근할 수 있다.

```java
public class AccessObjExam extends AccessObj{
    public static void main(String[] args) {
        AccessObjExam obj = new AccessObjExam();
        System.out.println(obj.p);
        System.out.println(obj.p2);
        System.out.println(obj.k);// 컴파일 오류가 발생합니다.
        System.out.println(obj.i);// 컴파일 오류가 발생합니다.
    }
}
```

## 15. 추상클래스

추상 클래스란 구체적이지 않은 클래스를 의미한다. 새, 포유류 같은 것은 구체적이지 않다. 이런 것을 구현한 클래스를 추상 클래스라고 한다.

**추상 클래스 정의하기**

- 추상 클래스는 클래스 앞에 **abstract** 키워드를 이용해서 정의한다.
- 추상 클래스는 미완성의 추상 메소드를 포함할 수 있다.
  - **추상 메소드**란, **내용이 없는 메소드** 이다. 즉 구현이 되지 않은 메소드이다.
  - **추상 메소드**는 리턴 타입 앞에 **abstract**라는 키워드를 붙여야 한다.
- 추상 클래스는 인스턴스를 생성할 수 없다.

```java
public abstract class Bird{
    public abstract void sing(); //추상 메소드

    public void fly(){
        System.out.println("날다.");
    }
}
```

**추상 클래스를 상속받는 클래스 생성하기**

- **추상 클래스를 상속**받은 클래스는 추상 클래스가 갖고 있는 추상 메소드를 **반드시 구현**해야 한다.
- 추상 클래스를 상속받고, 추상 클래스가 갖고 있는 **추상 메소드를 구현하지 않으면 해당 클래스도 추상 클래스가 된다**.

```java
public class Duck extends Bird{
    @Override
    public void sing() {
        System.out.println("꽥꽥!!");
    }
}
```

**사용하기**

- **Bird는 추상 클래스 이므로 객체를 생성할 수 없다.**

```java
public class DuckExam { 
    public static void main(String[] args) {
        Duck duck = new Duck();
        duck.sing();
        duck.fly();

        //Bird b = new Bird();
    }   
}
```

## 16. super와 부모 생성자

class가 인스턴스화 될때 부모의 생성자부터 실행된다.

**부모 생성자**

```java
public class Car{
    public Car(){
        System.out.println("Car의 기본생성자입니다.");
    }
}

public class Bus extends Car{
    public Bus(){
        System.out.println("Bus의 기본생성자입니다.");
    }

}
```

- 생성자 테스트

```java
public class BusExam{
    public static void main(String args[]){
        Bus b = new Bus();
    }
}
```

- 결과

> Car의 기본생성자입니다.
> Bus의 기본생성자입니다.

- new 연산자로 Bus객체를 생성하면, Bus객체가 메모리에 올라갈때 **부모인 Car도 함께 메모리에 올라간다.**
- 생성자가 호출될 때 **자동으로 부모의 생성자가 호출되면서 부모객체를 초기화** 하게된다.

**super**

- **자신을** 가리키는 키워드가 **this** 라면, **부모들 가리키는 키워드**는 **super**
- **super() 는 부모의 생성자**를 의미한다.
- 부모의 생성자를 임의로 호출하지 않으면, **부모 class의 기본 생성자가 자동으로 호출**된다.
- 아래 예제처럼 호출해보면 위에서 **super()를 호출하지 않을때와 결과가 같다.**

```java
public Bus(){
    super();
    System.out.println("Bus의 기본생성자입니다.");
}
```

**부모의 기본생성자가 아닌 다른 생성자를 호출하는 방법**

- 클래스는 **기본 생성자가 없는 경우도 존재**한다.

```java
public class Car{
    public Car(String name){
        System.out.println(name + " 을 받아들이는 생성자입니다.");
    }
}
```

- Car class가 위 처럼 수정되면, Bus생성자에서 컴파일 오류가 발생
- 부모가 **기본생성자가 없기 때문에** 컴파일 오류가 발생
- 이런 문제를 해결하려면 **자식 클래스의 생성자에서 직접 부모의 생성자를 호출**

```java
public Bus(){
    super("소방차"); // 문자열을 매개변수로 받는 부모 생성자를 호출하였다.
    System.out.println("Bus의 기본생성자입니다.");
}
```

- super 키워드는 자식에서 부모의 메소드나 필드를 사용할 때도 사용

## 17. 오버라이딩

오버라이딩이란 부모가 가지고 있는 **메소드와 똑같은 모양의 메소드를 자식이 가지고 있는 것**이다. 즉 오버라이딩이란 **메소드를 재정의** 하는 것이다.

**메소드 오버라이딩**

- Car 클래스를 상속받은 Bus 클래스는 부모클래스가 가진고 있는 run() 메소드를 잘 사용한다.

```java
//run 메소드를 가지고 있는  Car클래스 
public class Car{
    public void run(){
        System.out.println("Car의 run메소드");
    }
}

//Car 를 상속받는 Bus 클래스 
public class Bus extends Car{

}

public class BusExam{
    public static void main(String args[]){
        Bus bus = new Bus();
        bus.run();  //Car의 run메소드가 실행된다. 
    }
}
```

- Bus클래스에 부모가 가지고 있는 메소드와 모양이 같은 메소드를 선언

```java
public class Bus extends Car{
    public void run(){
        System.out.println("Bus의 run메소드");
    }
}

public class BusExam{
    public static void main(String args[]){
        Bus bus = new Bus();
        bus.run();  //Bus run메소드가 실행된다. 
    }
}
```

- BusExam을 실행해 보도록 하겠습니다. Bus의 run메소드가 출력된다.
- **메소드를 오버라이드 하면, 항상 자식클래스에서 정의된 메소드가 호출**된다.
- 오버라이딩 한다고 해서 부모의 메소드가 사라지는 것은 아니다.
  - **super 키워드를 이용하면, 부모의 메소드를 호출** 할 수 있다.

```java
public class Bus extends Car{
    public void run(){
        super.run();  // 부모의  run()메소드를 호출 
        System.out.println("Bus의 run메소드");
    }
}
```

## 18. 클래스 형변환

부모타입으로 자식객체를 참조하게 되면 부모가 가지고 있는 메소드만 사용할 수 있다. 자식객체가 가지고 있는 메소드나 속성을 사용하고 싶다면 형변환 해야 한다.

**형변환**

```java
public class Car{
    public void run(){
        System.out.println("Car의 run메소드");
    }
}

public class Bus extends Car{
    public void ppangppang(){
        System.out.println("빵빵.");
    }   
}
```

- 부모타입으로 자식객체를 참조할 수 있다.
  - 부모타입으로 자식객체를 참조하게 되면 부모가 가지고 있는 메소드만 사용할 수 있다.

```java
public class BusExam{
    public static void main(String args[]){
        Car car = new Bus(); // Bus의 인스턴스를 Car 타입으로 선언
        car.run();
        car.ppangppang(); // 컴파일 오류 발생
    }
}
```

- **ppangppang()메소드**를 호출하고 싶다**면 Bus타입의 참조변수로 참조**해야 한다.

```java
public class BusExam{
    public static void main(String args[]){
        Car car = new Bus();  // 묵시적 형변환
        car.run();
        //car.ppangppang(); // 컴파일 오류 발생

        Bus bus = (Bus)car;  // 부모타입을 자식타입으로 형변환 
        bus.run();
        bus.ppangppang();
    }
}
```

- 객체들 끼리도 형변환이 가능하다. 단 **상속관계에 있었을 때만 가능**하다.
- **부모타입으로 자식타입의 객체를 참조할 때는 묵시적으로 형변환**이 일어난다.
- **부모타입의 객체를 자식타입으로 참조하게 할때는 명시적으로 형변환** 해주어 한다. 단 이렇게 형변환 할때에는 **부모가 참조하는 인스턴스가 형변환 하려는 자식타입일 때만 가능**하다.

## 19. 인터페이스

**인터페이스**: 서로 관계가 없는 물체들이 상호 작용을 하기 위해서 사용하는 장치나 시스템

기능들을 모아 놓은 것

**인터페이스 정의**

- **추상 메소드와 상수를 정의** 할 수 있다.
- 인터페이스에 정의된 수는 상수이고, 메서드는 추상메서드이다.
- 추상 메소드에 abstract를 쓰지 않아도된다.

```java
public interface TV{
    public int MAX_VOLUME = 100;
    public int MIN_VOLUME = 0;

    public void turnOn();
    public void turnOff();
    public void changeVolume(int volume);
    public void changeChannel(int channel);
}
```

인터페이스에서 변수를 선언하면 컴파일시 자동으로 아래와 같이 바뀐다.

```java
public static final int MAX_VOLUME = 100;
public static final int MIN_VOLUME = 0;
```

**인터페이스에서 정의된 메소드는 모두 추상 메소드**이다. 위에서 선언된 모든 메소드는 컴파일 시에 다음과 같이 자동으로 변경된다.

```java
public abstract void on();
public abstract void off();
public abstract void volume(int value);
public abstract void channel(int number);
```

**인터페이스 사용**

- 인터페이스는 사용할때 해당 인터페이스를 구현하는 클래스에서 **implements** 키워드를 이용한다.

```java
public class LedTV implements TV{
    public void on(){
        System.out.println("켜다");
    }
    public void off(){
        System.out.println("끄다");   
    }
    public void volume(int value){
        System.out.println(value + "로 볼륨조정하다.");  
    }
    public void channel(int number){
        System.out.println(number + "로 채널조정하다.");         
    }
}
```

- 인터페이스가 가지고 있는 **메소드를 하나라도 구현하지 않는다면 해당 클래스는 추상클래스가 된다.**(추상클래스는 인스턴스를 만들 수 없음)

```java
public class LedTVExam{
    public static void main(String args[]){
        TV tv = new LedTV();
        tv.on();
        tv.volume(50);
        tv.channel(6);
        tv.off();
    }
}
```

- **참조변수의 타입** (TV tv = )으로 인터페이스를 사용할 수 있다. 이 경우 **인터페이스가 가지고 있는 메소드만 사용할 수 있다.**
- 형변환도 가능하다.
- 만약 TV인터페이스를 구현하는 LcdTV를 만들었다면 위의 코드에서 new LedTV부분만 new LcdTV로 변경해도 똑같이 프로그램이 동작할 것다. 동일한 인터페이스를 구현한다는 것은 클래스 사용법이 같다는 것을 의미한다.
- 클래스는 이러한 인터페이스를 **여러개 구현**할 수 있다. (다중 상속)

## 20. 인터페이스의 default method

**JAVA 8**이 등장하면서 interface에 대한 정의가 몇 가지 변경되었다.

**default메소드**

- 인터페이스가 **default키워드**로 선언되면 **메소드가 구현될 수 있다**. 
- 또한 이를 구현하는 클래스는 **default메소드를 오버라이딩** 할 수 있다.
- 이를 지원하는 이유는 아마 유지보수 측면에서 인터페이스가 수정되면 인터페이스를 상속하는 클래스들을 모두 바꾸어야 하는데, 그것이 쉽지 않아서 그런게 아닐까..?

```java
public interface Calculator {
    public int plus(int i, int j);
    public int multiple(int i, int j);
    default int exec(int i, int j){      //default로 선언함으로 메소드를 구현할 수 있다.
        return i + j;
    }
}

//Calculator인터페이스를 구현한 MyCalculator클래스
public class MyCalculator implements Calculator {

    @Override
    public int plus(int i, int j) {
        return i + j;
    }

    @Override
    public int multiple(int i, int j) {
        return i * j;
    }
}

public class MyCalculatorExam {
    public static void main(String[] args){
        Calculator cal = new MyCalculator();
        int value = cal.exec(5, 10);
        System.out.println(value);
    }
}
```

- 인터페이스가 변경이 되면, 인터페이스를 구현하는 모든 클래스들이 해당 메소드를 구현해야 하는 문제가 있다. 이런 문제를 해결하기 위하여 인터페이스에 메소드를 구현해 놓을 수 있도록 하였다.

**static메소드**

```java
public interface Calculator {
    public int plus(int i, int j);
    public int multiple(int i, int j);
    default int exec(int i, int j){
        return i + j;
    }
    public static int exec2(int i, int j){   //static 메소드 
        return i * j;
    }
}

//인터페이스에서 정의한 static메소드는 반드시 인터페이스명.메소드 형식으로 호출해야한다.  

public class MyCalculatorExam {
    public static void main(String[] args){
        Calculator cal = new MyCalculator();
        int value = cal.exec(5, 10);
        System.out.println(value);

        int value2 = Calculator.exec2(5, 10);  //static메소드 호출 
        System.out.println(value2);
    }
}
```

- 인터페이스에서 정의한 static메소드는 반드시 **인터페이스명.메소드** 형식으로 호출해야한다. 
- 인터페이스에 static 메소드를 선언함으로써, **인터페이스를 이용하여 간단한 기능을 가지는 유틸리티성 인터페이스**를 만들 수 있게 되었다.

## 21. 내부 클래스

**어느 위치에 선언하느냐에 따라서 4가지 형태가 있을 수 있다.**

- 첫번째는 **클래스 안에 인스턴스 변수**, 즉 필드를 선언하는 위치에 선언되는 경우. 보통 **중첩클래스** 혹은 **인스턴스 클래스**라고 한다.
  - 내부에 있는 Cal객체를 생성하기 위해서는, 밖에는 **InnerExam1의 객체를 만든 후**에 `InnerExam1.Cal cal = t.new Cal();`과 같은 방법으로 Cal객체를 생성한 후 사용한다.

```java
public class InnerExam1{
    class Cal{
        int value = 0;
        public void plus(){
            value++;
        }
    }

    public static void main(String args[]){
        InnerExam1 t = new InnerExam1();
        InnerExam1.Cal cal = t.new Cal();
        cal.plus();
        System.out.println(cal.value);
    }
}
```

- 두번째는 **내부 클래스가 static으로 정의된 경우**, **정적 중첩 클래스** 또는 **static 클래스**라고 한다.
  - 필드 선언할 때 스태틱한 필드로 선언한 것과 같다. 이 경우에는 **InnerExam2객체를 생성할 필요없이** **new InnerExam2.Cal() 로 객체를 생성할 수 있다.**

```java
public class InnerExam2{
    static class Cal{
        int value = 0;
        public void plus(){
            value++;
        }
    }

    public static void main(String args[]){
        InnerExam2.Cal cal = new InnerExam2.Cal();
        cal.plus();
        System.out.println(cal.value);

    }
}
```

- 세번째로는 **메소드 안에 클래스를 선언**한 경우, **지역 중첩 클래스** 또는 **지역 클래스**라고 한다.
  - **메소드 안에서 해당 클래스를 이용할 수 있다.**

```java
public class InnerExam3{
    public void exec(){
        class Cal{
            int value = 0;
            public void plus(){
                value++;
            }
        }
        Cal cal = new Cal();
        cal.plus();
        System.out.println(cal.value);
    }


    public static void main(String args[]){
        InnerExam3 t = new InnerExam3();
        t.exec();
    }
}
```

- 네번째로는 익명 중첩 클래스가 있다. **익명 클래스**라고 보통 말하며, **내부 클래스**이기도 하다.

```java
//추상클래스 Action 
public abstract class Action{
    public abstract void exec();
}

//------------------------------------//

//추상클래스 Action을 상속받은 클래스 MyAction
public class MyAction extends Action{
    public void exec(){
        System.out.println("exec");
    }
}
//MyAction을 사용하는 클래스 ActionExam 
public class ActionExam{
    public static void main(String args[]){
        Action action = new MyAction();
        action.exec();
    }
}

//------------------------------------//

//MyAction을 사용하지 않고 Action을 상속받는 익명 클래스를 만들어서 사용하도록 수정해 보도록 하겠습니다.
public class ActionExam{
    public static void main(String args[]){
        Action action = new Action(){
            public void exec(){
                System.out.println("exec");
            }
        };
        action.exec();
    }
}
```

- **생성자 다음에** 중괄호 열고 닫고가 나오면, 해당 생성자 이름에 해당하는 **클래스를 상속받는 이름없는 객체**를 만든다는 것을 뜻한다.
- **괄호 안에는 메소드를 구현하거나 메소드를 추가할 수 있다.** 이렇게 생성된 이름 없는 객체를 **action이라는 참조변수가 참조하도록 하고, exec()메소드를 호출**.
- 익명클래스를 만드는 이유는 **Action을 상속받는 클래스를 만들 필요가 없을 경우**이다.
- **Action을 상속받는 클래스가 해당 클래스에서만 사용되고 다른 클래스에서는 사용되지 않는 경우**이다.

## 22. Exception

프로그램 실행 중 예기치 못한 사건을 예외라 한다.

```java
public class ExceptionExam {
    public static void main(String[] args) {
        int i = 10;
        int j = 5;
        int k = i / j;
        System.out.println(k);
        System.out.println(main 종료!!);
    }
}
```

- 위 코드에서 j를 0으로 바꾸면 Excption 발생
  - j를 0으로 바꾸면 **ArithmeticException이 발생**하면서 프로그램이 종료된다.
  - Java는 정수를 정수로 나눌때 0으로 나누면 안된다.0으로 나누면 오류가 발생하는 것입니다.
- 예외 처리
  - 프로그래머는 j라는 변수에 0이 들어올지도 모르는 예외 상황을 미리 예측하고 처리할 수 있다.
- 예외처리하는 문법
  - 오류가 발생할 예상 부분을 **try라는 블록으로 감싼 후,** 발생할 오류와 관련된 **Exception을 catch라는 블록에서 처리**한다.
  - 오류가 발생했든 안했든 **무조건 실행되는 finally라는 블록**을 가질 수 있다.
  - **finally블록은 생략가능**하다.

```java
public class ExceptionExam {
    public static void main(String[] args) {
        int i = 10;
        int j = 0;
        try{
            int k = i / j;
            System.out.println(k);
        }catch(ArithmeticException e){
            System.out.println("0으로 나눌 수 없습니다. : " + e.toString());
        }finally {
            System.out.println("오류가 발생하든 안하든 무조건 실행되는 블록입니다.");
        }
    }
}
```

- 실행결과

  > 0으로 나눌 수 없습니다. :` java.lang.ArithmeticException: / by zero`
  >
  > 오류가 발생하든 안하든 무조건 실행되는 블록입니다.

- Exception 처리하지 않았을때는 프로그램이 강제 종료되었는데 **catch라는 블록으로 Exception을 처리하니 강제종료되지 않고 잘 실행**되는 것을 알 수 있다.

- try블록에서 여러종류의 Exception이 발생한다면 **catch라는 블록을 여러개** 둘 수 있다.

- **Exception클래스들은 모두 Exception클래스를 상속**받으므로, **예외클래스에 Exception을 두게 되면 어떤 오류가 발생하든지 간에 ****하나의 catch블록에서 모든 오류를 처리**할 수 있다.

## 23. throws

**throws**는 예외가 발생했을때 예외를 **호출한 쪽에서 처리하도록 던져준다.**

```java
public class ExceptionExam2 {   
    public static void main(String[] args) {
        int i = 10;
        int j = 0;
        int k = divide(i, j);
        System.out.println(k);
    }

    public static int divide(int i, int j){
        int k = i / j;
        return k;
    }
}
```

다음과 같이 divide메소드를 수정

```java
public class ExceptionExam2 {

    public static void main(String[] args) {
        int i = 10;
        int j = 0;
        int k = divide(i, j);
        System.out.println(k);
    }

    public static int divide(int i, int j) throws ArithmeticException{
        int k = i / j;
        return k;
    }
}
```

메소드 선언 뒤에 `throws ArithmeticException` 이 적혀있는 것을 알 수 있습니다. 이렇게 적어놓으면 divide메소드는 **ArithmeticException**이 발생하니 **divide메소드를 호출하는 쪽에서 오류를 처리**하라는 뜻입니다.

```java
package javaStudy;
public class ExceptionExam2 {

    public static void main(String[] args) {
        int i = 10;
        int j = 0;
        try{
            int k = divide(i, j);
            System.out.println(k);
        } catch(ArithmeticException e){
            System.out.println("0으로 나눌수 없습니다.");
        }

    }

    public static int divide(int i, int j) throws ArithmeticException{
        int k = i / j;
        return k;
    }

}
```

- 메서드 뒤에 `throws Exception` 이라고 적으면 모든 예외에 대해서 예외를 던진다.

## 24. 강제로 예외 발생 시키기

`throw != throws`

**throw**는 오류를 떠넘기는 **throws**와 **보통 같이 사용**됩니다.

```java
public class ExceptionExam3 {   
    public static void main(String[] args) {
        int i = 10;
        int j = 0;
        int k = divide(i, j);
        System.out.println(k);

    }       
    public static int divide(int i, int j){
        int k = i / j;
        return k;
    }   
}
```

- divide메소드는 2번째 파라미터의 값이 0일 경우 나누기를 할 때 Exception이 발생한다.

**위의 코드를 에러가 발생하지 않게 수정**

```java
public class ExceptionExam3 {
    public static void main(String[] args) {
        int i = 10;
        int j = 0;
        int k = divide(i, j);
        System.out.println(k);      
    }

    public static int divide(int i, int j){
        if(j == 0){
            System.out.println("2번째 매개변수는 0이면 안됩니다.");
            return 0;
        }
        int k = i / j;
        return k;
    }
}
```

- j가 0일 경우 안된다는 메시지가 출력되도록 수정하고 0을 리턴.
- 이렇게 할 경우 main메소드의 k변수는 0값을 가지게 되고 0을 출력하게 된다.
- 0으로 나눈 결과는 0이 아니다. 0으로 반환하면 더 큰 문제가 발생할수도 있다.

**에러도 발생하지 않고, 올바르지 않은 결과를 리턴하지 않도록 수정**

```java
public class ExceptionExam3 {
    public static void main(String[] args) {
        int i = 10;
        int j = 0;
        int k = divide(i, j);
        System.out.println(k);

    }       
    public static int divide(int i, int j) throws IllegalArgumentException{
        if(j == 0){
            throw new IllegalArgumentException("0으로 나눌 수 없어요.");
        }
        int k = i / j;
        return k;
    }   
}
```

- j가 0일 경우에 new연산자를 통하여 **IllegalArgumentException 객체가 만들어 진다.**
- **new 앞에 throw 는 해당 라인에서 익셉션이 발생한다는 의미**이다.
- 즉 그 줄에서 오류가 발생했다는 것이다. 0으로 나눌수 없습니다. 라는 오류가 발생한것이다.
- **Exception클래스 이름을 보면 아규먼트가 잘못되었기 때문에 발생한 오류라는 것을 알 수 있다.**

**divide 메소드를 호출 한 쪽에서의 오류 처리**

- divide 메소드 뒤에 **throws IllegalArgumentException 은 해당 오류는 divide를 호출한 쪽에서 처리를 해야한다는 것을 의미**한다.

```java
public class ExceptionExam3 {   
    public static void main(String[] args) {
        int i = 10;
        int j = 0;
        try{
            int k = divide(i, j);
            System.out.println(k);
        }catch(IllegalArgumentException e){
            System.out.println(e.toString()); // 0으로 나눌 수 없어요.
        }           
    }

    public static int divide(int i, int j) throws IllegalArgumentException{
        if(j == 0){
            throw new IllegalArgumentException("0으로 나눌 수 없어요.");
        }
        int k = i / j;
        return k;
    }   
}
```

## 25. 사용자 정의 Exception (상속)

원하는 Exception의 이름을 만들기 위해 상속을 사용할 수 있다.

- **Exception 클래스를 상속** 받아 정의한 **checked Exception**
  - **반드시 오류를 처리 해야만 하는 Exception**
  - 예외 처리하지 않으면 **컴파일 오류**를 발생 시킨다.
- **RuntimeException 클래스를 상속** 받아 정의한 **unChecked Exception**
  - 예외 처리하지 않아도 **컴파일 시에는 오류를 발생시키지 않는다.**
  - 런타임시 오류를 발생

**RuntimeException을 상속받은 BizException객체**

```java
public class BizException extends RuntimeException {
    public BizException(String msg){
        super(msg);
    }       
    public BizException(Exception ex){
        super(ex);
    }
}
```

- 생성자 오버로딩을 활용
  - 스트링을 받아서 에러 메세지를 받도록 함
  - 다른 예외를 입력받아서 예외 생성

**BizService**클래스는 업무를 처리하는 메소드를 가지고 있다고 가정한다.

```java
public class BizService {
    public void bizMethod(int i)throws BizException{
        System.out.println("비지니스 로직이 시작합니다.");
        if(i < 0){
            throw new BizException("매개변수 i는 0이상이어야 합니다.");
        }
        System.out.println("비지니스 로직이 종료됩니다.");
    }
}
```

**앞에서 만든 BizService를 이용하는 BizExam클래스**

- 매개변수 값을 -1을 넘길때는 Exception이 발생하기 때문에 try catch블록으로 처리한다.

```java
public class BizExam {  
    public static void main(String[] args) {
        BizService biz = new BizService();
        biz.bizMethod(5);
        try{
            biz.bizMethod(-3);
        }catch(Exception ex){
            ex.printStackTrace();
        }
    }
}
```

**실행결과**

> 비지니스 로직이 시작합니다.
> 비지니스 로직이 종료됩니다.
> 비지니스 로직이 시작합니다.
> javaStudy.BizException: 매개변수 i는 0이상이어야 합니다.
> at javaStudy.BizService.bizMethod(BizService.java:7)
> at javaStudy.BizExam.main(BizExam.java:9)