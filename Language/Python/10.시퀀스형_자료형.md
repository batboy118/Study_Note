# 10. 시퀀스형 자료형

> 파이썬에서는 리스트, 튜플, range, 문자열처럼 값이 연속적으로 이어진 자료형을 시퀀스 자료형(sequence types)라고 부른다.

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./README.md)

---

<!-- TOC -->

- [0. 시퀀스형 자료형](#0-시퀀스형-자료형)
	- [0.0 시퀀스 객체의 공통 기능](#00-시퀀스-객체의-공통-기능)
- [1. 리스트](#1-리스트)
	- [1.1. 리스트 만들기](#11-리스트-만들기)
	- [1.2. 리스트 사용법](#12-리스트-사용법)
		- [1.2.1. list index와 주소](#121-list-index와-주소)
		- [1.2.2. list 연산자](#122-list-연산자)
		- [1.2.3. list 추가](#123-list-추가)
		- [1.2.4. list 수정](#124-list-수정)
		- [1.2.5. list 제거](#125-list-제거)
		- [1.2.6. list 항목 확인](#126-list-항목-확인)
		- [1.2.7 list 내포 기능](#127-list-내포-기능)
- [2. 튜플](#2-튜플)
	- [2.1. 튜플 만들기](#21-튜플-만들기)
	- [2.2. 튜플 사용법](#22-튜플-사용법)
		- [2.2.1. tuple index와 주소](#221-tuple-index와-주소)
		- [1.2.2. tuple 연산자](#122-tuple-연산자)
		- [1.2.3. tuple 항목 확인](#123-tuple-항목-확인)
		- [1.2.4 tuple 내포 기능](#124-tuple-내포-기능)
- [3. 리스트와 튜플로 변수 여러개 만들기](#3-리스트와-튜플로-변수-여러개-만들기)

<!-- /TOC -->

## 0. 시퀀스형 자료형

파이썬에서는 리스트, 튜플, range, 문자열처럼 값이 연속적으로 이어진 자료형을 시퀀스 자료형(sequence types)라고 부른다.

![image](https://user-images.githubusercontent.com/53181778/78213223-8cdbe780-74a1-11ea-9ed0-8a8407e93a95.png)

### 0.0 시퀀스 객체의 공통 기능

- 특정 값이 있는지 확인하기

  - `값 in 시퀀스객체`

- 시퀀스 객체 연결

  - `시퀀스객체1 + 시퀀스객체2`
    - range 객체는 불가능함

- 시퀀스 객체 반복하기

  - `시퀀스객체 * 정수` 또는 `정수 * 시퀀스객체`
    - range 객체는 불가능함

- 길이 구하기

  - `len(시퀀스객체)`

  - 문자열 바이트 수 구하기

    - ```python
      len(문자열.encode('utf-8'))
      ```

- 슬라이스 사용하기

  - `시퀀스객체[시작인덱스:끝인덱스:증가폭]`
    - 마지막 인덱스는 포함하지 않음
    - 증가폭은 생략 가능
  - `시퀀스객체[시작인덱스:]`
    - 시작인덱스부터 마지막 요소까지 가져옴
  - `시퀀스객체[:끝인덱스]`
    - 처음 부터 끝인덱스 전까지의 요소를 가져옴
  - `시퀀스객체[:]`  또는 `시퀀스객체[::]`
    - 전체 요소를 가져옴
  - 다음과 같이 활용 가능
    - `시퀀스객체[:끝인덱스:증가폭]`
    - `시퀀스객체[시작인덱스::증가폭]`
    - `시퀀스객체[::증가폭]`

## 1. 리스트

### 1.1. 리스트 만들기

`리스트 = [값, 값, 값]`

- 대괄호 안에 서로 다른 자료형의 값을 콤마로 구분해 하나 이상 저장할 수 있는 컬렉션 자료형
  - 개별 항목은 0부터 시작하는 인덱스를 이용 해 접근
  - 음의 인덱스로도 접근이 가능하다. -1이면 마지막에 위치한 값이고, -리스트의 크기 이면 처음 값이 된다.
  - 범위 연산자인 `[시작index : 끝index]` 사용 가능 (끝 index는 포함되지 않음)
  - 저장된 항목 변경 가능

- 비어 있는 리스트 만들기

  - `리스트 = []`
  - `리스트 = list()`

- range를 사용하여 리스트 만들기

  - `리스트 = list(range(횟수))`

    ```python
    >>> a = list(range(10))
    >>> a
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    ```

  > 참고) range는 range 객체를 반환한다.
  >
  > ```python
  > >>> range(10)
  > range(0, 10)
  > ```

### 1.2. 리스트 사용법

#### 1.2.1. list index와 주소

- 인덱스 반환 : `list.index(값)`
  - 리스트 내의 특정 값의 index를 반환
  - 리스트 내에 해당 값이 없다면 error
- list의 주소값 확인 : `id(list)`
  - 보통 `hex(id(list))`형태로 16진수 형태로 사용

#### 1.2.2. list 연산자

- list합치기 : `list1 + list2`

  - `+`연산자를 이용하여 리스트를 합칠 수 있다.

- list 반복하기 : `list * 반복 회수`

  - `*`연산자를 이용하여 동일한 리스트를 여러번 반복할 수 있다.

    ```python
    >>> data_list = [1,2,3]
    >>> mul_list = data_list * 3
    >>> mul_list
    [1, 2, 3, 1, 2, 3, 1, 2, 3]
    ```

#### 1.2.3. list 추가

- list에 값 추가하기 : `list.append(값)`
  - 추가하고 싶은 값을 추가할 수 있다.
  - 주의) 값 대신 list를 받으면 리스트 자료형 자체가 하나의 객체로 리스트에 추가 된다.
  - 반환 값은 없다.
- list의 특정 위치에 값 삽입하기 :  `list.insert(index, 값)`
  - index의 위치에 값을 삽입함
- list에 다른 list의 값 추가하기 : `list.extend(list2)`
  - list의 끝에 list2의 원소들을 추가함
  - 주의) append는 값으로 받은 것 자체를 리스트의 하나의 인덱스에 추가하는 것이고, extend는 list의 개별 요소를 추가함

#### 1.2.4. list 수정

- 범위 연산자를 이용해 list 값을 수정 : `list[시작index : 끝index] = [값, ..., 값]`

  - 범위 연산자를 이용해 특정 index들에 값을 변경 시킬 수 있다.

  - 이때, 끝 index는 포함 되지 않는다. ([1:3]이라면, 1,2번 index만 변경)

  - 만약, 범위 보다 값의 개수가 많다면, 전체 리스트의 크기가 늘어난다.

    ```python
    >>> data_list = [10, 20, 30, 40]
    >>> data_list[1:3] = [12, 15, 20]
    >>> data_list
    [10, 12, 15, 20, 40]
    ```

#### 1.2.5. list 제거

- 특정 index 원소 제거(del) : `del list[index]` 또는  `del list[시작index : 끝 index]`
- 특정 index 원소 제거(pop) : `list.pop(index)`
- 특정 값 제거 : `list.remove(값)`
  - 특정 값을 가진 첫 번째 항목을 제거
- 모든 항목 제거 : `list.clear()`
  - 참고)  `del list[:]`를 이용해 모든 항목제거 가능

#### 1.2.6. list 항목 확인

- 특정 값이 리스트에 있는지 확인 : `값 in list`
  - 있으면 True 없으면 False 반환
- 특정 값이 리스트에 없는지 확인 : `값 not in list`
  - 있으면 False 없으면 True 반환
- 특 정값의 개수 반환 : `list.count(값)`

#### 1.2.7 list 내포 기능

- 보통 시퀀스형 자료형의 경우 리터럴 안에서 for문을 이용하면 내포 기능을 사용할 수 있다.

  ```python
  >>> data_list1 = [1, 2, 3, 4, 5]
  >>> data_list2 = [item for item in data_list1]  #data_list1과 동일한 list 생성
  >>> data_list2
  [1, 2, 3, 4, 5]
  ```

- 특정 조건을 만족 하는 내포 기능

  - if문을 넣어 특정 조건에 만족하는 경우만 list에 넣는다.

  ```python
  >>> data_list1 = [1, 2, 3, 4, 5]
  >>> data_list2 = [item for item in data_list1 if item % 2 == 1]  #data_list1에서 홀수만 있는 list 생성
  >>> data_list2
  [1, 3, 5]
  ```

- 중첩구조의 내포 사용

  ```python
  >>> data_list1 = [1, 2, 3, 4, 5]
  >>> data_list2 = [1, 2, 3, 4, 5]
  >>> data_list3 = [x * y for x in data_list1 if x % 2 == 1
                    	    for y in data_list2 if y % 2 == 0]
  [2, 4, 6, 12, 10, 20]
  ```

- 문자열 내포기능 사용

  ```python
  >>> data_str = "HEllO, PYTHon!"
  >>> data_list = [item.lower() for item in data_str]
  >>> data_list
  ['h', 'e', 'l', 'l', 'o', ',', ' ', 'p', 'y', 't', 'h', 'o', 'n', '!']
  ```

## 2. 튜플

### 2.1. 튜플 만들기

`튜플 = (값, 값, 값)` 또는 `튜플 = 값, 값, 값`

- 중괄호 ( ) 안 또는 괄호 없이 서로 다른 자료형의 값을 콤마로 구분해 하나 이상 저장 할 수 있는 컬렉션 자료형
  - 개별 항목은 0부터 시작하는 인덱스를 이용 해 접근
  - 음의 인덱스로도 접근이 가능하다. -1이면 마지막에 위치한 값이고, -튜플의 크기 이면 처음 값이 된다.
  - 범위 연산자인 `[시작index : 끝index]` 사용 가능 (끝 index는 포함되지 않음)
  - 저장된 항목 변경 **불가능**
- 비어 있는 튜플 만들기

- `튜플 = tuple()`

- 요소가 한개인 튜플 만들기

  - `튜플 = 값,`
  - `튜플 = (값,)`

  > `,`를 만드시 써주어야 튜플로 생성 된다. 콤마가 없으면 그냥 하나의 값으로 생성됨

- range를 사용하여 튜플 만들기

  - `리스트 = list(range(횟수))`

    ```python
    >>> a = tuple(range(10))
    >>> a
    (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
    ```

- 튜플, 리스트 형변환

  - 리스트를 튜플로 변환 하기
    - `튜플 = tuple(리스트)`
  - 문자열을 튜플로 변환하기
    - `튜플 = tuple(문자열)`

  - 튜플을 리스트로 변환 하기
    - `리스트= list(튜플)`
  - 문자열을 리스트로 변환하기
    - `리스트= list(문자열)`

### 2.2. 튜플 사용법

#### 2.2.1. tuple index와 주소

- 인덱스 반환 : `tuple.index(값)`
  - 튜플 내의 특정 값의 index를 반환
  - 튜플 내에 해당 값이 없다면 error
- 튜플의 주소값 확인 : `id(tuple)`
  - 보통 `hex(id(tuple))`형태로 16진수 형태로 사용

#### 1.2.2. tuple 연산자

- tuple 합치기 : `tuple1 + tuple2`
  - `+`연산자를 이용하여 튜플을 합친 결과를 반환한다.
- tuple 반복하기 : `tuple * 반복 회수`
  - `*`연산자를 이용하여 동일한 리스트를 여러번 반복한 결과를 반환한다.

#### 1.2.3. tuple 항목 확인

- 특정 값이 튜플에 있는지 확인 : `값 in tuple`
  - 있으면 True 없으면 False 반환
- 특정 값이 튜플에 없는지 확인 : `값 not in tuple`
  - 있으면 False 없으면 True 반환
- 특 정값의 개수 반환 : `tuple.count(값)`

#### 1.2.4 tuple 내포 기능

```python
>>> data1 = (1, 2, 3, 4, 5)
>>> generator1 = (item for item in data1)  #tuple은 ()만 사용하면 generator 타입으로 생성이 된다.
>>> data2 = tuple(generator1) #tuple로 형변환을 해주어야 제대로 된 값이 저장된다.
>>> data2
(1, 2, 3, 4, 5)
```

- 중첩구조의 내포 사용

  ```python
  >>> data1 = (1, 2, 3, 4, 5)
  >>> data2 = (1, 2, 3, 4, 5)
  >>> data3 = tuple(x * y for x in data1 if x % 2 == 1
                    	    for y in data2 if y % 2 == 0)
  (2, 4, 6, 12, 10, 20)
  ```

## 3. 리스트와 튜플로 변수 여러개 만들기

리스트와 튜플을 사용하면 변수 여러 개를 한 번에 만들 수 있다. 이때 변수의 개수와 리스트(튜플)의 요소 개수는 같아야 한다.

```python
>>> a, b, c = [1, 2, 3]
>>> print(a, b, c)
1 2 3
>>> d, e, f = (4, 5, 6)
>>> print(d, e, f)
4 5 6
```

리스트와 튜플 변수로도 변수 여러 개를 만들 수 있다. 다음과 같이 리스트와 튜플의 요소를 변수 여러 개에 할당하는 것을 리스트 언패킹(list unpacking), 튜플 언패킹(tuple unpacking)이라고 한다.

```python
>>> x = [1, 2, 3]
>>> a, b, c = x
>>> print(a, b, c)
1 2 3
>>> y = (4, 5, 6)
>>> d, e, f = y
>>> print(d, e, f)
4 5 6
```

`input().split()`은 리스트를 반환한다. 그래서 리스트 언패킹 형식으로 입력 값을 변수 여러 개에 저장할 수 있다.

```python
>>> input().split()
10 20
['10', '20']
>>> x = input().split()
10 20
>>> a, b = x         # a, b = input().split()과 같음
>>> print(a, b)
10 20
```

그리고 리스트 패킹(list packing)과 튜플 패킹(tuple packing)은 변수에 리스트 또는 튜플을 할당하는 과정을 뜻한다.

```python
a = [1, 2, 3]    # 리스트 패킹
b = (1, 2, 3)    # 튜플 패킹
c = 1, 2, 3      # 튜플 패킹
```
