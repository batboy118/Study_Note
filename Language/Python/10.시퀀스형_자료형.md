# 10. 시퀀스형 자료형

> 파이썬에서는 리스트, 튜플, range, 문자열처럼 값이 연속적으로 이어진 자료형을 시퀀스 자료형(sequence types)라고 부른다.

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./README.md)

---

<!-- TOC -->

- [0. 시퀀스형 자료형](#0-시퀀스형-자료형)
	- [0.0 시퀀스 객체의 공통 기능](#00-시퀀스-객체의-공통-기능)
- [1. 리스트](#1-리스트)
	- [1.1. 리스트 만들기](#11-리스트-만들기)
	- [1.2. 리스트 사용법](#12-리스트-사용법)
		- [1.2.1. list index와 주소](#121-list-index와-주소)
		- [1.2.2. list 연산자](#122-list-연산자)
		- [1.2.3. list 추가](#123-list-추가)
		- [1.2.4. list 수정](#124-list-수정)
		- [1.2.5. list 제거](#125-list-제거)
		- [1.2.6. list 항목 확인](#126-list-항목-확인)
		- [1.2.7 list 내포 기능](#127-list-내포-기능)
		- [1.2.8. list로 스택과 큐 만들기](#128-list로-스택과-큐-만들기)
		- [1.2.9. list 정렬](#129-list-정렬)
		- [1.2.10. list가 비어 있는지 확인하기](#1210-list가-비어-있는지-확인하기)
		- [1.2.11. list의 할당과 복사](#1211-list의-할당과-복사)
		- [1.2.12. 인덱스와 요소를 함께 출력하기](#1212-인덱스와-요소를-함께-출력하기)
	- [1.3. 2차원 리스트](#13-2차원-리스트)
		- [1.3.1. 생성](#131-생성)
		- [1.3.2. 접근](#132-접근)
		- [1.3.3. 톱니형 리스트](#133-톱니형-리스트)
		- [1.3.4. 알아보기 쉽게 출력하기](#134-알아보기-쉽게-출력하기)
		- [1.3.5. 반복문으로 모든 요소 출력하기](#135-반복문으로-모든-요소-출력하기)
		- [1.3.6. 리스트 표현식으로 2차원 리스트 만들기](#136-리스트-표현식으로-2차원-리스트-만들기)
		- [1.3.7. 2차원 리스트 정렬하기](#137-2차원-리스트-정렬하기)
- [2. 튜플](#2-튜플)
	- [2.1. 튜플 만들기](#21-튜플-만들기)
	- [2.2. 튜플 사용법](#22-튜플-사용법)
		- [2.2.1. tuple index와 주소](#221-tuple-index와-주소)
		- [1.2.2. tuple 연산자](#122-tuple-연산자)
		- [1.2.3. tuple 항목 확인](#123-tuple-항목-확인)
		- [1.2.4 tuple 내포 기능](#124-tuple-내포-기능)
	- [2.3. 2차원 튜플](#23-2차원-튜플)
- [3. 리스트와 튜플로 변수 여러개 만들기](#3-리스트와-튜플로-변수-여러개-만들기)

<!-- /TOC -->

## 0. 시퀀스형 자료형

파이썬에서는 리스트, 튜플, range, 문자열처럼 값이 연속적으로 이어진 자료형을 시퀀스 자료형(sequence types)라고 부른다.

![image](https://user-images.githubusercontent.com/53181778/78213223-8cdbe780-74a1-11ea-9ed0-8a8407e93a95.png)

### 0.0 시퀀스 객체의 공통 기능

- 특정 값이 있는지 확인하기

  - `값 in 시퀀스객체`

- 시퀀스 객체 연결

  - `시퀀스객체1 + 시퀀스객체2`
    - range 객체는 불가능함

- 시퀀스 객체 반복하기

  - `시퀀스객체 * 정수` 또는 `정수 * 시퀀스객체`
    - range 객체는 불가능함

- 길이 구하기

  - `len(시퀀스객체)`

  - 문자열 바이트 수 구하기

    - ```python
      len(문자열.encode('utf-8'))
      ```

- 슬라이스 사용하기

  - `시퀀스객체[시작인덱스:끝인덱스:증가폭]`
    - 마지막 인덱스는 포함하지 않음
    - 증가폭은 생략 가능
  - `시퀀스객체[시작인덱스:]`
    - 시작인덱스부터 마지막 요소까지 가져옴
  - `시퀀스객체[:끝인덱스]`
    - 처음 부터 끝인덱스 전까지의 요소를 가져옴
  - `시퀀스객체[:]`  또는 `시퀀스객체[::]`
    - 전체 요소를 가져옴
  - 다음과 같이 활용 가능
    - `시퀀스객체[:끝인덱스:증가폭]`
    - `시퀀스객체[시작인덱스::증가폭]`
    - `시퀀스객체[::증가폭]`

## 1. 리스트

### 1.1. 리스트 만들기

`리스트 = [값, 값, 값]`

- 대괄호 안에 서로 다른 자료형의 값을 콤마로 구분해 하나 이상 저장할 수 있는 컬렉션 자료형
  - 개별 항목은 0부터 시작하는 인덱스를 이용 해 접근
  - 음의 인덱스로도 접근이 가능하다. -1이면 마지막에 위치한 값이고, -리스트의 크기 이면 처음 값이 된다.
  - 범위 연산자인 `[시작index : 끝index]` 사용 가능 (끝 index는 포함되지 않음)
  - 저장된 항목 변경 가능

- 비어 있는 리스트 만들기

  - `리스트 = []`
  - `리스트 = list()`

- range를 사용하여 리스트 만들기

  - `리스트 = list(range(횟수))`

    ```python
    >>> a = list(range(10))
    >>> a
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    ```

  > 참고) range는 range 객체를 반환한다.
  >
  > ```python
  > >>> range(10)
  > range(0, 10)
  > ```

### 1.2. 리스트 사용법

#### 1.2.1. list index와 주소

- 인덱스 반환 : `list.index(값)`
  - 리스트 내의 특정 값의 index를 반환
  - 리스트 내에 해당 값이 없다면 error
- list의 주소값 확인 : `id(list)`
  - 보통 `hex(id(list))`형태로 16진수 형태로 사용

#### 1.2.2. list 연산자

- list합치기 : `list1 + list2`

  - `+`연산자를 이용하여 리스트를 합칠 수 있다.

- list 반복하기 : `list * 반복 회수`

  - `*`연산자를 이용하여 동일한 리스트를 여러번 반복할 수 있다.

    ```python
    >>> data_list = [1,2,3]
    >>> mul_list = data_list * 3
    >>> mul_list
    [1, 2, 3, 1, 2, 3, 1, 2, 3]
    ```

#### 1.2.3. list 추가

- list에 값 추가하기 : `list.append(값)`
  - 추가하고 싶은 값을 추가할 수 있다.
  - 주의) 값 대신 list를 받으면 리스트 자료형 자체가 하나의 객체로 리스트에 추가 된다.
  - 반환 값은 없다.
- list의 특정 위치에 값 삽입하기 :  `list.insert(index, 값)`
  - index의 위치에 값을 삽입함
- list에 다른 list의 값 추가하기 : `list.extend(list2)`
  - list의 끝에 list2의 원소들을 추가함
  - 주의) append는 값으로 받은 것 자체를 리스트의 하나의 인덱스에 추가하는 것이고, extend는 list의 개별 요소를 추가함

#### 1.2.4. list 수정

- 범위 연산자를 이용해 list 값을 수정 : `list[시작index : 끝index] = [값, ..., 값]`

  - 범위 연산자를 이용해 특정 index들에 값을 변경 시킬 수 있다.

  - 이때, 끝 index는 포함 되지 않는다. ([1:3]이라면, 1,2번 index만 변경)

  - 만약, 범위 보다 값의 개수가 많다면, 전체 리스트의 크기가 늘어난다.

    ```python
    >>> data_list = [10, 20, 30, 40]
    >>> data_list[1:3] = [12, 15, 20]
    >>> data_list
    [10, 12, 15, 20, 40]
    ```

#### 1.2.5. list 제거

- 특정 index 원소 제거(del) : `del list[index]` 또는  `del list[시작index : 끝 index]`
- 특정 index 원소 제거(pop) : `list.pop(index)`
  - 해당 index의 값을 제거 후 반환
  - index없이 사용하면 마지막 값을 제거 후 반환
- 특정 값 제거 : `list.remove(값)`
  - 특정 값을 가진 첫 번째 항목을 제거
- 모든 항목 제거 : `list.clear()`
  - 참고)  `del list[:]`를 이용해 모든 항목제거 가능

#### 1.2.6. list 항목 확인

- 특정 값이 리스트에 있는지 확인 : `값 in list`
  - 있으면 True 없으면 False 반환
- 특정 값이 리스트에 없는지 확인 : `값 not in list`
  - 있으면 False 없으면 True 반환
- 특정 값의 개수 반환 : `list.count(값)`

#### 1.2.7 list 내포 기능

- 보통 시퀀스형 자료형의 경우 리터럴 안에서 for문을 이용하면 내포 기능을 사용할 수 있다.

  ```python
  >>> data_list1 = [1, 2, 3, 4, 5]
  >>> data_list2 = [item for item in data_list1]  #data_list1과 동일한 list 생성
  >>> data_list2
  [1, 2, 3, 4, 5]
  ```

- 특정 조건을 만족 하는 내포 기능

  - if문을 넣어 특정 조건에 만족하는 경우만 list에 넣는다.

  ```python
  >>> data_list1 = [1, 2, 3, 4, 5]
  >>> data_list2 = [item for item in data_list1 if item % 2 == 1]  #data_list1에서 홀수만 있는 list 생성
  >>> data_list2
  [1, 3, 5]
  ```

- 중첩구조의 내포 사용

  ```python
  >>> data_list1 = [1, 2, 3, 4, 5]
  >>> data_list2 = [1, 2, 3, 4, 5]
  >>> data_list3 = [x * y for x in data_list1 if x % 2 == 1
                    	    for y in data_list2 if y % 2 == 0]
  [2, 4, 6, 12, 10, 20]
  ```

- 문자열 내포기능 사용

  ```python
  >>> data_str = "HEllO, PYTHon!"
  >>> data_list = [item.lower() for item in data_str]
  >>> data_list
  ['h', 'e', 'l', 'l', 'o', ',', ' ', 'p', 'y', 't', 'h', 'o', 'n', '!']
  ```

#### 1.2.8. list로 스택과 큐 만들기

지금까지 알아본 리스트의 메서드로 스택(stack)과 큐(queue)를 만들 수 있다. 다음과 같이 `append`와 `pop()`을 호출을 이용하여 스택으로 사용 할 수 있다.

반대로, `pop()` 대신 `pop(0)`을 사용하면 큐가 된다.

물론 append(), pop(0)이 아닌 insert(0, 요소), pop()을 사용해서 추가/삭제 방향을 반대로 해도 큐로 사용할 수 있다.

파이썬에서 스택은 리스트를 그대로 활용해도 되지만, 큐는 좀 더 효율적으로 사용할 수 있도록 **덱(deque, double ended queue)**이라는 자료형을 제공한다. 덱은 양쪽 끝에서 추가/삭제가 가능한 자료 구조입니다.

deque(반복 가능한 객체)

```python
>>> from collections import deque    # collections 모듈에서 deque를 가져옴
>>> a = deque([10, 20, 30])
>>> a
deque([10, 20, 30])
>>> a.append(500)    # 덱의 오른쪽에 500 추가
>>> a
deque([10, 20, 30, 500])
>>> a.popleft()     # 덱의 왼쪽 요소 하나 삭제
10
>>> a
deque([20, 30, 500])
```

deque의 `append`는 덱의 **오른쪽에 요소를 추가**하고, `popleft`는 **덱의 왼쪽 요소를 삭제**한다. 반대로 `appendleft`는 덱의 **왼쪽에 요소를 추가**하고, `pop`으로 **덱의 오른쪽 요소를 삭제**한다.

#### 1.2.9. list 정렬

- 리스트 뒤집기

  - `리스트.reverse()` : 리스트에서 요소의 순서를 반대로 뒤집는다.

    ```python
    >>> a = [10, 20, 30, 15, 20, 40]
    >>> a.reverse()
    >>> a
    [40, 20, 15, 30, 20, 10]
    ```

- 오름차순 정렬

  - `sort()` 또는 `sort(reverse=False)` : 리스트의 값을 작은 순서대로 정렬(오름차순)

    ```python
    >>> a = [10, 20, 30, 15, 20, 40]
    >>> a.sort()
    >>> a
    [10, 15, 20, 20, 30, 40]
    ```

- 내림 차순 정렬

  - `sort(reverse=True)`: 리스트의 값을 큰 순서대로 정렬(내림차순)

> 참고 | sort 메서드와 sorted 함수
>
> 파이썬은 리스트의 sort 메서드뿐만 아니라 내장 함수 sorted도 제공한다. sort와        sorted 모두 정렬을 해주는 함수지만, 약간의 차이점이 있다. sort는 메서드를 사용한 리스트를 변경하지만, sorted 함수는 정렬된 새 리스트를 생성하여 반환하다.
>
> ```python
> >>> a = [10, 20, 30, 15, 20, 40]
> >>> a.sort()    # a의 내용을 변경하여 정렬
> >>> a
> [10, 15, 20, 20, 30, 40]
> >>> b = [10, 20, 30, 15, 20, 40]
> >>> sorted(b)    # 정렬된 새 리스트를 생성
> [10, 15, 20, 20, 30, 40]
> ```

#### 1.2.10. list가 비어 있는지 확인하기

- len()함수 사용법

```python
if not len(seq):    # 리스트가 비어 있으면 True
if len(seq):        # 리스트에 요소가 있으면 True
```

- 객체 자체 활용

```python
if not seq:    # 리스트가 비어 있으면 True
if seq:        # 리스트에 내용이 있으면 True
```

리스트가 비어 있는지 확인하는 방법은 리스트의 마지막 요소에 접근할 때 유용하게 사용할 수 있다. 리스트의 마지막 요소에 접근할 때는 인덱스를 -1로 지정하여 접근하는데 만약 비어있다면 에러가 발생하기 때문에, 리스트가 비어있는 것을 확인해야 한다.

```python
seq = []
if seq:               # 리스트에 요소가 있는지 확인
    print(seq[-1])    # 요소가 있을 때만 마지막 요소를 가져옴
```

#### 1.2.11. list의 할당과 복사

할당과 복사는 다르다. 할당은 객체 자체를 할당하기 때문에 같은 객체를 참조하게 된다. 복사는 값을 복사하기 때문에 다른 객체를 가리키는 개념이다.

- 할당

  ```python
  >>> a = [0, 0, 0, 0, 0]
  >>> b = a
  ```

  b = a와 같이 리스트를 다른 변수에 할당하면 리스트는 두 개가 될 것 같지만 실제로는 리스트가 한 개다.

- a와 b를 is 연산자로 비교해보면 True가 나온다. 즉, 변수 이름만 다를 뿐 리스트 a와 b는 같은 객체다.

  ```python
  >>> a is b
  True
  ```

  a와 b는 같으므로 b[2] = 99와 같이 리스트 b의 요소를 변경하면 리스트 a와 b에 모두 반영된다.

  ```python
  >>> b[2] = 99
  >>> a
  [0, 0, 99, 0, 0]
  >>> b
  [0, 0, 99, 0, 0]
  ```

- 복사하기

  리스트 a와 b를 완전히 두 개로 만들려면 copy 메서드로 모든 요소를 복사해야 한다.

  ```python
  >>> a = [0, 0, 0, 0, 0]
  >>> b = a.copy()
  ```

  `b = a.copy()`와 같이 copy를 사용한 뒤 b에 할당해주면 리스트 a의 요소가 모두 b에 복사된다.

  a와 b를 is 연산자로 비교해보면 False가 나온다. 즉, 두 리스트는 다른 이다. 그러나 복사된 요소는 모두 같으므로 ==로 비교하면 True가 나오게 된다.

  ```python
  >>> a is b
  False
  >>> a == b
  True
  ```

#### 1.2.12. 인덱스와 요소를 함께 출력하기

- **for** **인덱스, 요소 in enumerate(리스트):**

```python
>>> a = [38, 21, 53, 62, 19]
>>> for index, value in enumerate(a):
...     print(index, value)
...
0 38
1 21
2 53
3 62
4 19
```

- **for** **인덱스, 요소 in enumerate(리스트, start=숫자):**

  enumerate에 start를 지정해주면 원하는 숫자 부터 설정할 수 있다.

  enumerate(a, start=1)처럼 start에 1을 지정하여 인덱스가 1부터 시작하도록 만들었습니다. 이 코드는 enumerate(a, 1)과 같이 줄여 쓸 수도 있다.

```python
>>> for index, value in enumerate(a, start=1):
...     print(index, value)
...
1 38
2 21
3 53
4 62
5 19
```

> 참고 | for 반복문에서 인덱스로 요소를 출력하기
>
> range에 len으로 리스트의 길이(요소 개수)를 구해서 넣어주면 인덱스를 순서대로 만들어준다.  따라서 a[i]와 같이 리스트에 인덱스를 지정하여 값을 가져올 수 있다.
>
> ```python
> >>> a = [38, 21, 53, 62, 19]
> >>> for i in range(len(a)):
> ...     print(a[i])
> ...
> 38
> 21
> 53
> 62
> 19
> ```

### 1.3. 2차원 리스트

#### 1.3.1. 생성

`리스트 = [[값, 값], [값, 값], [값, 값]]`

```python
>>> a = [[10, 20], [30, 40], [50, 60]]
>>> a
[[10, 20], [30, 40], [50, 60]]
```

#### 1.3.2. 접근

`리스트[세로인덱스][가로인덱스]`

`리스트[세로인덱스][가로인덱스] = 값`

```python
>>> a = [[10, 20], [30, 40], [50, 60]]
>>> a[0] [0]            # 세로 인덱스 0, 가로 인덱스 0인 요소 출력
10
>>> a[1][1]           # 세로 인덱스 1, 가로 인덱스 1인 요소 출력
40
>>> a[2][1]           # 세로 인덱스 2, 가로 인덱스 0인 요소 출력
60
>>> a[0][1] = 1000    # 세로 인덱스 0, 가로 인덱스 1인 요소에 값 할당
>>> a[0][1]
1000
```

#### 1.3.3. 톱니형 리스트

```python
a = [[10, 20],
     [500, 600, 700],
     [9],
     [30, 40],
     [8],
     [800, 900, 1000]]
```

리스트 a는 가로 크기(행의 요소 개수) 가 제각각이다. 이런 리스트는 요소가 배치된 모양이 톱니처럼 생겨 톱니형 리스트라고 부른다.

톱니형 리스트는 다음과 같이 append 메서드 등을 사용하여 동적으로 생성할 수도 있다.

```python
>>> a = []
>>> a.append([])
>>> a[0].append(10)
>>> a[0].append(20)
>>> a.append([])
>>> a[1].append(500)
>>> a[1].append(600)
>>> a[1].append(700)
>>> a
[[10, 20], [500, 600, 700]]
```

#### 1.3.4. 알아보기 쉽게 출력하기

2차원 리스트를 출력하면 한 줄로 쭉 붙어서 출력된다.

```python
>>> a = [[10, 20], [30, 40], [50, 60]]
>>> a
[[10, 20], [30, 40], [50, 60]]
```

만약 2차원 리스트의 사각형 구조를 유지하도록 출력하려면 **pprint** 모듈의 **pprint** 함수를 사용하면 된다.

```python
>>> from pprint import pprint
>>> pprint(a, indent=4, width=20)
[   [10, 20],
    [30, 40],
    [50, 60]]
```

**indent**는 들여쓰기 칸 수, **width**는 가로 폭이다.

#### 1.3.5. 반복문으로 모든 요소 출력하기

-  for문 한번만 사용하는 법

  ```python
  >>> a = [[10, 20], [30, 40], [50, 60]]
  >>> for x, y in a:    # 리스트의 가로 한 줄(안쪽 리스트)에서 요소 두 개를 꺼냄
  ...     print(x, y)
  ...
  10 20
  30 40
  50 60
  ```

- for문 두번 쓰는 법

  ```python
  a = [[10, 20], [30, 40], [50, 60]]

  for i in a:        # a에서 안쪽 리스트를 꺼냄
      for j in i:    # 안쪽 리스트에서 요소를 하나씩 꺼냄
          print(j, end=' ')
      print()
  ```

  - 결과

    > 10 20
    > 30 40
    > 50 60

- for와 range 사용

  ```python
  a = [[10, 20], [30, 40], [50, 60]]

  for i in range(len(a)):            # 세로 크기
      for j in range(len(a[i])):     # 가로 크기
          print(a[i][j], end=' ')
      print()
  ```

  - 결과

  > 10 20
  > 30 40
  > 50 60

- while 반복문을 한 번 사용하기

  ```python
  a = [[10, 20], [30, 40], [50, 60]]

  i = 0
  while i < len(a):    # 반복할 때 리스트의 크기 활용(세로 크기)
      x, y = a[i]      # 요소 두 개를 한꺼번에 가져오기
      print(x, y)
      i += 1           # 인덱스를 1 증가시킴
  ```

  - 결과

  > 10 20
  > 30 40
  > 50 60

- while 반복문을 두 번 사용하기

  ```python
  a = [[10, 20], [30, 40], [50, 60]]

  i = 0
  while i < len(a):           # 세로 크기
      j = 0
      while j < len(a[i]):    # 가로 크기
          print(a[i][j], end=' ')
          j += 1              # 가로 인덱스를 1 증가시킴
      print()
      i += 1                  # 세로 인덱스를 1 증가시킴
  ```

  - 결과

  > 10 20
  > 30 40
  > 50 60

#### 1.3.6. 리스트 표현식으로 2차원 리스트 만들기

내포를 두번 사용해서 만들어 줄 수 있다.

```python
>>> a = [[0 for j in range(2)] for i in range(3)]
>>> a
[[0, 0], [0, 0], [0, 0]]
```

> 참고 |  for 반복문을 한 번만 사용하고 싶다면 다음과 같이 식 부분에서 리스트 자체를 곱해주면 된다.
>
> ```python
> >>> a = [[0] * 2 for i in range(3)]
> >>> a
> [[0, 0], [0, 0], [0, 0]]
> ```

#### 1.3.7. 2차원 리스트 정렬하기

2차원 리스트를 정렬할 때는 sorted 함수를 사용한다 .

`sorted(반복가능한객체, key=정렬함수, reverse=True 또는 False)`

```python
students = [
    ['john', 'C', 19],
    ['maria', 'A', 25],
    ['andrew', 'B', 7]
]

print(sorted(students, key=lambda student: student[1]))  # 안쪽 리스트의 인덱스 1을 기준으로 정렬
print(sorted(students, key=lambda student: student[2]))  # 안쪽 리스트의 인덱스 2를 기준으로 정렬
```

- 결과

```
[['maria', 'A', 25], ['andrew', 'B', 7], ['john', 'C', 19]]
[['andrew', 'B', 7], ['john', 'C', 19], ['maria', 'A', 25]]
```

## 2. 튜플

### 2.1. 튜플 만들기

`튜플 = (값, 값, 값)` 또는 `튜플 = 값, 값, 값`

- 중괄호 ( ) 안 또는 괄호 없이 서로 다른 자료형의 값을 콤마로 구분해 하나 이상 저장 할 수 있는 컬렉션 자료형
  - 개별 항목은 0부터 시작하는 인덱스를 이용 해 접근
  - 음의 인덱스로도 접근이 가능하다. -1이면 마지막에 위치한 값이고, -튜플의 크기 이면 처음 값이 된다.
  - 범위 연산자인 `[시작index : 끝index]` 사용 가능 (끝 index는 포함되지 않음)
  - 저장된 항목 변경 **불가능**
- 비어 있는 튜플 만들기

- `튜플 = tuple()`

- 요소가 한개인 튜플 만들기

  - `튜플 = 값,`
  - `튜플 = (값,)`

  > `,`를 만드시 써주어야 튜플로 생성 된다. 콤마가 없으면 그냥 하나의 값으로 생성됨

- range를 사용하여 튜플 만들기

  - `리스트 = list(range(횟수))`

    ```python
    >>> a = tuple(range(10))
    >>> a
    (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
    ```

- 튜플, 리스트 형변환

  - 리스트를 튜플로 변환 하기
    - `튜플 = tuple(리스트)`
  - 문자열을 튜플로 변환하기
    - `튜플 = tuple(문자열)`

  - 튜플을 리스트로 변환 하기
    - `리스트= list(튜플)`
  - 문자열을 리스트로 변환하기
    - `리스트= list(문자열)`

### 2.2. 튜플 사용법

#### 2.2.1. tuple index와 주소

- 인덱스 반환 : `tuple.index(값)`
  - 튜플 내의 특정 값의 index를 반환
  - 튜플 내에 해당 값이 없다면 error
- 튜플의 주소값 확인 : `id(tuple)`
  - 보통 `hex(id(tuple))`형태로 16진수 형태로 사용

#### 1.2.2. tuple 연산자

- tuple 합치기 : `tuple1 + tuple2`
  - `+`연산자를 이용하여 튜플을 합친 결과를 반환한다.
- tuple 반복하기 : `tuple * 반복 회수`
  - `*`연산자를 이용하여 동일한 리스트를 여러번 반복한 결과를 반환한다.

#### 1.2.3. tuple 항목 확인

- 특정 값이 튜플에 있는지 확인 : `값 in tuple`
  - 있으면 True 없으면 False 반환
- 특정 값이 튜플에 없는지 확인 : `값 not in tuple`
  - 있으면 False 없으면 True 반환
- 특 정값의 개수 반환 : `tuple.count(값)`

#### 1.2.4 tuple 내포 기능

```python
>>> data1 = (1, 2, 3, 4, 5)
>>> generator1 = (item for item in data1)  #tuple은 ()만 사용하면 generator 타입으로 생성이 된다.
>>> data2 = tuple(generator1) #tuple로 형변환을 해주어야 제대로 된 값이 저장된다.
>>> data2
(1, 2, 3, 4, 5)
```

- 중첩구조의 내포 사용

  ```python
  >>> data1 = (1, 2, 3, 4, 5)
  >>> data2 = (1, 2, 3, 4, 5)
  >>> data3 = tuple(x * y for x in data1 if x % 2 == 1
                    	    for y in data2 if y % 2 == 0)
  (2, 4, 6, 12, 10, 20)
  ```

### 2.3. 2차원 튜플

- 2차원 튜플

  `튜플 = ((값, 값), (값, 값), (값, 값))`

  `튜플 = ([값, 값], [값, 값], [값, 값])`

  `리스트 = [(값, 값), (값, 값), (값, 값)]`

  ```python
  a = ((10, 20), (30, 40), (50, 60))    # 튜플 안에 튜플을 넣은 2차원 튜플
  b = ([10, 20], [30, 40], [50, 60])    # 튜플 안에 리스트를 넣음
  c = [(10, 20), (30, 40), (50, 60)]    # 리스트 안에 튜플을 넣음
  ```

  튜플은 내용을 변경할 수 없으므로 a는 안쪽과 바깥쪽 모두 요소를 변경할 수 없고, b는 안쪽 리스트만 요소를 변경할 수 있고, c는 바깥쪽 리스트만 요소를 변경할 수 있다.

  ```python
  a[0][0] = 500        # 안쪽 튜플은 변경할 수 없음. TypeError 발생
  a[0] = (500, 600)    # 바깥쪽 튜플은 변경할 수 없음. TypeError 발생
  b[0][0] = 500        # 안쪽 리스트는 변경할 수 있음
  b[0] = (500, 600)    # 바깥쪽 튜플은 변경할 수 없음. TypeError 발생
  c[0][0] = 500        # 안쪽 튜플은 변경할 수 없음. TypeError 발생
  c[0] = (500, 600)    # 바깥쪽 리스트는 변경할 수 있음
  ```

## 3. 리스트와 튜플로 변수 여러개 만들기

리스트와 튜플을 사용하면 변수 여러 개를 한 번에 만들 수 있다. 이때 변수의 개수와 리스트(튜플)의 요소 개수는 같아야 한다.

```python
>>> a, b, c = [1, 2, 3]
>>> print(a, b, c)
1 2 3
>>> d, e, f = (4, 5, 6)
>>> print(d, e, f)
4 5 6
```

리스트와 튜플 변수로도 변수 여러 개를 만들 수 있다. 다음과 같이 리스트와 튜플의 요소를 변수 여러 개에 할당하는 것을 리스트 언패킹(list unpacking), 튜플 언패킹(tuple unpacking)이라고 한다.

```python
>>> x = [1, 2, 3]
>>> a, b, c = x
>>> print(a, b, c)
1 2 3
>>> y = (4, 5, 6)
>>> d, e, f = y
>>> print(d, e, f)
4 5 6
```

`input().split()`은 리스트를 반환한다. 그래서 리스트 언패킹 형식으로 입력 값을 변수 여러 개에 저장할 수 있다.

```python
>>> input().split()
10 20
['10', '20']
>>> x = input().split()
10 20
>>> a, b = x         # a, b = input().split()과 같음
>>> print(a, b)
10 20
```

그리고 리스트 패킹(list packing)과 튜플 패킹(tuple packing)은 변수에 리스트 또는 튜플을 할당하는 과정을 뜻한다.

```python
a = [1, 2, 3]    # 리스트 패킹
b = (1, 2, 3)    # 튜플 패킹
c = 1, 2, 3      # 튜플 패킹
```
