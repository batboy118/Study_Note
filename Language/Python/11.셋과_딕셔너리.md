# 11. 셋과 딕셔너리

> 파이썬 자료구조 중 셋과 딕셔너리에 대해서 학습합니다.

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./README.md)

---

<!-- TOC -->

- [1. 셋](#1-셋)
	- [1.1. 셋 만들기](#11-셋-만들기)
	- [1.2. 셋 사용법](#12-셋-사용법)
		- [1.2.1. 셋의 기본 연산](#121-셋의-기본-연산)
		- [1.2.2. 셋의 항목 추가](#122-셋의-항목-추가)
		- [1.2.3. 셋의 항목 제거](#123-셋의-항목-제거)
		- [1.2.4. 셋의 항목 확인](#124-셋의-항목-확인)
		- [1.2.5. 부분 집합의 포함 관계](#125-부분-집합의-포함-관계)
		- [1.2.5. for 문을 이용한 셋 항목 접근](#125-for-문을-이용한-셋-항목-접근)
		- [1.2.6. 셋 내포의 특징](#126-셋-내포의-특징)
- [2. 딕셔너리](#2-딕셔너리)
	- [2.1. 딕셔너리 만들기](#21-딕셔너리-만들기)
		- [2.1.1. dict()를 이용한 생성](#211-dict를-이용한-생성)
		- [2.1.2. dict.fromkeys()를 이용한 생성](#212-dictfromkeys를-이용한-생성)
		- [2.1.3. defaultdict()를 이용한 생성](#213-defaultdict를-이용한-생성)
	- [2.2. 딕셔너리 사용법](#22-딕셔너리-사용법)
		- [2.2.1. 딕셔너리 키에 접근하기](#221-딕셔너리-키에-접근하기)
		- [2.2.1. 딕셔너리의 키에 값 할당하기](#221-딕셔너리의-키에-값-할당하기)
		- [2.2.2. 딕셔너리 항목 추가](#222-딕셔너리-항목-추가)
		- [2.2.3. 딕셔너리 항목 확인](#223-딕셔너리-항목-확인)
		- [2.2.4. 딕셔너리 항목 삭제하기](#224-딕셔너리-항목-삭제하기)
		- [2.2.5. 딕셔너리 키, 값, 항목 읽기](#225-딕셔너리-키-값-항목-읽기)
	- [2.3. 반복문으로 딕셔너리의 키-값 출력하기](#23-반복문으로-딕셔너리의-키-값-출력하기)
	- [2.4. 딕셔너리 표현식 사용하기](#24-딕셔너리-표현식-사용하기)

<!-- /TOC -->

## 1. 셋

### 1.1. 셋 만들기

중복되지 않는 데이터를 만들기 위해 사용하는 자료구조

- `{ }` 안에 서로 다른 자료형의 유일한 값을 `콤마(,)로 구분`해 하나 이상 저장할 수 있는 컬렉션 자료형 중 하나

- 인덱스 없음, 순서의 개념 없음, 중복 허용하지 않음

- range 함수를 이용하여 set 생성 가능

  ```python
  data = set(range(10,21,2))
  ```

- 문자열을 set()함수를 사용하여 변환하면 개별 문자를 원소로 가지게 됨

  ```python
  data = set("A B c d d")
  data
  ```

  - 결과 : `{' ', A', 'B', 'c', 'd'}`

### 1.2. 셋 사용법

#### 1.2.1. 셋의 기본 연산

- 교집합 :

  1. `&`

     ```python
     data1 = {1,2,3}
     data2 = {2,3,4}
     data3 = data1 & data2
     data3
     ```

     - 결과 : `{2, 3}`

  2. `set1.intersection(set2)`

     ```python
     data1 = {1,2,3}
     data2 = {2,3,4}
     data3 = data1.intersection(data2)
     data3
     ```

     - 결과 : `{2, 3}`

- 합집합 : 중복 원소는 한번만 생성 됨

  1. `|`

     ```python
     data1 = {1,2,3}
     data2 = {2,3,4}
     data3 = data1 | data2
     data3
     ```

     - 결과 : `{1, 2, 3, 4}`

  2. `set1.union(set2)`

     ```python
     data1 = {1,2,3}
     data2 = {2,3,4}
     data3 = data1.union(data2)
     data3
     ```

     - 결과 : `{1, 2, 3, 4}`

- 차집함 :

  1. `-`

     ```python
     data1 = {1,2,3}
     data2 = {2,3,4}
     data3 = data1 - data2
     data3
     ```

     - 결과 : `{1}`

  2. `set1.difference(set2)`

     ```python
     data1 = {1,2,3}
     data2 = {2,3,4}
     data3 = data1.difference(data2)
     data3
     ```

     - 결과 : `{1}`

#### 1.2.2. 셋의 항목 추가

-  하나의 항목 추가 : `set.add(값)`

  ```python
  data = {1, 2, 3}
  data.add(4)
  print(data)
  ```

  - 결과 : `{1, 2, 3, 4}`

- 셋을 이용한 여러개 항목 추가 : `set1.update(set2)`

  ```python
  data = {1, 2, 3}
  data.update({3, 4, 5})
  print(data)
  ```

  - 결과 : `{1, 2, 3, 4, 5}`

#### 1.2.3. 셋의 항목 제거

-  특정 원소 제거 : `set.remove(값)`
  -  없을 때 **에러 메시지**를 출력
- 특정 원소 제거 : `set.discard(값)`
  - 없을 때 그냥 무시
- 임의의 값을 반환하며 삭제 : `set.pop()`
- 모든 항목 제거 : `set.clear()`

#### 1.2.4. 셋의 항목 확인

- `값 in set` : 셋객체에 해당 값이 있으면 true 반환, 없으면 false 반환
- `값 not in set` : 셋객체에 해당 값이 없으면 true 반환, 있으면 false 반환

#### 1.2.5. 부분 집합의 포함 관계

- `set1.issuperset(set2)`

  - set1이 set2 전체를 포함하고 있으면 True, 아니면 False를 반환

  ![image](https://user-images.githubusercontent.com/53181778/78338105-ae140500-7581-11ea-9534-f7213961e51e.png)

- `set1.issubset(set2)`

  - set1이 set2에 포함되면 True, 아니면 False를 반환

    ![image](https://user-images.githubusercontent.com/53181778/78338136-bb30f400-7581-11ea-8b0b-820e129dc51e.png)

#### 1.2.5. for 문을 이용한 셋 항목 접근

```python
data_set = set(range(0, 11, 2))

for item in data_set:
    print("{0}".format(item), end=" ")
```

- 결과 : 0 2 4 6 8 10

#### 1.2.6. 셋 내포의 특징

```python
data1 = {1, 2, 3, 4, 5}
data2 = {item for item in data1 if item % 2 == 1}
print(data2)
```

- 결과 : {1, 3, 5}

```python
data1 = {1, 2, 3, 4, 5}
data2 = {1, 2, 3, 4, 5}
data3 = {x*y for x in data1 if x % 2 == 1
        	 for y in data2 if y % 2 == 0}
print(data3)
```

- 결과 : {2, 4, 6, 10, 12, 20}

## 2. 딕셔너리

### 2.1. 딕셔너리 만들기

키 데이터와 관련된 데이터를 연결한 자료구조, 데이터의 중복을 허용하지 않음

- 중광호 {} 안에 **키 : 값** 형식을 가진 유일한 데이터를 콤마로 구분해 하나 이상 저장 할 수 있는 컬렉션 자료형

  `딕셔너리 = {키1: 값1, 키2: 값2}`

- 인덱스 제공 X , 순서의 개념 없음

- 키는 문자열, 정수, 실수, 불 도 사용할 수 있고 자료형을 섞어서 사용할 수도 있다.

- 중복을 허용하지 않아, 동일한 키가 존재 할 경우, 나중에 오는 값만 저장된다.

  ```python
  >>> lux = {'health': 490, 'health': 800, 'mana': 334, 'melee': 550, 'armor': 18.72}
  >>> lux['health']    # 키가 중복되면 가장 뒤에 있는 값만 사용함
  800
  >>> lux    # 중복되는 키는 저장되지 않음
  {'health': 800, 'mana': 334, 'melee': 550, 'armor': 18.72}
  ```

- 빈 딕셔너리 만들기
  - `딕셔너리 = {}`
  - `딕셔너리 = dict()`

#### 2.1.1. dict()를 이용한 생성

- `딕셔너리 = dict(키1=값1, 키2=값2)`

  ```python
  >>> lux1 = dict(health=490, mana=334, melee=550, armor=18.72)    # 키=값 형식으로 딕셔너리를 만듦
  >>> lux1
  {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
  ```

  dict에서  **`키=값`** 형식으로 딕셔너리를 만들 수 있다. 이때는 키에 ' '(작은따옴표)나 " "(큰따옴표)를 사용하면 안된다. 키는 딕셔너리를 만들고 나면 문자열로 바뀐다.

- `딕셔너리 = dict(zip([키1, 키2], [값1, 값2]))`

  ```python
  >>> lux2 = dict(zip(['health', 'mana', 'melee', 'armor'], [490, 334, 550, 18.72]))    # zip 함수로
  >>> lux2                                                            # 키 리스트와 값 리스트를 묶음
  {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
  ```

  dict에서 zip 함수를 이용한다. 다음과 같이 키가 들어있는 리스트와 값이 들어있는 리스트를 차례대로 zip에 넣은 뒤 다시 dict에 넣어주면 된다.

- `딕셔너리 = dict([(키1, 값1), (키2, 값2)])`

  ```python
  >>> lux3 = dict([('health', 490), ('mana', 334), ('melee', 550), ('armor', 18.72)])
  >>> lux3                                                  # (키, 값) 형식의 튜플로 딕셔너리를 만듦
  {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
  ```

   **(키, 값)** 형식의 튜플을 리스트로나열하는 방법

- `딕셔너리 = dict([(키1, 값1), (키2, 값2)])`

  ```python
  >>> lux3 = dict((('health', 490), ('mana', 334), ('melee', 550), ('armor', 18.72)))
  >>> lux3                                                  # (키, 값) 형식의 튜플로 딕셔너리를 만듦
  {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
  ```

   **(키, 값)** 형식의 튜플을 튜플로나열하는 방법

- `딕셔너리 = dict([(키1, 값1), (키2, 값2)])`

  ```python
  >>> lux3 = dict({('health', 490), ('mana', 334), ('melee', 550), ('armor', 18.72)})
  >>> lux3                                                  # (키, 값) 형식의 튜플로 딕셔너리를 만듦
  {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
  ```

   **(키, 값)** 형식의 튜플을 셋으로나열하는 방법

- `딕셔너리 = dict({키1: 값1, 키2: 값2})`

  ```python
  >>> lux4 = dict({'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72})     # dict 안에서
  >>> lux4                                                           # 중괄호로 딕셔너리를 만듦
  {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
  ```

  dict 안에서 중괄호로 딕셔너리를 생성하는 방법

#### 2.1.2. dict.fromkeys()를 이용한 생성

- `딕셔너리 = dict.fromkeys(key리스트 또는 튜플)`

  ```python
  >>> keys = ['a', 'b', 'c', 'd']
  >>> x = dict.fromkeys(keys)
  >>> x
  {'a': None, 'b': None, 'c': None, 'd': None}
  ```

  리스트나 튜플에 있는 key 값을 이용하여 딕셔너리를 만드는 방법으로 기본값이 None으로 설정됨

- `딕셔너리 = dict.fromkeys(key리스트 또는 튜플, 기본값)`

  ```python
  >>> keys = ['a', 'b', 'c', 'd']
  >>> y = dict.fromkeys(keys, 100)
  >>> y
  {'a': 100, 'b': 100, 'c': 100, 'd': 100}
  ```

  리스트나 튜플에 있는 key 값을 이용하여 딕셔너리를 만드는 방법으로 기본값을 넣으면 해당 값으로 기본값이 설정됨

#### 2.1.3. defaultdict()를 이용한 생성

`defaultdict(기본값생성함수)`

다음은 기본값이 0인 defaultdict 딕셔너리를 만든다.

```python
>>> from collections import defaultdict    # collections 모듈에서 defaultdict를 가져옴
>>> y = defaultdict(int)    # int로 기본값 생성
```

딕셔너리 y에는 키 'z'가 없지만 y['z']와 같이 키의 값을 가져와보면 0이 나온다. 왜냐하면 기본값을 0으로 설정했기 때문이다.

```python
>>> y['z']
0
```

int는 실수나 문자열을 정수로 변환하지만, 다음과 같이 int에 아무것도 넣지 않고 호출하면 0을 반환한다.

```python
>>> int()
0
```

defaultdict에는 특정 값을 반환하는 함수를 넣어주면 되는데, defaultdict(int)는 기본값 생성 함수로 int를 지정하여 0이 나오도록 만든 것이다.

0이 아닌 다른 값을 기본값으로 설정하고 싶다면 다음과 같이 기본값 생성 함수를 만들어서 넣어주면 된다

```python
>>> z = defaultdict(lambda: 'python')
>>> z['a']
'python'
>>> z[0]
'python'
```

### 2.2. 딕셔너리 사용법

#### 2.2.1. 딕셔너리 키에 접근하기

`딕셔너리[키]`

```python
>>> lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
>>> lux['health']
490
>>> lux['armor']
18.72
```

딕셔너리의 키에 접근할 때는 딕셔너리 뒤에 `[]`(대괄호)를 사용하며 [ ] 안에 키를 지정해주면 된다.

> 참고 | 딕셔너리에 키를 지정하지 않으면?
>
> 딕셔너리에 키를 지정하지 않은 상태는 해당 딕셔너리 전체를 뜻한다. 따라서 다음과 같이 딕셔너리 lux를 출력하면 { }를 포함하여 딕셔너리 전체가 출력된다.
>
> ```python
> >>> lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
> >>> lux    # 딕셔너리에 키를 지정하지 않으면 딕셔너리 전체를 뜻함
> {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
> ```

#### 2.2.1. 딕셔너리의 키에 값 할당하기

`딕셔너리[키] = 값`

```python
>>> lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
>>> lux['health'] = 2037    # 키 'health'의 값을 2037로 변경
>>> lux['mana'] = 1184      # 키 'mana'의 값을 1184로 변경
>>> lux
{'health': 2037, 'mana': 1184, 'melee': 550, 'armor': 18.72}
```

딕셔너리에서 키의 값을 출력할 때와 마찬가지로 [ ]에 키를 지정한 뒤 값을 할당하면 된다.

key가 **문자열**일 경우에는 `update[key=값]`을 이용하여 값을 수정할 수 있다. 이때 key값이 문자열이지만, `''`나 `""`는 사용하지 않는 것을 주의해야 한다.

```python
>>> x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}
>>> x.update(a=90)  # 'a'=90이 아니고 a=90으로 표현해야 함
>>> x
{'a': 90, 'b': 20, 'c': 30, 'd': 40}
```

아래 처럼 여러개의 값을 변경할 수도 있다.

```python
>>> x.update(a=900, f=60)
>>> x
{'a': 900, 'b': 20, 'c': 30, 'd': 40, 'e': 50, 'f': 60}
```

만약 key가 문자열이 아니고 숫자일 경우에는 `update(딕셔너리)`, `update(리스트 또는 튜플)`, `update(반복가능한객체)`형식으로 딕셔너리를 넣어 값을 수정할 수 있다.

```python
#update(딕셔너리)
>>> y = {1: 'one', 2: 'two'}
>>> y.update({1: 'ONE', 3: 'THREE'})
>>> y
{1: 'ONE', 2: 'two', 3: 'THREE'}

#update(리스트 또는 튜플)
>>> y.update([[2, 'TWO'], [4, 'FOUR']])
>>> y
{1: 'ONE', 2: 'TWO', 3: 'THREE', 4: 'FOUR'}

#update(반복가능한객체)
>>> y.update(zip([1, 2], ['one', 'two']))
>>> y
{1: 'one', 2: 'two', 3: 'THREE', 4: 'FOUR'}
```

> setdefault와 update의 차이
>
> setdefault는 키-값 쌍 추가만 할 수 있고, 이미 들어있는 키의 값은 수정할 수 없다. 하지만 update는 키-값 쌍 추가와 값 수정이 모두 가능하다.

#### 2.2.2. 딕셔너리 항목 추가

딕셔너리는 **없는 키에 값을 할당하면 해당 키가 추가되고 값이 할당**된다.

```python
>>> lux['mana_regen'] = 3.28    # 키 'mana_regen'을 추가하고 값 3.28 할당
>>> lux
{'health': 2037, 'mana': 1184, 'melee': 550, 'armor': 18.72, 'mana_regen': 3.28}
```

만약, key만 있고 값이 None인 쌍을 추가하고 싶으면 `setdefault(key)`를 이용한다.

```python
x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}
x.setdefault('e')
print(x)

```

> 결과 :` {'a': 10, 'b': 20, 'c': 30, 'd': 40, 'e': None}`

 `setdefault(key, 기본값)`을 이용하여 원하는 값을 넣어서 항목을 추가할 수 있다.

```python
x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}
x.setdefault('e', 100)
print(x)
```

> 결과 : `{'a': 10, 'b': 20, 'c': 30, 'd': 40, 'e': 100}`

#### 2.2.3. 딕셔너리 항목 확인

- `키 in 딕셔너리`

  ```python
  >>> lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
  >>> 'health' in lux
  True
  >>> 'attack_speed' in lux
  False
  ```

  - 딕셔너리에 특정 키가 있으면 `True` 없으면 `False`를 반환한다.

- `키 not in 딕셔너리`

  ```python
  >>> 'attack_speed' not in lux
  True
  >>> 'health' not in lux
  False
  ```

  - 딕셔너리에 특정 키가 없으면 `True` 있으면 `False`를 반환한다.

  > 참고 | 해시
  >
  > 딕셔너리는 해시(Hash) 기법을 이용해서 데이터를 저장한다. 보통 딕셔너리와 같은 키-값 형태의 자료형을 해시, 해시 맵, 해시테이블 등으로 부른다.

- `len(딕셔너리)` : 항목 갯수 확인

  ```python
  >>> lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
  >>> len(lux)
  4
  >>> len({'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72})
  4
  ```

#### 2.2.4. 딕셔너리 항목 삭제하기

- `pop(key)` : key에 해당하는 쌍을 삭제한 뒤 삭제한 쌍의 값을 반환한다.

  ```python
  >>> x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}
  >>> x.pop('a')
  10
  >>> x
  {'b': 20, 'c': 30, 'd': 40}
  ```

- `pop(key, 기본값)` : 기본값을 지정하면 딕셔너리에 키가 있을 때는 해당 키-값 쌍을 삭제한 값을 반환하지만 키가 없을 떄는 기본값만 반환한다.

  ```python
  >>> x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}
  >>> x.pop('z', 0)
  0
  ```

- `del 딕셔너리이름[key]`

  ```python
  >>> x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}
  >>> del x['a']
  >>> x
  {'b': 20, 'c': 30, 'd': 40}
  ```

- `popitem()` : **파이썬 3.6 이상**을 기준으로 딕셔너리에서 **마지막 키-값의 쌍을 삭제**하게 되고, **3.5이하의 버전**에서는 **임의의 키-값**을 삭제하기 때문에 매번 실행할 때 마다 삭제되는 값이 달라지게 된다.

  ```python
  >>> x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}
  >>> x.popitem()
  ('d', 40)
  >>> x
  {'a': 10, 'b': 20, 'c': 30}
  ```

- `clear()` : 딕셔너리의 모든 항목을 삭제

  ```python
  >>> x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}
  >>> x.clear()
  >>> x
  {}
  ```

#### 2.2.5. 딕셔너리 키, 값, 항목 읽기

- `get(key)` : 딕셔너리에서 키의 값을 가져온다.

```
>>> x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}
>>> x.get('a')
10
```

- `get(key, 기본값)` : 딕셔너리에서 키의 값을 가져오지만, key가 존재하지 않는다면 기본값을 반환한다.

```python
>>> x.get('z', 0)
0
```

- `items()` : 딕셔너리의 모든 `키-값`의 쌍을 반환함

```python
>>> x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}
>>> x.items()
dict_items([('a', 10), ('b', 20), ('c', 30), ('d', 40)])
```

- `keys()` : 모든 키를 반환함

```python
>>> x.keys()
dict_keys(['a', 'b', 'c', 'd'])
```

- `values()`: 모든 값을 반환함

```python
>>> x.values()
dict_values([10, 20, 30, 40])
```

### 2.3. 반복문으로 딕셔너리의 키-값 출력하기

- 키 출력하기

  ```python
  >>> x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}
  >>> for i in x:
  ...     print(i, end=' ')
  ...
  a b c d
  ```

  또는 ` for key in 딕셔너리.keys():`

  ```python
  >>> x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}
  >>> for key in x.keys():
  ...     print(key, end=' ')
  ...
  a b c d
  ```

- 값 출력하기

  `for value in 딕셔너리.values():`

  ```python
  >>> x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}
  >>> for value in x.values():
  ...     print(value, end=' ')
  ...
  10 20 30 40
  ```

- 키 - 값 출력하기

  `for 키, 값 in 딕셔너리.items():`

  ```python
  >>> x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}
  >>> for key, value in x.items():
  ...     print(key, value)
  ...
  a 10
  b 20
  c 30
  d 40
  ```

### 2.4. 딕셔너리 표현식 사용하기

