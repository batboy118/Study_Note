# 11. 셋과 딕셔너리

> 파이썬 자료구조 중 셋과 딕셔너리에 대해서 학습합니다.

[🏠Home](https://github.com/batboy118/Study_Note)

[◀Previous page ](./README.md)

---

<!-- TOC -->

- [1. 셋](#1-셋)
	- [1.1. 셋 만들기](#11-셋-만들기)
	- [1.2. 셋 사용법](#12-셋-사용법)
		- [1.2.1. 셋의 기본 연산](#121-셋의-기본-연산)
		- [1.2.2. 셋의 항목 추가](#122-셋의-항목-추가)
		- [1.2.3. 셋의 항목 제거](#123-셋의-항목-제거)
		- [1.2.4. 셋의 항목 확인](#124-셋의-항목-확인)
		- [1.2.5. 부분 집합의 포함 관계](#125-부분-집합의-포함-관계)
		- [1.2.5. for 문을 이용한 셋 항목 접근](#125-for-문을-이용한-셋-항목-접근)
		- [1.2.6. 셋 내포의 특징](#126-셋-내포의-특징)
- [2. 딕셔너리](#2-딕셔너리)
	- [2.1. 딕셔너리 만들기](#21-딕셔너리-만들기)
		- [2.1.1. dict()를 이용한 생성](#211-dict를-이용한-생성)
	- [2.2. 딕셔너리 사용법](#22-딕셔너리-사용법)
		- [2.2.1. 딕셔너리 키에 접근하기](#221-딕셔너리-키에-접근하기)
		- [2.2.1. 딕셔너리의 키에 값 할당하기](#221-딕셔너리의-키에-값-할당하기)
		- [2.2.2. 딕셔너리 항목 추가](#222-딕셔너리-항목-추가)
		- [2.2.3. 딕셔너리 항목 확인](#223-딕셔너리-항목-확인)

<!-- /TOC -->

## 1. 셋

### 1.1. 셋 만들기

중복되지 않는 데이터를 만들기 위해 사용하는 자료구조

- `{ }` 안에 서로 다른 자료형의 유일한 값을 `콤마(,)로 구분`해 하나 이상 저장할 수 있는 컬렉션 자료형 중 하나

- 인덱스 없음, 순서의 개념 없음, 중복 허용하지 않음

- range 함수를 이용하여 set 생성 가능

  ```python
  data = set(range(10,21,2))
  ```

- 문자열을 set()함수를 사용하여 변환하면 개별 문자를 원소로 가지게 됨

  ```python
  data = set("A B c d d")
  data
  ```

  - 결과 : `{' ', A', 'B', 'c', 'd'}`

### 1.2. 셋 사용법

#### 1.2.1. 셋의 기본 연산

- 교집합 :

  1. `&`

     ```python
     data1 = {1,2,3}
     data2 = {2,3,4}
     data3 = data1 & data2
     data3
     ```

     - 결과 : `{2, 3}`

  2. `set1.intersection(set2)`

     ```python
     data1 = {1,2,3}
     data2 = {2,3,4}
     data3 = data1.intersection(data2)
     data3
     ```

     - 결과 : `{2, 3}`

- 합집합 : 중복 원소는 한번만 생성 됨

  1. `|`

     ```python
     data1 = {1,2,3}
     data2 = {2,3,4}
     data3 = data1 | data2
     data3
     ```

     - 결과 : `{1, 2, 3, 4}`

  2. `set1.union(set2)`

     ```python
     data1 = {1,2,3}
     data2 = {2,3,4}
     data3 = data1.union(data2)
     data3
     ```

     - 결과 : `{1, 2, 3, 4}`

- 차집함 :

  1. `-`

     ```python
     data1 = {1,2,3}
     data2 = {2,3,4}
     data3 = data1 - data2
     data3
     ```

     - 결과 : `{1}`

  2. `set1.difference(set2)`

     ```python
     data1 = {1,2,3}
     data2 = {2,3,4}
     data3 = data1.difference(data2)
     data3
     ```

     - 결과 : `{1}`

#### 1.2.2. 셋의 항목 추가

-  하나의 항목 추가 : `set.add(값)`

  ```python
  data = {1, 2, 3}
  data.add(4)
  print(data)
  ```

  - 결과 : `{1, 2, 3, 4}`

- 셋을 이용한 여러개 항목 추가 : `set1.update(set2)`

  ```python
  data = {1, 2, 3}
  data.update({3, 4, 5})
  print(data)
  ```

  - 결과 : `{1, 2, 3, 4, 5}`

#### 1.2.3. 셋의 항목 제거

-  특정 원소 제거 : `set.remove(값)`
  -  없을 때 **에러 메시지**를 출력
- 특정 원소 제거 : `set.discard(값)`
  - 없을 때 그냥 무시
- 임의의 값을 반환하며 삭제 : `set.pop()`
- 모든 항목 제거 : `set.clear()`

#### 1.2.4. 셋의 항목 확인

- `값 in set` : 셋객체에 해당 값이 있으면 true 반환, 없으면 false 반환
- `값 not in set` : 셋객체에 해당 값이 없으면 true 반환, 있으면 false 반환

#### 1.2.5. 부분 집합의 포함 관계

- `set1.issuperset(set2)`

  - set1이 set2 전체를 포함하고 있으면 True, 아니면 False를 반환

  ![image](https://user-images.githubusercontent.com/53181778/78338105-ae140500-7581-11ea-9534-f7213961e51e.png)

- `set1.issubset(set2)`

  - set1이 set2에 포함되면 True, 아니면 False를 반환

    ![image](https://user-images.githubusercontent.com/53181778/78338136-bb30f400-7581-11ea-8b0b-820e129dc51e.png)

#### 1.2.5. for 문을 이용한 셋 항목 접근

```python
data_set = set(range(0, 11, 2))

for item in data_set:
    print("{0}".format(item), end=" ")
```

- 결과 : 0 2 4 6 8 10

#### 1.2.6. 셋 내포의 특징

```python
data1 = {1, 2, 3, 4, 5}
data2 = {item for item in data1 if item % 2 == 1}
print(data2)
```

- 결과 : {1, 3, 5}

```python
data1 = {1, 2, 3, 4, 5}
data2 = {1, 2, 3, 4, 5}
data3 = {x*y for x in data1 if x % 2 == 1
        	 for y in data2 if y % 2 == 0}
print(data3)
```

- 결과 : {2, 4, 6, 10, 12, 20}

## 2. 딕셔너리

### 2.1. 딕셔너리 만들기

키 데이터와 관련된 데이터를 연결한 자료구조, 데이터의 중복을 허용하지 않음

- 중광호 {} 안에 **키 : 값** 형식을 가진 유일한 데이터를 콤마로 구분해 하나 이상 저장 할 수 있는 컬렉션 자료형

  `딕셔너리 = {키1: 값1, 키2: 값2}`

- 인덱스 제공 X , 순서의 개념 없음

- 키는 문자열, 정수, 실수, 불 도 사용할 수 있고 자료형을 섞어서 사용할 수도 있다.

- 중복을 허용하지 않아, 동일한 키가 존재 할 경우, 나중에 오는 값만 저장된다.

  ```python
  >>> lux = {'health': 490, 'health': 800, 'mana': 334, 'melee': 550, 'armor': 18.72}
  >>> lux['health']    # 키가 중복되면 가장 뒤에 있는 값만 사용함
  800
  >>> lux    # 중복되는 키는 저장되지 않음
  {'health': 800, 'mana': 334, 'melee': 550, 'armor': 18.72}
  ```

- 빈 딕셔너리 만들기
  - `딕셔너리 = {}`
  - `딕셔너리 = dict()`

#### 2.1.1. dict()를 이용한 생성

- `딕셔너리 = dict(키1=값1, 키2=값2)`

  ```python
  >>> lux1 = dict(health=490, mana=334, melee=550, armor=18.72)    # 키=값 형식으로 딕셔너리를 만듦
  >>> lux1
  {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
  ```

  dict에서  **`키=값`** 형식으로 딕셔너리를 만들 수 있다. 이때는 키에 ' '(작은따옴표)나 " "(큰따옴표)를 사용하면 안된다. 키는 딕셔너리를 만들고 나면 문자열로 바뀐다.

- `딕셔너리 = dict(zip([키1, 키2], [값1, 값2]))`

  ```python
  >>> lux2 = dict(zip(['health', 'mana', 'melee', 'armor'], [490, 334, 550, 18.72]))    # zip 함수로
  >>> lux2                                                            # 키 리스트와 값 리스트를 묶음
  {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
  ```

  dict에서 zip 함수를 이용한다. 다음과 같이 키가 들어있는 리스트와 값이 들어있는 리스트를 차례대로 zip에 넣은 뒤 다시 dict에 넣어주면 된다.

- `딕셔너리 = dict([(키1, 값1), (키2, 값2)])`

  ```python
  >>> lux3 = dict([('health', 490), ('mana', 334), ('melee', 550), ('armor', 18.72)])
  >>> lux3                                                  # (키, 값) 형식의 튜플로 딕셔너리를 만듦
  {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
  ```

   **(키, 값)** 형식의 튜플을 리스트로나열하는 방법

- `딕셔너리 = dict([(키1, 값1), (키2, 값2)])`

  ```python
  >>> lux3 = dict((('health', 490), ('mana', 334), ('melee', 550), ('armor', 18.72)))
  >>> lux3                                                  # (키, 값) 형식의 튜플로 딕셔너리를 만듦
  {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
  ```

   **(키, 값)** 형식의 튜플을 튜플로나열하는 방법

- `딕셔너리 = dict([(키1, 값1), (키2, 값2)])`

  ```python
  >>> lux3 = dict({('health', 490), ('mana', 334), ('melee', 550), ('armor', 18.72)})
  >>> lux3                                                  # (키, 값) 형식의 튜플로 딕셔너리를 만듦
  {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
  ```

   **(키, 값)** 형식의 튜플을 셋으로나열하는 방법

- `딕셔너리 = dict({키1: 값1, 키2: 값2})`

  ```python
  >>> lux4 = dict({'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72})     # dict 안에서
  >>> lux4                                                           # 중괄호로 딕셔너리를 만듦
  {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
  ```

  dict 안에서 중괄호로 딕셔너리를 생성하는 방법

### 2.2. 딕셔너리 사용법

#### 2.2.1. 딕셔너리 키에 접근하기

`딕셔너리[키]`

```python
>>> lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
>>> lux['health']
490
>>> lux['armor']
18.72
```

딕셔너리의 키에 접근할 때는 딕셔너리 뒤에 `[]`(대괄호)를 사용하며 [ ] 안에 키를 지정해주면 된다.

> 참고 | 딕셔너리에 키를 지정하지 않으면?
>
> 딕셔너리에 키를 지정하지 않은 상태는 해당 딕셔너리 전체를 뜻한다. 따라서 다음과 같이 딕셔너리 lux를 출력하면 { }를 포함하여 딕셔너리 전체가 출력된다.
>
> ```python
> >>> lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
> >>> lux    # 딕셔너리에 키를 지정하지 않으면 딕셔너리 전체를 뜻함
> {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
> ```

#### 2.2.1. 딕셔너리의 키에 값 할당하기

`딕셔너리[키] = 값`

```python
>>> lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
>>> lux['health'] = 2037    # 키 'health'의 값을 2037로 변경
>>> lux['mana'] = 1184      # 키 'mana'의 값을 1184로 변경
>>> lux
{'health': 2037, 'mana': 1184, 'melee': 550, 'armor': 18.72}
```

딕셔너리에서 키의 값을 출력할 때와 마찬가지로 [ ]에 키를 지정한 뒤 값을 할당하면 된다.

#### 2.2.2. 딕셔너리 항목 추가

딕셔너리는 **없는 키에 값을 할당하면 해당 키가 추가되고 값이 할당**된다.

```python
>>> lux['mana_regen'] = 3.28    # 키 'mana_regen'을 추가하고 값 3.28 할당
>>> lux
{'health': 2037, 'mana': 1184, 'melee': 550, 'armor': 18.72, 'mana_regen': 3.28}
```

#### 2.2.3. 딕셔너리 항목 확인

- `키 in 딕셔너리`

  ```python
  >>> lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
  >>> 'health' in lux
  True
  >>> 'attack_speed' in lux
  False
  ```

  - 딕셔너리에 특정 키가 있으면 `True` 없으면 `False`를 반환한다.

- `키 not in 딕셔너리`

  ```python
  >>> 'attack_speed' not in lux
  True
  >>> 'health' not in lux
  False
  ```

  - 딕셔너리에 특정 키가 없으면 `True` 있으면 `False`를 반환한다.

  > 참고 | 해시
  >
  > 딕셔너리는 해시(Hash) 기법을 이용해서 데이터를 저장한다. 보통 딕셔너리와 같은 키-값 형태의 자료형을 해시, 해시 맵, 해시테이블 등으로 부른다.

- `len(딕셔너리)` : 항목 갯수 확인

  ```python
  >>> lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
  >>> len(lux)
  4
  >>> len({'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72})
  4
  ```

